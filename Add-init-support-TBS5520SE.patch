diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/Kconfig" "b/drivers/media/dvb-frontends/Kconfig"
--- "a/drivers/media/dvb-frontends/Kconfig"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/dvb-frontends/Kconfig"	2018-01-17 18:32:32.568183000 +0800
@@ -841,6 +841,13 @@
 	help
 	  A DVB-S tuner module. Say Y when you want to support this frontend.
 
+config DVB_SI2183
+	tristate "Silicon Labs Si2183"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Say Y when you want to support this frontend.
+
 config DVB_M88RS2000
 	tristate "M88RS2000 DVB-S demodulator and tuner"
 	depends on DVB_CORE && I2C
diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/Makefile" "b/drivers/media/dvb-frontends/Makefile"
--- "a/drivers/media/dvb-frontends/Makefile"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/dvb-frontends/Makefile"	2018-01-17 18:33:32.823399000 +0800
@@ -124,5 +124,6 @@
 obj-$(CONFIG_DVB_GP8PSK_FE) += gp8psk-fe.o
 obj-$(CONFIG_DVB_TC90522) += tc90522.o
 obj-$(CONFIG_DVB_HORUS3A) += horus3a.o
+obj-$(CONFIG_DVB_SI2183) += si2183.o
 obj-$(CONFIG_DVB_ASCOT2E) += ascot2e.o
 obj-$(CONFIG_DVB_HELENE) += helene.o
diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/mn88473.c" "b/drivers/media/dvb-frontends/mn88473.c"
--- "a/drivers/media/dvb-frontends/mn88473.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/dvb-frontends/mn88473.c"	2018-01-28 19:52:29.063015000 +0800
@@ -223,6 +223,32 @@
 	if (ret)
 		goto err;
 
+	/* PLP ID write in 0x32 and 0x36 registers(MPLP) */
+	if (c->delivery_system == SYS_DVBT2) {
+		ret = regmap_write(dev->regmap[2], 0x32,
+			(c->stream_id == NO_STREAM_ID_FILTER) ? 0x80 : 0);
+		if (ret)
+			goto err;
+
+		ret = regmap_write(dev->regmap[2], 0x36,
+			(c->stream_id == NO_STREAM_ID_FILTER) ? 0 : c->stream_id);
+		if (ret)
+			goto err;
+	}
+
+	/* PLP ID write in 0x32 and 0x36 registers(MPLP) */
+	if (c->delivery_system == SYS_DVBT2) {
+		ret = regmap_write(dev->regmap[2], 0x32,
+			(c->stream_id == NO_STREAM_ID_FILTER) ? 0x80 : 0);
+		if (ret)
+			goto err;
+
+		ret = regmap_write(dev->regmap[2], 0x36,
+			(c->stream_id == NO_STREAM_ID_FILTER) ? 0 : c->stream_id);
+		if (ret)
+			goto err;
+	}
+
 	/* Reset FSM */
 	ret = regmap_write(dev->regmap[2], 0xf8, 0x9f);
 	if (ret)
@@ -429,7 +455,8 @@
 			FE_CAN_GUARD_INTERVAL_AUTO     |
 			FE_CAN_HIERARCHY_AUTO          |
 			FE_CAN_MUTE_TS                 |
-			FE_CAN_2G_MODULATION
+			FE_CAN_2G_MODULATION           |
+			FE_CAN_MULTISTREAM
 	},
 
 	.get_tune_settings = mn88473_get_tune_settings,
diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/si2168.c" "b/drivers/media/dvb-frontends/si2168.c"
--- "a/drivers/media/dvb-frontends/si2168.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/dvb-frontends/si2168.c"	2018-01-23 19:12:33.968928000 +0800
@@ -85,7 +85,8 @@
 	struct i2c_client *client = fe->demodulator_priv;
 	struct si2168_dev *dev = i2c_get_clientdata(client);
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	int ret;
+	int ret, i;
+	unsigned int utmp, utmp1, utmp2;
 	struct si2168_cmd cmd;
 
 	*status = 0;
@@ -95,7 +96,7 @@
 		goto err;
 	}
 
-	switch (c->delivery_system) {
+	switch (dev->delivery_system) {
 	case SYS_DVBT:
 		memcpy(cmd.args, "\xa0\x01", 2);
 		cmd.wlen = 2;
@@ -106,6 +107,11 @@
 		cmd.wlen = 2;
 		cmd.rlen = 9;
 		break;
+	case SYS_DVBC_ANNEX_B:
+		memcpy(cmd.args, "\x98\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 10;
+		break;
 	case SYS_DVBT2:
 		memcpy(cmd.args, "\x50\x01", 2);
 		cmd.wlen = 2;
@@ -133,9 +139,11 @@
 	dev->fe_status = *status;
 
 	if (*status & FE_HAS_LOCK) {
-		c->cnr.len = 1;
+		c->cnr.len = 2;
 		c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
-		c->cnr.stat[0].svalue = cmd.args[3] * 1000 / 4;
+		c->cnr.stat[0].svalue = (s64)cmd.args[3] * 250;
+		c->cnr.stat[1].scale = FE_SCALE_RELATIVE;
+		c->cnr.stat[1].uvalue = (s64)cmd.args[3] * 328;
 	} else {
 		c->cnr.len = 1;
 		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
@@ -144,12 +152,146 @@
 	dev_dbg(&client->dev, "status=%02x args=%*ph\n",
 			*status, cmd.rlen, cmd.args);
 
+	/* BER */
+	if (*status & FE_HAS_VITERBI) {
+		memcpy(cmd.args, "\x82\x00", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 3;
+		ret = si2168_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+
+		/*
+		 * Firmware returns [0, 255] mantissa and [0, 8] exponent.
+		 * Convert to DVB API: mantissa * 10^(8 - exponent) / 10^8
+		 */
+		utmp = clamp(8 - cmd.args[1], 0, 8);
+		for (i = 0, utmp1 = 1; i < utmp; i++)
+			utmp1 = utmp1 * 10;
+
+		utmp1 = cmd.args[2] * utmp1;
+		utmp2 = 100000000; /* 10^8 */
+
+		dev_dbg(&client->dev,
+			"post_bit_error=%u post_bit_count=%u ber=%u*10^-%u\n",
+			utmp1, utmp2, cmd.args[2], cmd.args[1]);
+
+		c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		c->post_bit_error.stat[0].uvalue += utmp1;
+		c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		c->post_bit_count.stat[0].uvalue += utmp2;
+	} else {
+		c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+
+	/* UCB */
+	if (*status & FE_HAS_SYNC) {
+		memcpy(cmd.args, "\x84\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 3;
+		ret = si2168_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+
+		utmp1 = cmd.args[2] << 8 | cmd.args[1] << 0;
+		dev_dbg(&client->dev, "block_error=%u\n", utmp1);
+
+		/* Sometimes firmware returns bogus value */
+		if (utmp1 == 0xffff)
+			utmp1 = 0;
+
+		c->block_error.stat[0].scale = FE_SCALE_COUNTER;
+		c->block_error.stat[0].uvalue += utmp1;
+	} else {
+		c->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+
 	return 0;
 err:
 	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
 }
 
+static int si2168_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int i;
+
+	*snr = 0;
+	for (i=0; i < c->cnr.len; i++)
+		if (c->cnr.stat[i].scale == FE_SCALE_RELATIVE)
+		  *snr = (u16)c->cnr.stat[i].uvalue;
+	return 0;
+}
+
+static int si2168_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int i;
+
+	*strength = 0;
+	for (i=0; i < c->strength.len; i++)
+	{
+		if (c->strength.stat[i].scale == FE_SCALE_RELATIVE)
+			*strength = (u16)c->strength.stat[i].uvalue;
+		else if (c->strength.stat[i].scale == FE_SCALE_DECIBEL)
+			*strength = ((100000 + (s32)c->strength.stat[i].svalue)/1000) * 656;
+	}
+	return 0;
+}
+
+static int si2168_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2168_dev *dev = i2c_get_clientdata(client);
+	struct si2168_cmd cmd;
+	int ret;
+	
+	if (dev->fe_status & FE_HAS_LOCK) {
+		memcpy(cmd.args, "\x82\x00", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 3;
+		ret = si2168_cmd_execute(client, &cmd);
+		if (ret) {
+			dev_err(&client->dev, "read_ber fe%d cmd_exec failed=%d\n", fe->id, ret);
+			goto err;
+		}
+		*ber = (u32)cmd.args[2] * cmd.args[1] & 0xf;
+	} else *ber = 1;
+
+	return 0;
+err:
+	dev_err(&client->dev, "read_ber failed=%d\n", ret);
+	return ret;
+}
+
+static int si2168_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2168_dev *dev = i2c_get_clientdata(client);
+	struct si2168_cmd cmd;
+	int ret;
+	
+	if (dev->stat_resp & 0x10) {
+		memcpy(cmd.args, "\x84\x00", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 3;
+		ret = si2168_cmd_execute(client, &cmd);
+		if (ret) {
+		dev_err(&client->dev, "read_ucblocks fe%d cmd_exec failed=%d\n", fe->id, ret);
+			goto err;
+		}
+
+		*ucblocks = (u16)cmd.args[2] << 8 | cmd.args[1];
+	} else 	*ucblocks = 0;
+
+	return 0;
+err:
+	dev_err(&client->dev, "read_ucblocks failed=%d\n", ret);
+	return ret;
+}
+
 static int si2168_set_frontend(struct dvb_frontend *fe)
 {
 	struct i2c_client *client = fe->demodulator_priv;
@@ -171,11 +313,19 @@
 	}
 
 	switch (c->delivery_system) {
+	case SYS_DVBC_ANNEX_B:
+		delivery_system = 0x10;
+		break;
 	case SYS_DVBT:
 		delivery_system = 0x20;
 		break;
 	case SYS_DVBC_ANNEX_A:
 		delivery_system = 0x30;
+		if (c->symbol_rate < 6000000) {
+			delivery_system = 0x10;
+			c->delivery_system = SYS_DVBC_ANNEX_B;
+			c->bandwidth_hz = 6000000;
+		}
 		break;
 	case SYS_DVBT2:
 		delivery_system = 0x70;
@@ -212,26 +362,6 @@
 			goto err;
 	}
 
-	memcpy(cmd.args, "\x88\x02\x02\x02\x02", 5);
-	cmd.wlen = 5;
-	cmd.rlen = 5;
-	ret = si2168_cmd_execute(client, &cmd);
-	if (ret)
-		goto err;
-
-	/* that has no big effect */
-	if (c->delivery_system == SYS_DVBT)
-		memcpy(cmd.args, "\x89\x21\x06\x11\xff\x98", 6);
-	else if (c->delivery_system == SYS_DVBC_ANNEX_A)
-		memcpy(cmd.args, "\x89\x21\x06\x11\x89\xf0", 6);
-	else if (c->delivery_system == SYS_DVBT2)
-		memcpy(cmd.args, "\x89\x21\x06\x11\x89\x20", 6);
-	cmd.wlen = 6;
-	cmd.rlen = 3;
-	ret = si2168_cmd_execute(client, &cmd);
-	if (ret)
-		goto err;
-
 	if (c->delivery_system == SYS_DVBT2) {
 		/* select PLP */
 		cmd.args[0] = 0x52;
@@ -298,6 +428,16 @@
 		if (ret)
 			goto err;
 	}
+	else if (c->delivery_system == SYS_DVBC_ANNEX_B) {
+		memcpy(cmd.args, "\x14\x00\x02\x16", 4);
+		cmd.args[4] = ((c->symbol_rate / 1000) >> 0) & 0xff;
+		cmd.args[5] = ((c->symbol_rate / 1000) >> 8) & 0xff;
+		cmd.wlen = 6;
+		cmd.rlen = 4;
+		ret = si2168_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+	}
 
 	memcpy(cmd.args, "\x14\x00\x0f\x10\x10\x00", 6);
 	cmd.wlen = 6;
@@ -355,11 +495,15 @@
 {
 	struct i2c_client *client = fe->demodulator_priv;
 	struct si2168_dev *dev = i2c_get_clientdata(client);
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret, len, remaining;
 	const struct firmware *fw;
 	struct si2168_cmd cmd;
 
 	dev_dbg(&client->dev, "\n");
+	
+	if (dev->active)
+		return 0;	
 
 	/* initialize */
 	memcpy(cmd.args, "\xc0\x12\x00\x0c\x00\x0d\x16\x00\x00\x00\x00\x00\x00", 13);
@@ -480,9 +624,60 @@
 		 dev->version >> 24 & 0xff, dev->version >> 16 & 0xff,
 		 dev->version >> 8 & 0xff, dev->version >> 0 & 0xff);
 
+	/* TER FEF */
+	memcpy(cmd.args, "\x51\x00", 2);
+	cmd.wlen = 2;
+	cmd.rlen = 12;
+	cmd.args[1] = (dev->fef_inv & 1) << 3 | (dev->fef_pin & 7);
+	dev_dbg(&client->dev, "args=%*ph\n", cmd.wlen, cmd.args);
+	
+	ret = si2168_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err set fef pip\n");
+	}
+
+	/* MP DEFAULTS */
+	memcpy(cmd.args, "\x88\x01\x01\x01\x01", 5);
+	cmd.wlen = 5;
+	cmd.rlen = 2;
+	switch (dev->fef_pin)
+	{
+	case SI2168_MP_A:
+		cmd.args[1] = dev->fef_inv ? 3 : 2;
+		break;
+	case SI2168_MP_B:
+		cmd.args[2] = dev->fef_inv ? 3 : 2;
+		break;
+	case SI2168_MP_C:
+		cmd.args[3] = dev->fef_inv ? 3 : 2;
+		break;
+	case SI2168_MP_D:
+		cmd.args[4] = dev->fef_inv ? 3 : 2;
+		break;
+	}
+	dev_dbg(&client->dev, "args=%*ph\n", cmd.wlen, cmd.args);
+	
+	ret = si2168_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err set mp defaults\n");
+	}
+
+	/* AGC */
+	memcpy(cmd.args, "\x89\x01\x06\x12\x00\x00", 6);
+	cmd.wlen = 6;
+	cmd.rlen = 3;
+	cmd.args[1] |= (dev->agc_inv & 1) << 7 | (dev->agc_pin & 7) << 4;
+	dev_dbg(&client->dev, "args=%*ph\n", cmd.wlen, cmd.args);
+
+	ret = si2168_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err set ter agc\n");
+	}
+
 	/* set ts mode */
-	memcpy(cmd.args, "\x14\x00\x01\x10\x10\x00", 6);
+	memcpy(cmd.args, "\x14\x00\x01\x10\x00\x00", 6);
 	cmd.args[4] |= dev->ts_mode;
+	cmd.args[4] |= dev->ts_clock_mode << 4;
 	if (dev->ts_clock_gapped)
 		cmd.args[4] |= 0x40;
 	cmd.wlen = 6;
@@ -491,12 +686,29 @@
 	if (ret)
 		goto err;
 
+	/* set ts freq to 10Mhz*/
+	memcpy(cmd.args, "\x14\x00\x0d\x10\xe8\x03", 6);
+	cmd.wlen = 6;
+	cmd.rlen = 4;
+	ret = si2168_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
 	dev->warm = true;
 warm:
+	/* Init stats here to indicate which stats are supported */
+	c->cnr.len = 1;
+	c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->post_bit_error.len = 1;
+	c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->post_bit_count.len = 1;
+	c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->block_error.len = 1;
+	c->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
 	dev->active = true;
 
 	return 0;
-
 err_release_firmware:
 	release_firmware(fw);
 err:
@@ -581,7 +793,7 @@
 }
 
 static const struct dvb_frontend_ops si2168_ops = {
-	.delsys = {SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A},
+	.delsys = {SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A, SYS_DVBC_ANNEX_B},
 	.info = {
 		.name = "Silicon Labs Si2168",
 		.symbol_rate_min = 1000000,
@@ -615,6 +827,10 @@
 	.set_frontend = si2168_set_frontend,
 
 	.read_status = si2168_read_status,
+	.read_signal_strength	= si2168_read_signal_strength,
+	.read_snr		= si2168_read_snr,
+	.read_ber		= si2168_read_ber,
+	.read_ucblocks		= si2168_read_ucblocks,
 };
 
 static int si2168_probe(struct i2c_client *client,
@@ -630,7 +846,6 @@
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev) {
 		ret = -ENOMEM;
-		dev_err(&client->dev, "kzalloc() failed\n");
 		goto err;
 	}
 
@@ -674,6 +889,9 @@
 	case SI2168_CHIP_ID_B40:
 		dev->firmware_name = SI2168_B40_FIRMWARE;
 		break;
+	case SI2168_CHIP_ID_D60:
+		dev->firmware_name = SI2168_D60_FIRMWARE;
+		break;
 	default:
 		dev_dbg(&client->dev, "unknown chip version Si21%d-%c%c%c\n",
 			cmd.args[2], cmd.args[1], cmd.args[3], cmd.args[4]);
@@ -703,8 +921,16 @@
 	*config->i2c_adapter = dev->muxc->adapter[0];
 	*config->fe = &dev->fe;
 	dev->ts_mode = config->ts_mode;
+	dev->ts_clock_mode = config->ts_clock_mode;
 	dev->ts_clock_inv = config->ts_clock_inv;
 	dev->ts_clock_gapped = config->ts_clock_gapped;
+	dev->fef_pin = config->fef_pin;
+	dev->fef_inv = config->fef_inv;
+	dev->agc_pin = config->agc_pin;
+	dev->agc_inv = config->agc_inv;
+
+	if (!dev->agc_pin) dev->agc_pin = SI2168_MP_A;
+	if (!dev->fef_pin) dev->fef_pin = SI2168_MP_B;
 
 	dev_info(&client->dev, "Silicon Labs Si2168-%c%d%d successfully identified\n",
 		 dev->version >> 24 & 0xff, dev->version >> 16 & 0xff,
@@ -761,3 +987,4 @@
 MODULE_FIRMWARE(SI2168_A20_FIRMWARE);
 MODULE_FIRMWARE(SI2168_A30_FIRMWARE);
 MODULE_FIRMWARE(SI2168_B40_FIRMWARE);
+MODULE_FIRMWARE(SI2168_D60_FIRMWARE);
diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/si2168.h" "b/drivers/media/dvb-frontends/si2168.h"
--- "a/drivers/media/dvb-frontends/si2168.h"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/dvb-frontends/si2168.h"	2018-01-23 19:12:33.968928000 +0800
@@ -40,11 +40,28 @@
 #define SI2168_TS_SERIAL	0x03
 	u8 ts_mode;
 
+	/* TS clock mode */
+#define SI2168_TS_CLK_AUTO_FIXED	0
+#define SI2168_TS_CLK_AUTO_ADAPT	1
+#define SI2168_TS_CLK_MANUAL		2
+	u8 ts_clock_mode;
+
 	/* TS clock inverted */
 	bool ts_clock_inv;
 
 	/* TS clock gapped */
 	bool ts_clock_gapped;
+
+	/* Tuner control pins */
+#define SI2168_MP_NOT_USED	1
+#define SI2168_MP_A		2
+#define SI2168_MP_B		3
+#define SI2168_MP_C		4
+#define SI2168_MP_D		5
+	int agc_pin;
+	bool agc_inv;
+	int fef_pin;
+	bool fef_inv;
 };
 
 #endif
diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/si2168_priv.h" "b/drivers/media/dvb-frontends/si2168_priv.h"
--- "a/drivers/media/dvb-frontends/si2168_priv.h"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/dvb-frontends/si2168_priv.h"	2018-01-23 19:12:33.968928000 +0800
@@ -21,10 +21,12 @@
 #include "dvb_frontend.h"
 #include <linux/firmware.h>
 #include <linux/i2c-mux.h>
+#include <linux/kernel.h>
 
 #define SI2168_A20_FIRMWARE "dvb-demod-si2168-a20-01.fw"
 #define SI2168_A30_FIRMWARE "dvb-demod-si2168-a30-01.fw"
 #define SI2168_B40_FIRMWARE "dvb-demod-si2168-b40-01.fw"
+#define SI2168_D60_FIRMWARE "dvb-demod-si2168-d60-01.fw"
 #define SI2168_B40_FIRMWARE_FALLBACK "dvb-demod-si2168-02.fw"
 
 /* state struct */
@@ -34,17 +36,24 @@
 	struct dvb_frontend fe;
 	enum fe_delivery_system delivery_system;
 	enum fe_status fe_status;
+	u8 stat_resp;
 	#define SI2168_CHIP_ID_A20 ('A' << 24 | 68 << 16 | '2' << 8 | '0' << 0)
 	#define SI2168_CHIP_ID_A30 ('A' << 24 | 68 << 16 | '3' << 8 | '0' << 0)
 	#define SI2168_CHIP_ID_B40 ('B' << 24 | 68 << 16 | '4' << 8 | '0' << 0)
+	#define SI2168_CHIP_ID_D60 ('D' << 24 | 68 << 16 | '6' << 8 | '0' << 0)
 	unsigned int chip_id;
 	unsigned int version;
 	const char *firmware_name;
 	bool active;
 	bool warm;
 	u8 ts_mode;
+	u8 ts_clock_mode;
 	bool ts_clock_inv;
 	bool ts_clock_gapped;
+	int fef_pin;
+	bool fef_inv;
+	int agc_pin;
+	bool agc_inv;
 };
 
 /* firmware command struct */
diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/si2183.c" "b/drivers/media/dvb-frontends/si2183.c"
--- "a/drivers/media/dvb-frontends/si2183.c"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/dvb-frontends/si2183.c"	2018-01-17 20:00:36.585139000 +0800
@@ -0,0 +1,1599 @@
+/*
+ * Silicon Labs Si2183(2) DVB-T/T2/C/C2/S/S2 demodulator driver
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ */
+
+#include "si2183.h"
+#include "dvb_frontend.h"
+#include <linux/firmware.h>
+#include <linux/i2c-mux.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+#if IS_ENABLED(CONFIG_I2C_MUX)
+#define SI2183_USE_I2C_MUX
+#endif
+#endif
+
+#define SI2183_B60_FIRMWARE "dvb-demod-si2183-b60-01.fw"
+
+#define SI2183_PROP_MODE	0x100a
+#define SI2183_PROP_DVBC_CONST	0x1101
+#define SI2183_PROP_DVBC_SR	0x1102
+#define SI2183_PROP_DVBT_HIER	0x1201
+#define SI2183_PROP_DVBT2_MODE	0x1304
+#define SI2183_PROP_DVBS2_SR	0x1401
+#define SI2183_PROP_DVBS_SR	0x1501
+#define SI2183_PROP_MCNS_CONST	0x1601
+#define SI2183_PROP_MCNS_SR	0x1602
+
+#define SI2183_ARGLEN      30
+struct si2183_cmd {
+	u8 args[SI2183_ARGLEN];
+	unsigned wlen;
+	unsigned rlen;
+};
+
+static const struct dvb_frontend_ops si2183_ops;
+
+LIST_HEAD(silist);
+
+struct si_base {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	struct i2c_mux_core *muxc;
+#endif
+	struct list_head     silist;
+
+	u8                   adr;
+	struct i2c_adapter  *i2c;
+	u32                  count;
+
+	struct i2c_adapter  *tuner_adapter;
+
+#ifndef SI2183_USE_I2C_MUX
+	struct i2c_client *i2c_gate_client;
+#endif
+};
+
+/* state struct */
+struct si2183_dev {
+	struct dvb_frontend fe;
+	enum fe_delivery_system delivery_system;
+	enum fe_status fe_status;
+	u8 stat_resp;
+	bool active;
+	bool fw_loaded;
+	u8 ts_mode;
+	bool ts_clock_inv;
+	bool ts_clock_gapped;
+
+	int fef_pin;
+	bool fef_inv;
+	int agc_pin;
+	bool ter_agc_inv;
+	bool sat_agc_inv;
+
+	struct si_base *base;
+
+	void (*RF_switch)(struct i2c_adapter * i2c,u8 rf_in,u8 flag);
+	u8 rf_in;
+	u8 active_fe;
+};
+
+/* Own I2C adapter locking is needed because of I2C gate logic. */
+static int si2183_i2c_master_send_unlocked(const struct i2c_client *client,
+					   const char *buf, int count)
+{
+	int ret;
+	struct i2c_msg msg = {
+		.addr = client->addr,
+		.flags = 0,
+		.len = count,
+		.buf = (char *)buf,
+	};
+
+	ret = __i2c_transfer(client->adapter, &msg, 1);
+	return (ret == 1) ? count : ret;
+}
+
+static int si2183_i2c_master_recv_unlocked(const struct i2c_client *client,
+					   char *buf, int count)
+{
+	int ret;
+	struct i2c_msg msg = {
+		.addr = client->addr,
+		.flags = I2C_M_RD,
+		.len = count,
+		.buf = buf,
+	};
+
+	ret = __i2c_transfer(client->adapter, &msg, 1);
+	return (ret == 1) ? count : ret;
+}
+
+/* execute firmware command */
+static int si2183_cmd_execute_unlocked(struct i2c_client *client,
+				       struct si2183_cmd *cmd)
+{
+	int ret;
+	unsigned long timeout;
+
+	if (cmd->wlen) {
+		/* write cmd and args for firmware */
+		ret = si2183_i2c_master_send_unlocked(client, cmd->args,
+						      cmd->wlen);
+		if (ret < 0) {
+			goto err;
+		} else if (ret != cmd->wlen) {
+			ret = -EREMOTEIO;
+			goto err;
+		}
+	}
+
+	if (cmd->rlen) {
+		/* wait cmd execution terminate */
+		#define TIMEOUT 500
+		timeout = jiffies + msecs_to_jiffies(TIMEOUT);
+		while (!time_after(jiffies, timeout)) {
+			ret = si2183_i2c_master_recv_unlocked(client, cmd->args,
+							      cmd->rlen);
+			if (ret < 0) {
+				goto err;
+			} else if (ret != cmd->rlen) {
+				ret = -EREMOTEIO;
+				goto err;
+			}
+
+			/* firmware ready? */
+			if ((cmd->args[0] >> 7) & 0x01)
+				break;
+		}
+
+		dev_dbg(&client->dev, "cmd execution took %d ms\n",
+				jiffies_to_msecs(jiffies) -
+				(jiffies_to_msecs(timeout) - TIMEOUT));
+
+		/* CTS ? */
+		if (!((cmd->args[0] >> 7) & 0x01)) {
+			ret = -ETIMEDOUT;
+			goto err;
+		}
+	}
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_cmd_execute(struct i2c_client *client, struct si2183_cmd *cmd)
+{
+	int ret;
+
+	i2c_lock_adapter(client->adapter);
+	ret = si2183_cmd_execute_unlocked(client, cmd);
+	i2c_unlock_adapter(client->adapter);
+
+	return ret;
+}
+
+static int si2183_set_prop(struct i2c_client *client, u16 prop, u16 *val)
+{
+	struct si2183_cmd cmd;
+	int ret;
+
+	cmd.args[0] = 0x14;
+	cmd.args[1] = 0x00;
+	cmd.args[2] = (u8) prop;
+	cmd.args[3] = (u8) (prop >> 8);
+	cmd.args[4] = (u8) (*val);
+	cmd.args[5] = (u8) (*val >> 8);
+	cmd.wlen = 6;
+	cmd.rlen = 4;
+	ret = si2183_cmd_execute(client, &cmd);
+	*val = (cmd.args[2] | (cmd.args[3] << 8));
+	return ret;
+}
+
+static int si2183_get_prop(struct i2c_client *client, u16 prop, u16 *val)
+{
+	struct si2183_cmd cmd;
+	int ret;
+
+	cmd.args[0] = 0x15;
+	cmd.args[1] = 0x00;
+	cmd.args[2] = (u8) prop;
+	cmd.args[3] = (u8) (prop >> 8);
+	cmd.wlen = 4;
+	cmd.rlen = 4;
+	ret = si2183_cmd_execute(client, &cmd);
+	*val = (cmd.args[2] | (cmd.args[3] << 8));
+	return ret;
+}
+
+static int si2183_read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	struct si2183_cmd cmd;
+	u16 agc, snr_mul;
+
+	*status = 0;
+
+	if (!dev->active) {
+		ret = -EAGAIN;
+		goto err;
+	}
+
+	if ((dev->delivery_system != c->delivery_system) || (dev->delivery_system == 0))
+		return 0;
+
+	switch (c->delivery_system) {
+	case SYS_DVBT:
+		memcpy(cmd.args, "\xa0\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 13;
+		snr_mul = 2;
+		break;
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_C:
+		memcpy(cmd.args, "\x90\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 9;
+		snr_mul = 2;
+		break;
+	case SYS_DVBC_ANNEX_B:
+		memcpy(cmd.args, "\x98\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 10;
+		snr_mul = 2;
+		break;
+	case SYS_DVBT2:
+		memcpy(cmd.args, "\x50\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 14;
+		snr_mul = 2;
+		break;
+	case SYS_DVBS:
+		memcpy(cmd.args, "\x60\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 10;
+		snr_mul = 5;
+		break;
+	case SYS_DVBS2:
+		memcpy(cmd.args, "\x70\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 13;
+		snr_mul = 5;
+		break;
+	case SYS_ISDBT:
+		memcpy(cmd.args, "\xa4\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 14;
+		snr_mul = 2;
+		break;
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "read_status fe%d cmd_exec failed=%d\n", fe->id, ret);
+		goto err;
+	}
+
+	dev->stat_resp = cmd.args[2];
+	switch ((dev->stat_resp >> 1) & 0x03) {
+	case 0x01:
+		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;
+		c->cnr.len = 1;
+		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		break;
+	case 0x03:
+		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |
+				FE_HAS_SYNC | FE_HAS_LOCK;
+		c->cnr.len = 2;
+		c->cnr.stat[0].scale = FE_SCALE_DECIBEL;			
+		c->cnr.stat[0].svalue = (s64)cmd.args[3] * 250;
+		c->cnr.stat[1].scale = FE_SCALE_RELATIVE;
+		c->cnr.stat[1].uvalue = (s64)cmd.args[3] * 164 * snr_mul;
+		break;
+	default:
+		c->cnr.len = 1;
+		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		break;
+	}
+	
+	dev->fe_status = *status;
+
+	dev_dbg(&client->dev, "status=%02x args=%*ph\n",
+			*status, cmd.rlen, cmd.args);
+
+	if (fe->ops.tuner_ops.get_rf_strength)
+	{
+		memcpy(cmd.args, "\x8a\x00\x00\x00\x00\x00", 6);
+		cmd.wlen = 6;
+		cmd.rlen = 3;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret) {
+			dev_err(&client->dev, "read_status fe%d cmd_exec failed=%d\n", fe->id, ret);
+			goto err;
+		}
+		dev_dbg(&client->dev, "status=%02x args=%*ph\n",
+			*status, cmd.rlen, cmd.args);
+
+		agc = cmd.args[1];
+		fe->ops.tuner_ops.get_rf_strength(fe, &agc);
+	}
+
+	return 0;
+err:
+	dev_err(&client->dev, "read_status failed=%d\n", ret);
+	return ret;
+}
+
+
+static int si2183_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int i;
+
+	*snr = 0;
+	for (i=0; i < c->cnr.len; i++)
+		if (c->cnr.stat[i].scale == FE_SCALE_RELATIVE)
+		  *snr = (u16)c->cnr.stat[i].uvalue;
+	return 0;
+}
+
+static int si2183_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int i;
+
+	*strength = 0;
+	for (i=0; i < c->strength.len; i++)
+	{
+		if (c->strength.stat[i].scale == FE_SCALE_RELATIVE)
+			*strength = (u16)c->strength.stat[i].uvalue;
+		else if (c->strength.stat[i].scale == FE_SCALE_DECIBEL)
+			*strength = ((100000 + (s32)c->strength.stat[i].svalue)/1000) * 656;
+	}
+	return 0;
+}
+
+static int si2183_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	struct si2183_cmd cmd;
+	int ret;
+	
+	if (dev->fe_status & FE_HAS_LOCK) {
+		memcpy(cmd.args, "\x82\x00", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 3;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret) {
+			dev_err(&client->dev, "read_ber fe%d cmd_exec failed=%d\n", fe->id, ret);
+			goto err;
+		}
+		*ber = (u32)cmd.args[2] * cmd.args[1] & 0xf;
+	} else *ber = 1;
+
+	return 0;
+err:
+	dev_err(&client->dev, "read_ber failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	struct si2183_cmd cmd;
+	int ret;
+	
+	if (dev->stat_resp & 0x10) {
+		memcpy(cmd.args, "\x84\x00", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 3;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret) {
+		dev_err(&client->dev, "read_ucblocks fe%d cmd_exec failed=%d\n", fe->id, ret);
+			goto err;
+		}
+
+		*ucblocks = (u16)cmd.args[2] << 8 | cmd.args[1];
+	} else 	*ucblocks = 0;
+
+	return 0;
+err:
+	dev_err(&client->dev, "read_ucblocks failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_set_dvbc(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_cmd cmd;
+	int ret;
+	u16 prop;
+
+	/* dvb-c mode */
+	prop = 0x38;
+	ret = si2183_set_prop(client, SI2183_PROP_MODE, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-c mode\n");
+		return ret;
+	}
+
+	switch (c->modulation) {
+	default:
+	case QAM_AUTO:
+		prop = 0;
+		break;
+	case QAM_16:
+		prop = 7;
+		break;
+	case QAM_32:
+		prop = 8;
+		break;
+	case QAM_64:
+		prop = 9;
+		break;
+	case QAM_128:
+		prop = 10;
+		break;
+	case QAM_256:
+		prop = 11;
+		break;
+	}
+	ret = si2183_set_prop(client, SI2183_PROP_DVBC_CONST, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-c constelation\n");
+		return ret;
+	}
+
+	/* symbol rate */
+	prop = c->symbol_rate / 1000;
+	ret = si2183_set_prop(client, SI2183_PROP_DVBC_SR, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-c symbol rate\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int si2183_set_mcns(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_cmd cmd;
+	int ret;
+	u16 prop;
+
+	/* mcns mode */
+	prop = 0x16;
+	ret = si2183_set_prop(client, SI2183_PROP_MODE, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set mcns mode\n");
+		return ret;
+	}
+
+	switch (c->modulation) {
+	default:
+	case QAM_AUTO:
+		prop = 0;
+		break;
+	case QAM_16:
+		prop = 7;
+		break;
+	case QAM_32:
+		prop = 8;
+		break;
+	case QAM_64:
+		prop = 9;
+		break;
+	case QAM_128:
+		prop = 10;
+		break;
+	case QAM_256:
+		prop = 11;
+		break;
+	}
+	ret = si2183_set_prop(client, SI2183_PROP_MCNS_CONST, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set mcns constelation\n");
+		return ret;
+	}
+
+	/* symbol rate */
+	prop = c->symbol_rate / 1000;
+	ret = si2183_set_prop(client, SI2183_PROP_MCNS_SR, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set mcns symbol rate\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int gold_code_index (int gold_sequence_index)
+{
+	unsigned int i, k , x_init;
+	u8 GOLD_PRBS[19] = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+	for (k=0; k<gold_sequence_index; k++) {
+		GOLD_PRBS[18] = (GOLD_PRBS[0] + GOLD_PRBS[7])%2;
+		/* Shifting 18 first values */
+		for (i=0; i<18; i++) 
+			GOLD_PRBS[i] = GOLD_PRBS[i+1];
+	}
+	x_init = 0;
+	for (i=0; i<18; i++) { x_init = x_init + GOLD_PRBS[i]*(1<<i); }
+
+	return x_init;
+}
+
+static int si2183_set_dvbs(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_cmd cmd;
+	int ret;
+	u16 prop;
+	u32 pls_mode, pls_code;
+	
+	/* set mode */
+	prop = 0x8;
+	switch (c->delivery_system) {
+	default:
+	case SYS_DVBS:
+		prop |= 0x80;
+		break;
+	case SYS_DVBS2:
+		prop |= 0x90;
+		break;
+	case SYS_DSS:
+		prop |= 0xa0;
+		break;
+	}
+	if (c->inversion)
+		prop |= 0x100;
+	ret = si2183_set_prop(client, SI2183_PROP_MODE, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-s/s2 mode\n");
+		return ret;
+	}
+
+	/* symbol rate */
+	prop = c->symbol_rate / 1000;
+	switch (c->delivery_system) {
+	default:
+	case SYS_DSS:
+	case SYS_DVBS:
+		ret = si2183_set_prop(client, SI2183_PROP_DVBS_SR, &prop);
+		break;
+	case SYS_DVBS2:
+		ret = si2183_set_prop(client, SI2183_PROP_DVBS2_SR, &prop);
+		/* stream_id selection */
+		cmd.args[0] = 0x71;
+		cmd.args[1] = (u8) c->stream_id;
+		cmd.args[2] = c->stream_id == NO_STREAM_ID_FILTER ? 0 : 1;
+		cmd.wlen = 3;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			dev_warn(&client->dev, "dvb-s2: err selecting stream_id\n");
+
+		/* pls selection */
+		pls_mode = c->stream_id == NO_STREAM_ID_FILTER ? 0 : (c->stream_id >> 26) & 3;
+		pls_code = c->stream_id == NO_STREAM_ID_FILTER ? 0 : (c->stream_id >> 8) & 0x3FFFF;
+		if (pls_mode)
+			pls_code = gold_code_index(pls_code);
+		cmd.args[0] = 0x73;
+		cmd.args[1] = pls_code > 0;
+		cmd.args[2] = cmd.args[3] = 0;
+		cmd.args[4] = (u8) pls_code;
+		cmd.args[5] = (u8) (pls_code >> 8);
+		cmd.args[6] = (u8) (pls_code >> 16);
+		cmd.args[7] = (u8) (pls_code >> 24);
+		cmd.wlen = 8;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			dev_warn(&client->dev, "dvb-s2: err set pls\n");
+
+		break;
+	}
+
+	return 0;
+}
+
+
+static int si2183_set_dvbt(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_cmd cmd;
+	int ret;
+	u16 prop;
+
+	if (c->bandwidth_hz == 0) {
+		return -EINVAL;
+	} else if (c->bandwidth_hz <= 2000000)
+		prop = 0x02;
+	else if (c->bandwidth_hz <= 5000000)
+		prop = 0x05;
+	else if (c->bandwidth_hz <= 6000000)
+		prop = 0x06;
+	else if (c->bandwidth_hz <= 7000000)
+		prop = 0x07;
+	else if (c->bandwidth_hz <= 8000000)
+		prop = 0x08;
+	else if (c->bandwidth_hz <= 9000000)
+		prop = 0x09;
+	else if (c->bandwidth_hz <= 10000000)
+		prop = 0x0a;
+	else
+		prop = 0x0f;
+
+	switch (c->delivery_system) {
+	default:
+	case SYS_DVBT:
+		prop |= 0x20;
+		break;
+	case SYS_DVBT2:
+		prop |= 0x70;
+		break;
+	}
+	ret = si2183_set_prop(client, SI2183_PROP_MODE, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-t mode\n");
+		return ret;
+	}
+
+	/* hierarchy - HP = 0 / LP = 1 */
+	prop = c->hierarchy == HIERARCHY_1 ? 1 : 0;
+	ret = si2183_set_prop(client, SI2183_PROP_DVBT_HIER, &prop);
+	if (ret)
+		dev_warn(&client->dev, "dvb-t: err set hierarchy\n");
+
+	if (c->delivery_system == SYS_DVBT2) {
+		/* stream_id selection */
+		cmd.args[0] = 0x52;
+		cmd.args[1] = (u8) c->stream_id;
+		cmd.args[2] = c->stream_id == NO_STREAM_ID_FILTER ? 0 : 1;
+		cmd.wlen = 3;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			dev_warn(&client->dev, "dvb-t2: err selecting stream_id\n");
+
+		/* dvb-t2 mode - any=0 / base=1 / lite=2 */
+		prop = 0;
+		ret = si2183_set_prop(client, SI2183_PROP_DVBT2_MODE, &prop);
+		if (ret)
+			dev_warn(&client->dev, "dvb-t2: err set mode\n");
+	}
+
+	return 0;
+}
+
+static int si2183_set_isdbt(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct i2c_client *client = fe->demodulator_priv;
+	int ret;
+	u16 prop;
+
+	if (c->bandwidth_hz == 0) {
+		return -EINVAL;
+	} else if (c->bandwidth_hz <= 2000000)
+		prop = 0x02;
+	else if (c->bandwidth_hz <= 5000000)
+		prop = 0x05;
+	else if (c->bandwidth_hz <= 6000000)
+		prop = 0x06;
+	else if (c->bandwidth_hz <= 7000000)
+		prop = 0x07;
+	else if (c->bandwidth_hz <= 8000000)
+		prop = 0x08;
+	else if (c->bandwidth_hz <= 9000000)
+		prop = 0x09;
+	else if (c->bandwidth_hz <= 10000000)
+		prop = 0x0a;
+	else
+		prop = 0x0f;
+
+	/* ISDB-T mode */
+	prop |= 0x40;
+	ret = si2183_set_prop(client, SI2183_PROP_MODE, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-t mode\n");
+		return ret;
+	}
+	return 0;
+}
+
+static int si2183_set_frontend(struct dvb_frontend *fe)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	struct si2183_cmd cmd;
+
+	dev_dbg(&client->dev,
+			"delivery_system=%u modulation=%u frequency=%u bandwidth_hz=%u symbol_rate=%u inversion=%u stream_id=%u\n",
+			c->delivery_system, c->modulation, c->frequency,
+			c->bandwidth_hz, c->symbol_rate, c->inversion,
+			c->stream_id);
+
+	if (!dev->active) {
+		ret = -EAGAIN;
+		goto err;
+	}
+
+	/* Force DVB-C Annex B if SR < 6000 Ks */
+	if (c->delivery_system == SYS_DVBC_ANNEX_A && c->symbol_rate < 6000000) {
+		c->delivery_system = SYS_DVBC_ANNEX_B;
+		c->bandwidth_hz = 6000000;
+	}
+
+	if(dev->RF_switch)
+	{	
+		switch (c->delivery_system) {
+		case SYS_DVBT:
+		case SYS_DVBT2:
+		case SYS_DVBC_ANNEX_A:
+		case SYS_DVBC_ANNEX_B:
+		case SYS_ISDBT:
+			dev->RF_switch(dev->base->i2c,dev->rf_in,1);
+			break;
+			
+		case SYS_DVBS:
+		case SYS_DVBS2:
+		case SYS_DSS:
+		default:
+			dev->RF_switch(dev->base->i2c,dev->rf_in,0);
+			break;
+		
+		}
+	}
+
+	if (fe->ops.tuner_ops.set_params) {
+#ifndef SI2183_USE_I2C_MUX
+		if (fe->ops.i2c_gate_ctrl)
+			fe->ops.i2c_gate_ctrl(fe, 1);
+#endif
+		ret = fe->ops.tuner_ops.set_params(fe);
+#ifndef SI2183_USE_I2C_MUX
+		if (fe->ops.i2c_gate_ctrl)
+			fe->ops.i2c_gate_ctrl(fe, 0);
+#endif
+		if (ret) {
+			dev_err(&client->dev, "err setting tuner params\n");
+			goto err;
+		}
+	}
+
+	switch (c->delivery_system) {
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		ret = si2183_set_dvbt(fe);
+		break;
+	case SYS_DVBC_ANNEX_A:
+	  ret = si2183_set_dvbc(fe);
+		break;
+	case SYS_DVBC_ANNEX_B:
+		ret = si2183_set_mcns(fe);
+		break;
+	case SYS_ISDBT:
+		ret = si2183_set_isdbt(fe);
+		break;
+	case SYS_DVBS:
+	case SYS_DVBS2:
+	case SYS_DSS:
+		ret = si2183_set_dvbs(fe);
+		break;
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* dsp restart */
+	memcpy(cmd.args, "\x85", 1);
+	cmd.wlen = 1;
+	cmd.rlen = 1;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err restarting dsp\n");
+		return ret;
+	}
+
+	dev->delivery_system = c->delivery_system;
+	return 0;
+err:
+	dev_err(&client->dev, "set_params failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_init(struct dvb_frontend *fe)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	int ret = 0, len, remaining;
+	const struct firmware *fw;
+	const char *fw_name;
+	struct si2183_cmd cmd;
+	unsigned int chip_id;
+	u16 prop;
+
+	dev_dbg(&client->dev, "\n");
+
+	if (dev->active_fe) {
+		dev->active_fe |= (1 << fe->id);
+		return 0;
+	}
+
+	/* initialize */
+	memcpy(cmd.args, "\xc0\x12\x00\x0c\x00\x0d\x16\x00\x00\x00\x00\x00\x00", 13);
+	cmd.wlen = 13;
+	cmd.rlen = 0;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	if (dev->fw_loaded) {
+		/* resume */
+		memcpy(cmd.args, "\xc0\x06\x08\x0f\x00\x20\x21\x01", 8);
+		cmd.wlen = 8;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+
+		memcpy(cmd.args, "\x85", 1);
+		cmd.wlen = 1;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+
+		goto warm;
+	}
+
+	/* power up */
+	memcpy(cmd.args, "\xc0\x06\x01\x0f\x00\x20\x20\x01", 8);
+	cmd.wlen = 8;
+	cmd.rlen = 1;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	/* query chip revision */
+	memcpy(cmd.args, "\x02", 1);
+	cmd.wlen = 1;
+	cmd.rlen = 13;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	chip_id = cmd.args[1] << 24 | cmd.args[2] << 16 | cmd.args[3] << 8 |
+			cmd.args[4] << 0;
+
+	#define SI2183_B60 ('B' << 24 | 83 << 16 | '6' << 8 | '0' << 0)
+
+	switch (chip_id) {
+	case SI2183_B60:
+		fw_name = SI2183_B60_FIRMWARE;
+		break;
+	default:
+		dev_err(&client->dev, "unknown chip version Si21%d-%c%c%c\n",
+				cmd.args[2], cmd.args[1],
+				cmd.args[3], cmd.args[4]);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	dev_info(&client->dev, "found a 'Silicon Labs Si21%d-%c%c%c'\n",
+			cmd.args[2], cmd.args[1], cmd.args[3], cmd.args[4]);
+
+	ret = request_firmware(&fw, fw_name, &client->dev);
+	if (ret) {
+		dev_err(&client->dev,
+				"firmware file '%s' not found\n",
+				fw_name);
+		goto err;
+	}
+
+	dev_info(&client->dev, "downloading firmware from file '%s'\n",
+			fw_name);
+
+	for (remaining = fw->size; remaining > 0; remaining -= 17) {
+		len = fw->data[fw->size - remaining];
+		if (len > SI2183_ARGLEN) {
+			ret = -EINVAL;
+			break;
+		}
+		memcpy(cmd.args, &fw->data[(fw->size - remaining) + 1], len);
+		cmd.wlen = len;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			break;
+	}
+	release_firmware(fw);
+
+	if (ret) {
+		dev_err(&client->dev, "firmware download failed %d\n", ret);
+		goto err;
+	}
+
+	memcpy(cmd.args, "\x01\x01", 2);
+	cmd.wlen = 2;
+	cmd.rlen = 1;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	/* query firmware version */
+	memcpy(cmd.args, "\x11", 1);
+	cmd.wlen = 1;
+	cmd.rlen = 10;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	dev_info(&client->dev, "firmware version: %c.%c.%d\n",
+			cmd.args[6], cmd.args[7], cmd.args[8]);
+
+	/* TER FEF */
+	memcpy(cmd.args, "\x51\x00", 2);
+	cmd.wlen = 2;
+	cmd.rlen = 12;
+	cmd.args[1] = (dev->fef_inv & 1) << 3 | (dev->fef_pin & 7);
+	dev_dbg(&client->dev, "args=%*ph\n", cmd.wlen, cmd.args);
+	
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err set fef pip\n");
+	}
+
+	/* MP DEFAULTS */
+	memcpy(cmd.args, "\x88\x00\x00\x00\x00", 5);
+	cmd.wlen = 5;
+	cmd.rlen = 2;
+	switch (dev->fef_pin)
+	{
+	case SI2183_MP_A:
+		cmd.args[1] = dev->fef_inv ? 3 : 2;
+		break;
+	case SI2183_MP_B:
+		cmd.args[2] = dev->fef_inv ? 3 : 2;
+		break;
+	case SI2183_MP_C:
+		cmd.args[3] = dev->fef_inv ? 3 : 2;
+		break;
+	case SI2183_MP_D:
+		cmd.args[4] = dev->fef_inv ? 3 : 2;
+		break;
+	}
+	switch (dev->agc_pin)
+	{
+	case SI2183_MP_A:
+		cmd.args[1] = 1;
+		break;
+	case SI2183_MP_B:
+		cmd.args[2] = 1;
+		break;
+	case SI2183_MP_C:
+		cmd.args[3] = 1;
+		break;
+	case SI2183_MP_D:
+		cmd.args[4] = 1;
+		break;
+	}
+	dev_dbg(&client->dev, "args=%*ph\n", cmd.wlen, cmd.args);
+	
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err set mp defaults\n");
+	}
+
+	/* TER AGC */
+	memcpy(cmd.args, "\x89\x01\x06\x12\x00\x00", 6);
+	cmd.wlen = 6;
+	cmd.rlen = 3;
+	cmd.args[1] |= (dev->ter_agc_inv & 1) << 7 | (dev->agc_pin & 7) << 4;
+	dev_dbg(&client->dev, "args=%*ph\n", cmd.wlen, cmd.args);
+	
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err set ter agc\n");
+	}
+
+	/* SAT AGC */
+	memcpy(cmd.args, "\x8a\x10\x12\x00\x00\x00", 6);
+	cmd.wlen = 6;
+	cmd.rlen = 3;
+	cmd.args[1] |= (dev->sat_agc_inv & 1) << 3 | (dev->agc_pin & 7);
+	dev_dbg(&client->dev, "args=%*ph\n", cmd.wlen, cmd.args);
+
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err set sat agc\n");
+	}
+
+	/* set ts mode */
+	prop = 0x10 | dev->ts_mode | (dev->ts_clock_gapped ? 0x40 : 0);
+	ret = si2183_set_prop(client, 0x1001, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set ts mode\n");
+	}
+
+	/* FER resol */
+	prop = 0x12;
+	ret = si2183_set_prop(client, 0x100c, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set FER resol\n");
+		return ret;
+	}
+
+	/* DD IEN */
+	prop = 0x00;
+	ret = si2183_set_prop(client, 0x1006, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dd ien\n");
+		return ret;
+	}
+
+	/* int sense */
+	prop = 0x2000;
+	ret = si2183_set_prop(client, 0x1007, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set int sense\n");
+		return ret;
+	}
+
+	/* Control of SQI computation */
+	prop = 0x1e;
+	ret = si2183_set_prop(client, 0x100f, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set sqi comp\n");
+		return ret;
+	}
+
+	/* Transport Stream setting for parallel mode */
+	prop = 0x0104 | (dev->ts_clock_inv ? 0x0000 : 0x1000);
+	ret = si2183_set_prop(client, 0x1009, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set par_ts\n");
+		return ret;
+	}
+
+	/* Transport Stream setting for serial mode */
+	prop = 0x230C | (dev->ts_clock_inv ? 0x0000 : 0x1000);
+	ret = si2183_set_prop(client, 0x1008, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set ser_ts\n");
+		return ret;
+	}
+
+	/* Transport Stream setting for parallel mode - secondary*/
+	prop = 0x08e3;
+	ret = si2183_set_prop(client, 0x1015, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set int par_ts_sec\n");
+		return ret;
+	}
+
+	/* Transport Stream setting for serial mode - secondary*/
+	prop = 0x01c7;
+	ret = si2183_set_prop(client, 0x1016, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set int ser_ts_sec\n");
+		return ret;
+	}
+
+	dev->fw_loaded = true;
+warm:
+	dev->active = true;
+	dev->active_fe |= (1 << fe->id);
+	return 0;
+
+err:
+	dev_dbg(&client->dev, "init failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_sleep(struct dvb_frontend *fe)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	int ret;
+	struct si2183_cmd cmd;
+
+	dev_dbg(&client->dev, "\n");
+
+	dev->active_fe &= ~(1 << fe->id);
+	if (dev->active_fe)
+		return 0;
+
+	dev->active = false;
+
+	memcpy(cmd.args, "\x13", 1);
+	cmd.wlen = 1;
+	cmd.rlen = 0;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_get_tune_settings(struct dvb_frontend *fe,
+	struct dvb_frontend_tune_settings *s)
+{
+	s->min_delay_ms = 900;
+
+	return 0;
+}
+
+#ifdef SI2183_USE_I2C_MUX
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+static int si2183_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	struct i2c_client *client = i2c_mux_priv(muxc);
+#else
+static int si2183_select(struct i2c_adapter *adap, void *mux_priv, u32 chan)
+{
+	struct i2c_client *client = mux_priv;
+#endif
+	int ret;
+	struct si2183_cmd cmd;
+
+	/* open I2C gate */
+	memcpy(cmd.args, "\xc0\x0d\x01", 3);
+	cmd.wlen = 3;
+	cmd.rlen = 0;
+	ret = si2183_cmd_execute_unlocked(client, &cmd);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+static int si2183_deselect(struct i2c_mux_core *muxc, u32 chan)
+{
+	struct i2c_client *client = i2c_mux_priv(muxc);
+#else
+static int si2183_deselect(struct i2c_adapter *adap, void *mux_priv, u32 chan)
+{
+	struct i2c_client *client = mux_priv;
+#endif
+	int ret;
+	struct si2183_cmd cmd;
+
+	/* close I2C gate */
+	memcpy(cmd.args, "\xc0\x0d\x00", 3);
+	cmd.wlen = 3;
+	cmd.rlen = 0;
+	ret = si2183_cmd_execute_unlocked(client, &cmd);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+#else
+static int si2183_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	struct si2183_cmd cmd;
+
+	memcpy(cmd.args, "\xc0\x0d\x00", 3);
+	if (enable)
+		cmd.args[2] = 1;
+	cmd.wlen = 3;
+	cmd.rlen = 0;
+	return si2183_cmd_execute(dev->base->i2c_gate_client, &cmd);
+}
+#endif
+
+static int si2183_tune(struct dvb_frontend *fe, bool re_tune,
+	unsigned int mode_flags, unsigned int *delay, enum fe_status *status)
+{
+	*delay = HZ / 5;
+	if (re_tune) {
+		int ret = si2183_set_frontend(fe);
+		if (ret)
+			return ret;
+	}
+	return si2183_read_status(fe, status);
+}
+
+static int si2183_get_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+
+static int si2183_set_property(struct dvb_frontend *fe,
+		struct dtv_property *p)
+{
+	int ret = 0;
+
+	switch (p->cmd) {
+	case DTV_DELIVERY_SYSTEM:
+		switch (p->u.data) {
+		case SYS_DVBS:
+		case SYS_DVBS2:
+		case SYS_DSS:
+			fe->ops.info.frequency_min = 950000;
+			fe->ops.info.frequency_max = 2150000;
+			fe->ops.info.frequency_stepsize = 0;
+			break;
+		case SYS_DVBC_ANNEX_A:
+		case SYS_DVBC_ANNEX_B:
+			fe->ops.info.frequency_min = 47000000;
+			fe->ops.info.frequency_max = 862000000;
+			fe->ops.info.frequency_stepsize = 62500;
+			break;
+		case SYS_ISDBT:
+			fe->ops.info.frequency_min = 42000000;
+			fe->ops.info.frequency_max = 1002000000;
+			fe->ops.info.frequency_stepsize = 0;
+			break;
+		case SYS_DVBT:
+		case SYS_DVBT2:
+		default:
+			fe->ops.info.frequency_min = 174000000;
+			fe->ops.info.frequency_max = 862000000;
+			fe->ops.info.frequency_stepsize = 250000;
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int si2183_send_diseqc_cmd(struct dvb_frontend *fe,
+	u8 cont_tone, u8 tone_burst, u8 burst_sel,
+	u8 end_seq, u8 msg_len, u8 *msg)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_cmd cmd;
+	u8 enable = 1;
+
+	cmd.args[0] = 0x8c;
+	cmd.args[1] = enable | (cont_tone << 1)
+		    | (tone_burst << 2) | (burst_sel << 3)
+		    | (end_seq << 4) | (msg_len << 5);
+
+	if (msg_len > 0)
+		memcpy(&cmd.args[2], msg, msg_len);
+
+	cmd.wlen = 8;
+	cmd.rlen = 1;
+	return si2183_cmd_execute(client, &cmd);
+}
+
+static int si2183_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	int ret;
+	u8 cont_tone;
+
+	switch (tone) {
+	case SEC_TONE_ON:
+		cont_tone = 1;
+		break;
+	case SEC_TONE_OFF:
+		cont_tone = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = si2183_send_diseqc_cmd(fe, cont_tone, 0, 0, 1, 0, NULL);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_err(&client->dev, "set_tone failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_diseqc_send_burst(struct dvb_frontend *fe,
+	enum fe_sec_mini_cmd burst)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	int ret;
+	u8 burst_sel;
+
+	switch (burst) {
+	case SEC_MINI_A:
+		burst_sel = 0;
+		break;
+	case SEC_MINI_B:
+		burst_sel = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = si2183_send_diseqc_cmd(fe, 0, 1, burst_sel, 1, 0, NULL);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_err(&client->dev, "set_tone failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_send_diseqc_msg(struct dvb_frontend *fe,
+	struct dvb_diseqc_master_cmd *d)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	int ret;
+	u8 remaining = d->msg_len;
+	u8 *p = d->msg;
+	u8 len = 0;
+
+	while (remaining > 0) {
+		p += len;
+		len = (remaining > 6) ? 6 : remaining;
+		remaining -= len;
+		ret = si2183_send_diseqc_cmd(fe, 0, 0, 0,
+			(remaining == 0) ? 1 : 0, len, p);
+		if (ret)
+			goto err;
+		msleep(50);
+	}
+
+	return 0;
+err:
+	dev_err(&client->dev, "set_tone failed=%d\n", ret);
+	return ret;
+}
+
+static const struct dvb_frontend_ops si2183_ops = {
+	.delsys = {SYS_DVBT, SYS_DVBT2, SYS_ISDBT,	  
+			SYS_DVBC_ANNEX_A, SYS_DVBC_ANNEX_B, 
+			SYS_DVBS, SYS_DVBS2, SYS_DSS},
+	.info = {
+		.name = "Silicon Labs Si2183",
+		.symbol_rate_min = 1000000,
+		.symbol_rate_max = 45000000,
+		.caps =	FE_CAN_FEC_1_2 |
+			FE_CAN_FEC_2_3 |
+			FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 |
+			FE_CAN_FEC_7_8 |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK |
+			FE_CAN_QAM_16 |
+			FE_CAN_QAM_32 |
+			FE_CAN_QAM_64 |
+			FE_CAN_QAM_128 |
+			FE_CAN_QAM_256 |
+			FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_MUTE_TS |
+			FE_CAN_2G_MODULATION |
+			FE_CAN_MULTISTREAM
+	},
+
+	.get_tune_settings = si2183_get_tune_settings,
+
+	.init = si2183_init,
+	.sleep = si2183_sleep,
+
+	.set_frontend = si2183_set_frontend,
+	.tune = si2183_tune,
+	.get_frontend_algo = si2183_get_algo,
+
+	.read_status = si2183_read_status,
+	.read_signal_strength	= si2183_read_signal_strength,
+	.read_snr		= si2183_read_snr,
+	.read_ber		= si2183_read_ber,
+	.read_ucblocks		= si2183_read_ucblocks,
+
+	/*.set_property			= si2183_set_property,*/
+	.set_tone			= si2183_set_tone,
+	.diseqc_send_master_cmd 	= si2183_send_diseqc_msg,
+	.diseqc_send_burst		= si2183_diseqc_send_burst,
+#ifndef SI2183_USE_I2C_MUX
+	.i2c_gate_ctrl			= si2183_i2c_gate_ctrl,
+#endif
+};
+
+
+static struct si_base *match_base(struct i2c_adapter *i2c, u8 adr)
+{
+	struct si_base *p;
+
+	list_for_each_entry(p, &silist, silist)
+		if (p->i2c == i2c)// && p->adr == adr) lja: TO FIX
+			return p;
+	return NULL;
+}
+
+
+
+static int si2183_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct si2183_config *config = client->dev.platform_data;
+	struct si2183_dev *dev;
+	struct si_base *base;
+	int ret;
+
+	dev_dbg(&client->dev, "\n");
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		ret = -ENOMEM;
+		dev_err(&client->dev, "kzalloc() failed\n");
+		goto err;
+	}
+
+	base = match_base(client->adapter, client->addr);
+	if (base) {
+		base->count++;
+		dev->base = base;
+	} else {
+		base = kzalloc(sizeof(struct si_base), GFP_KERNEL);
+		if (!base)
+			goto err_kfree;
+		base->i2c = client->adapter;
+		base->adr = client->addr;
+		base->count = 1;
+		dev->base = base;
+		list_add(&base->silist, &silist);
+
+#ifdef SI2183_USE_I2C_MUX
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		/* create mux i2c adapter for tuner */
+		base->muxc = i2c_mux_alloc(client->adapter, &client->adapter->dev,
+					  1, 0, I2C_MUX_LOCKED,
+					  si2183_select, si2183_deselect);
+		if (!base->muxc) {
+			ret = -ENOMEM;
+			goto err_base_kfree;
+		}
+		base->muxc->priv = client;
+		ret = i2c_mux_add_adapter(base->muxc, 0, 0, 0);
+		if (ret)
+			goto err_base_kfree;
+		base->tuner_adapter = base->muxc->adapter[0];
+#else
+		/* create mux i2c adapter for tuners */
+		base->tuner_adapter = i2c_add_mux_adapter(client->adapter, &client->adapter->dev,
+				client, 0, 0, 0, si2183_select, si2183_deselect);
+		if (base->tuner_adapter == NULL) {
+			ret = -ENODEV;
+			goto err_base_kfree;
+		}
+#endif
+#else
+		base->tuner_adapter = client->adapter;
+		base->i2c_gate_client = client;
+#endif
+	}
+
+	/* create dvb_frontend */
+	memcpy(&dev->fe.ops, &si2183_ops, sizeof(struct dvb_frontend_ops));
+	dev->fe.demodulator_priv = client;
+	*config->i2c_adapter = base->tuner_adapter;
+	*config->fe = &dev->fe;
+	dev->ts_mode = config->ts_mode;
+	dev->ts_clock_inv = config->ts_clock_inv;
+	dev->ts_clock_gapped = config->ts_clock_gapped;
+	dev->fef_pin = config->fef_pin;
+	dev->fef_inv = config->fef_inv;
+	dev->agc_pin = config->agc_pin;
+	dev->ter_agc_inv = config->ter_agc_inv;
+	dev->sat_agc_inv = config->sat_agc_inv;
+	dev->RF_switch = config->RF_switch;
+	dev->rf_in  = config->rf_in;
+	dev->fw_loaded = false;
+	dev->stat_resp = 0;
+
+	dev->active_fe = 0;
+
+	i2c_set_clientdata(client, dev);
+
+#ifndef SI2183_USE_I2C_MUX
+	/* leave gate open for tuner to init */
+	si2183_i2c_gate_ctrl(&dev->fe, 1);
+#endif
+	dev_info(&client->dev, "Silicon Labs Si2183 successfully attached\n");
+	return 0;
+err_base_kfree:
+	kfree(base);
+err_kfree:
+	kfree(dev);
+err:
+	dev_dbg(&client->dev, "probe failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_remove(struct i2c_client *client)
+{
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+
+	dev_dbg(&client->dev, "\n");
+
+	dev->base->count--;
+	if (dev->base->count == 0) {
+
+#ifdef SI2183_USE_I2C_MUX
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		i2c_mux_del_adapters(dev->base->muxc);
+#else
+		i2c_del_mux_adapter(dev->base->tuner_adapter);
+#endif
+#endif
+		list_del(&dev->base->silist);
+		kfree(dev->base);
+	}
+
+	dev->fe.ops.release = NULL;
+	dev->fe.demodulator_priv = NULL;
+
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id si2183_id_table[] = {
+	{"si2183", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, si2183_id_table);
+
+static struct i2c_driver si2183_driver = {
+	.driver = {
+		.name	= "si2183",
+	},
+	.probe		= si2183_probe,
+	.remove		= si2183_remove,
+	.id_table	= si2183_id_table,
+};
+
+module_i2c_driver(si2183_driver);
+
+MODULE_AUTHOR("Luis Alves <ljalvs@gmail.com>");
+MODULE_DESCRIPTION("Silicon Labs Si2183 DVB-T/T2/C/C2/S/S2 demodulator driver");
+MODULE_LICENSE("GPL");
diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/si2183.h" "b/drivers/media/dvb-frontends/si2183.h"
--- "a/drivers/media/dvb-frontends/si2183.h"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/dvb-frontends/si2183.h"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,65 @@
+/*
+ * Silicon Labs Si2183(2) DVB-T/T2/C/C2/S/S2 demodulator driver
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ */
+
+#ifndef SI2183_H
+#define SI2183_H
+
+#include <linux/dvb/frontend.h>
+/*
+ * I2C address
+ * 0x64
+ */
+struct si2183_config {
+	/*
+	 * frontend
+	 * returned by driver
+	 */
+	struct dvb_frontend **fe;
+
+	/*
+	 * tuner I2C adapter
+	 * returned by driver
+	 */
+	struct i2c_adapter **i2c_adapter;
+
+	/* TS mode */
+#define SI2183_TS_PARALLEL	0x06
+#define SI2183_TS_SERIAL	0x03
+	u8 ts_mode;
+
+	/* TS clock inverted */
+	bool ts_clock_inv;
+
+	/* TS clock gapped */
+	bool ts_clock_gapped;
+
+	/* Tuner control pins */
+#define SI2183_MP_NOT_USED	1
+#define SI2183_MP_A		2
+#define SI2183_MP_B		3
+#define SI2183_MP_C		4
+#define SI2183_MP_D		5
+	int fef_pin;
+	bool fef_inv;
+	int agc_pin;
+	bool ter_agc_inv;
+	bool sat_agc_inv;
+
+	/*rf switch*/
+	void (*RF_switch)(struct i2c_adapter * i2c,u8 rf_in,u8 flag);
+	/*rf no.*/
+	u8 rf_in;
+};
+
+#endif
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/Kconfig" "b/drivers/media/tuners/Kconfig"
--- "a/drivers/media/tuners/Kconfig"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/tuners/Kconfig"	2018-01-17 18:35:26.648178000 +0800
@@ -256,6 +256,13 @@
 	help
 	  ITE Tech IT913x silicon tuner driver.
 
+config MEDIA_TUNER_AV201X
+	tristate "Airoha Technology AV201x silicon tuner"
+	depends on MEDIA_SUPPORT && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Airoha Technology AV201x silicon tuner driver.
+
 config MEDIA_TUNER_R820T
 	tristate "Rafael Micro R820T silicon tuner"
 	depends on MEDIA_SUPPORT && I2C
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/Makefile" "b/drivers/media/tuners/Makefile"
--- "a/drivers/media/tuners/Makefile"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/tuners/Makefile"	2018-01-17 18:36:19.701333000 +0800
@@ -40,6 +40,7 @@
 obj-$(CONFIG_MEDIA_TUNER_R820T) += r820t.o
 obj-$(CONFIG_MEDIA_TUNER_MXL301RF) += mxl301rf.o
 obj-$(CONFIG_MEDIA_TUNER_QM1D1C0042) += qm1d1c0042.o
+obj-$(CONFIG_MEDIA_TUNER_AV201X) += av201x.o
 obj-$(CONFIG_MEDIA_TUNER_M88RS6000T) += m88rs6000t.o
 
 ccflags-y += -I$(srctree)/drivers/media/dvb-core
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/av201x.c" "b/drivers/media/tuners/av201x.c"
--- "a/drivers/media/tuners/av201x.c"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/tuners/av201x.c"	2018-01-10 20:21:52.803346000 +0800
@@ -0,0 +1,272 @@
+/*
+ * AV201x Airoha Technology silicon tuner driver
+ *
+ * Copyright (C) 2014 Luis Alves <ljalvs@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "av201x.h"
+#include "av201x_priv.h"
+
+/* write multiple (continuous) registers */
+static int av201x_wrm(struct av201x_priv *priv, u8 *buf, int len)
+{
+	int ret;
+	struct i2c_msg msg = {
+		.addr = priv->cfg->i2c_address,
+		.flags = 0, .buf = buf, .len = len };
+
+	dev_dbg(&priv->i2c->dev, "%s() i2c wrm @0x%02x (len=%d) ",
+		__func__, buf[0], len);
+
+	ret = i2c_transfer(priv->i2c, &msg, 1);
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c wrm err(%i) @0x%02x (len=%d)\n",
+			KBUILD_MODNAME, ret, buf[0], len);
+		return ret;
+	}
+	return 0;
+}
+
+/* write one register */
+static int av201x_wr(struct av201x_priv *priv, u8 addr, u8 data)
+{
+	u8 buf[] = { addr, data };
+	return av201x_wrm(priv, buf, 2);
+}
+
+/* read multiple (continuous) registers starting at addr */
+static int av201x_rdm(struct av201x_priv *priv, u8 addr, u8 *buf, int len)
+{
+	int ret;
+	struct i2c_msg msg[] = {
+		{ .addr = priv->cfg->i2c_address, .flags = 0,
+			.buf = &addr, .len = 1 },
+		{ .addr = priv->cfg->i2c_address, .flags = I2C_M_RD,
+			.buf = buf, .len = len }
+	};
+
+	dev_dbg(&priv->i2c->dev, "%s() i2c rdm @0x%02x (len=%d)\n",
+		__func__, addr, len);
+
+	ret = i2c_transfer(priv->i2c, msg, 2);
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c rdm err(%i) @0x%02x (len=%d)\n",
+			KBUILD_MODNAME, ret, addr, len);
+		return ret;
+	}
+	return 0;
+}
+
+/* read one register */
+static int av201x_rd(struct av201x_priv *priv, u8 addr, u8 *data)
+{
+	return av201x_rdm(priv, addr, data, 1);
+}
+
+/* read register, apply masks, write back */
+static int av201x_regmask(struct av201x_priv *priv,
+	u8 reg, u8 setmask, u8 clrmask)
+{
+	int ret;
+	u8 b = 0;
+	if (clrmask != 0xff) {
+		ret = av201x_rd(priv, reg, &b);
+		if (ret)
+			return ret;
+		b &= ~clrmask;
+	}
+	return av201x_wr(priv, reg, b | setmask);
+}
+
+static int av201x_wrtable(struct av201x_priv *priv,
+	struct av201x_regtable *regtable, int len)
+{
+	int ret, i;
+
+	for (i = 0; i < len; i++) {
+		ret = av201x_regmask(priv, regtable[i].addr,
+			regtable[i].setmask, regtable[i].clrmask);
+		if (ret)
+			return ret;
+		if (regtable[i].sleep)
+			msleep(regtable[i].sleep);
+	}
+	return 0;
+}
+
+static int av201x_release(struct dvb_frontend *fe)
+{
+	struct av201x_priv *priv = fe->tuner_priv;
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static int av201x_init(struct dvb_frontend *fe)
+{
+	struct av201x_priv *priv = fe->tuner_priv;
+	int ret;
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+
+	ret = av201x_wrtable(priv, av201x_inittuner0,
+		ARRAY_SIZE(av201x_inittuner0));
+
+	switch (priv->cfg->id) {
+	case ID_AV2011:
+		ret |= av201x_wrtable(priv, av201x_inittuner1a,
+			ARRAY_SIZE(av201x_inittuner1a));
+		break;
+	case ID_AV2012:
+	default:
+		ret |= av201x_wrtable(priv, av201x_inittuner1b,
+			ARRAY_SIZE(av201x_inittuner1b));
+		break;
+	}
+
+	ret |= av201x_wrtable(priv, av201x_inittuner2,
+		ARRAY_SIZE(av201x_inittuner2));
+
+	ret |= av201x_wr(priv, REG_TUNER_CTRL, 0x96);
+
+	msleep(120);
+
+	if (ret)
+		dev_dbg(&priv->i2c->dev, "%s() failed\n", __func__);
+	return ret;
+}
+
+static int av201x_sleep(struct dvb_frontend *fe)
+{
+	struct av201x_priv *priv = fe->tuner_priv;
+	int ret;
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+
+	ret = av201x_regmask(priv, REG_TUNER_CTRL, AV201X_SLEEP, 0);
+	if (ret)
+		dev_dbg(&priv->i2c->dev, "%s() failed\n", __func__);
+	return ret;
+}
+
+static int av201x_set_params(struct dvb_frontend *fe)
+{
+	struct av201x_priv *priv = fe->tuner_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u32 n, bw, bf;
+	u8 buf[5];
+	int ret;
+
+	dev_dbg(&priv->i2c->dev, "%s() delivery_system=%d frequency=%d " \
+			"symbol_rate=%d\n", __func__,
+			c->delivery_system, c->frequency, c->symbol_rate);
+
+	/*
+	   ** PLL setup **
+	   RF = (pll_N * ref_freq) / pll_M
+	   pll_M = fixed 0x10000
+	   PLL output is divided by 2
+	   REG_FN = pll_M<24:0>
+	*/
+	buf[0] = REG_FN;
+	n = DIV_ROUND_CLOSEST(c->frequency, priv->cfg->xtal_freq);
+	buf[1] = (n > 0xff) ? 0xff : (u8) n;
+	n = DIV_ROUND_CLOSEST((c->frequency / 1000) << 17, priv->cfg->xtal_freq / 1000);
+	buf[2] = (u8) (n >> 9);
+	buf[3] = (u8) (n >> 1);
+	buf[4] = (u8) (((n << 7) & 0x80) | 0x50);
+	ret = av201x_wrm(priv, buf, 5);
+	if (ret)
+		goto exit;
+
+	msleep(20);
+
+	/* set bandwidth */
+	bw = (c->symbol_rate / 1000) * 135/200;
+	if (c->symbol_rate < 6500000)
+		bw += 6000;
+	bw += 2000;
+	bw *= 108/100;
+
+	/* check limits (4MHz < bw < 40MHz) */
+	if (bw > 40000)
+		bw = 40000;
+	else if (bw < 4000)
+		bw = 4000;
+
+	/* bandwidth step = 211kHz */
+	bf = DIV_ROUND_CLOSEST(bw * 127, 21100);
+	ret = av201x_wr(priv, REG_BWFILTER, (u8) bf);
+
+	/* enable fine tune agc */
+	ret |= av201x_wr(priv, REG_FT_CTRL, AV201X_FT_EN | AV201X_FT_BLK);
+
+	ret |= av201x_wr(priv, REG_TUNER_CTRL, 0x96);
+	msleep(20);
+exit:
+	if (ret)
+		dev_dbg(&priv->i2c->dev, "%s() failed\n", __func__);
+	return ret;
+}
+
+static const struct dvb_tuner_ops av201x_tuner_ops = {
+	.info = {
+		.name           = "Airoha Technology AV201x",
+
+		.frequency_min  = 850000,
+		.frequency_max  = 2300000,
+		.frequency_step = 206,
+	},
+
+	.release = av201x_release,
+
+	.init = av201x_init,
+	.sleep = av201x_sleep,
+	.set_params = av201x_set_params,
+};
+
+struct dvb_frontend *av201x_attach(struct dvb_frontend *fe,
+		struct av201x_config *cfg, struct i2c_adapter *i2c)
+{
+	struct av201x_priv *priv = NULL;
+
+	priv = kzalloc(sizeof(struct av201x_priv), GFP_KERNEL);
+	if (priv == NULL) {
+		dev_dbg(&i2c->dev, "%s() attach failed\n", __func__);
+		return NULL;
+	}
+
+	priv->cfg = cfg;
+	priv->i2c = i2c;
+
+	dev_info(&priv->i2c->dev,
+		"%s: Airoha Technology AV201x successfully attached\n",
+		KBUILD_MODNAME);
+
+	memcpy(&fe->ops.tuner_ops, &av201x_tuner_ops,
+			sizeof(struct dvb_tuner_ops));
+
+	fe->tuner_priv = priv;
+	return fe;
+}
+EXPORT_SYMBOL(av201x_attach);
+
+MODULE_DESCRIPTION("Airoha Technology AV201x silicon tuner driver");
+MODULE_AUTHOR("Luis Alves <ljalvs@gmail.com>");
+MODULE_LICENSE("GPL");
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/av201x.h" "b/drivers/media/tuners/av201x.h"
--- "a/drivers/media/tuners/av201x.h"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/tuners/av201x.h"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,55 @@
+/*
+ * AV201x Airoha Technology silicon tuner driver
+ *
+ * Copyright (C) 2014 Luis Alves <ljalvs@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef AV201X_H
+#define AV201X_H
+
+#include <linux/kconfig.h>
+#include "dvb_frontend.h"
+
+typedef enum av201x_id {
+	ID_AV2011,
+	ID_AV2012,
+	ID_AV2018,
+} av201x_id_t;
+
+struct av201x_config {
+	/* tuner i2c address */
+	u8 i2c_address;
+	/* tuner type */
+	av201x_id_t id;
+
+	/* crystal freq in kHz */
+	u32 xtal_freq;
+};
+
+#if IS_ENABLED(CONFIG_MEDIA_TUNER_AV201X)
+extern struct dvb_frontend *av201x_attach(struct dvb_frontend *fe,
+		struct av201x_config *cfg, struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *av201x_attach(struct dvb_frontend *fe,
+		struct av201x_config *cfg, struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* AV201X_H */
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/av201x_priv.h" "b/drivers/media/tuners/av201x_priv.h"
--- "a/drivers/media/tuners/av201x_priv.h"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/tuners/av201x_priv.h"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,110 @@
+/*
+ * AV201x Airoha Technology silicon tuner driver
+ *
+ * Copyright (C) 2014 Luis Alves <ljalvs@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef AV201X_PRIV_H
+#define AV201X_PRIV_H
+
+struct av201x_priv {
+	struct av201x_config *cfg;
+	struct i2c_adapter *i2c;
+};
+
+enum av201x_regs_addr {
+	REG_FN		= 0x00,
+	REG_BWFILTER	= 0x05,
+	REG_TUNER_STAT	= 0x0b,
+	REG_TUNER_CTRL	= 0x0c,
+	REG_FT_CTRL	= 0x25,
+};
+
+/* REG_TUNER_STAT */
+#define AV201X_PLLLOCK		(1<<0)
+
+/* REG_TUNER_CTRL */
+#define AV201X_SLEEP		(1<<5)
+#define AV201X_RFLP		(1<<6)
+
+/* REG_FT_CTRL */
+#define AV201X_FT_EN		(1<<1)
+#define AV201X_FT_BLK		(1<<2)
+
+struct av201x_regtable {
+	u8 addr;
+	u8 setmask;
+	u8 clrmask;
+	int sleep;
+};
+
+static struct av201x_regtable av201x_inittuner0[] = {
+	{0x00, 0x38, 0xff, 0},
+	{0x01, 0x00, 0xff, 0},
+	{0x02, 0x00, 0xff, 0},
+	{0x03, 0x50, 0xff, 0},
+	{0x04, 0x1f, 0xff, 0},
+	{0x05, 0xa3, 0xff, 0},
+	{0x06, 0xfd, 0xff, 0},
+	{0x07, 0x58, 0xff, 0},
+	{0x08, 0x36, 0xff, 0},
+	{0x09, 0xc2, 0xff, 0},
+	{0x0a, 0x88, 0xff, 0},
+	{0x0b, 0xb4, 0xff, 20},
+	{0x0d, 0x40, 0xff, 0},
+};
+
+static struct av201x_regtable av201x_inittuner1a[] = {
+	{0x0e, 0x94, 0xff, 0},
+	{0x0f, 0x9a, 0xff, 0},
+};
+
+static struct av201x_regtable av201x_inittuner1b[] = {
+	{0x0e, 0x5b, 0xff, 0},
+	{0x0f, 0x6a, 0xff, 0},
+};
+
+static struct av201x_regtable av201x_inittuner2[] = {
+	{0x10, 0x66, 0xff, 0},
+	{0x11, 0x40, 0xff, 0},
+	{0x12, 0x80, 0xff, 0},
+	{0x13, 0x2b, 0xff, 0},
+	{0x14, 0x6a, 0xff, 0},
+	{0x15, 0x50, 0xff, 0},
+	{0x16, 0x91, 0xff, 0},
+	{0x17, 0x27, 0xff, 0},
+	{0x18, 0x8f, 0xff, 0},
+	{0x19, 0xcc, 0xff, 0},
+	{0x1a, 0x21, 0xff, 0},
+	{0x1b, 0x10, 0xff, 0},
+	{0x1c, 0x80, 0xff, 0},
+	{0x1d, 0x02, 0xff, 0},
+	{0x1e, 0xf5, 0xff, 0},
+	{0x1f, 0x7f, 0xff, 0},
+	{0x20, 0x4a, 0xff, 0},
+	{0x21, 0x9b, 0xff, 0},
+	{0x22, 0xe0, 0xff, 0},
+	{0x23, 0xe0, 0xff, 0},
+	{0x24, 0x36, 0xff, 0},
+	{0x25, 0x00, 0xff, 0},
+	{0x26, 0xab, 0xff, 0},
+	{0x27, 0x97, 0xff, 0},
+	{0x28, 0xc5, 0xff, 0},
+	{0x29, 0xa8, 0xff, 20},
+};
+
+#endif /* AV201X_PRIV_H */
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/si2157.c" "b/drivers/media/tuners/si2157.c"
--- "a/drivers/media/tuners/si2157.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/tuners/si2157.c"	2018-01-28 19:52:48.709049000 +0800
@@ -40,7 +40,7 @@
 
 	if (cmd->rlen) {
 		/* wait cmd execution terminate */
-		#define TIMEOUT 80
+		#define TIMEOUT 500
 		timeout = jiffies + msecs_to_jiffies(TIMEOUT);
 		while (!time_after(jiffies, timeout)) {
 			ret = i2c_master_recv(client, cmd->args, cmd->rlen);
@@ -86,6 +86,7 @@
 	const char *fw_name;
 	unsigned int uitmp, chip_id;
 
+
 	dev_dbg(&client->dev, "\n");
 
 	/* Returned IF frequency is garbage when firmware is not running */
@@ -106,6 +107,9 @@
 	if (dev->chiptype == SI2157_CHIPTYPE_SI2146) {
 		memcpy(cmd.args, "\xc0\x05\x01\x00\x00\x0b\x00\x00\x01", 9);
 		cmd.wlen = 9;
+	} else if (dev->chiptype == SI2157_CHIPTYPE_SI2141) {
+		memcpy(cmd.args, "\xc0\x00\x0d\x0e\x00\x01\x01\x01\x01\x03", 10);
+		cmd.wlen = 10;
 	} else {
 		memcpy(cmd.args, "\xc0\x00\x0c\x00\x00\x01\x01\x01\x01\x01\x01\x02\x00\x00\x01", 15);
 		cmd.wlen = 15;
@@ -115,6 +119,24 @@
 	if (ret)
 		goto err;
 
+	/* Si2141 needs a second command before it answers the revision query */
+	if (dev->chiptype == SI2157_CHIPTYPE_SI2141) {
+		memcpy(cmd.args, "\xc0\x08\x01\x02\x00\x00\x01", 7);
+		cmd.wlen = 7;
+		ret = si2157_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+	}
+
+	/* Si2141 needs a second command before it answers the revision query */
+	if (dev->chiptype == SI2157_CHIPTYPE_SI2141) {
+		memcpy(cmd.args, "\xc0\x08\x01\x02\x00\x00\x01", 7);
+		cmd.wlen = 7;
+		ret = si2157_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+	}
+
 	/* query chip revision */
 	memcpy(cmd.args, "\x02", 1);
 	cmd.wlen = 1;
@@ -131,12 +153,16 @@
 	#define SI2157_A30 ('A' << 24 | 57 << 16 | '3' << 8 | '0' << 0)
 	#define SI2147_A30 ('A' << 24 | 47 << 16 | '3' << 8 | '0' << 0)
 	#define SI2146_A10 ('A' << 24 | 46 << 16 | '1' << 8 | '0' << 0)
+	#define SI2141_A10 ('A' << 24 | 41 << 16 | '1' << 8 | '0' << 0)
 
 	switch (chip_id) {
 	case SI2158_A20:
 	case SI2148_A20:
 		fw_name = SI2158_A20_FIRMWARE;
 		break;
+	case SI2141_A10:
+		fw_name = SI2141_A10_FIRMWARE;
+		break;
 	case SI2157_A30:
 	case SI2147_A30:
 	case SI2146_A10:
@@ -288,20 +314,20 @@
 
 	switch (c->delivery_system) {
 	case SYS_ATSC:
-			delivery_system = 0x00;
-			if_frequency = 3250000;
-			break;
-	case SYS_DVBC_ANNEX_B:
-			delivery_system = 0x10;
-			if_frequency = 4000000;
-			break;
+		delivery_system = 0x00;
+		if_frequency = 3250000;
+		break;
 	case SYS_DVBT:
 	case SYS_DVBT2: /* it seems DVB-T and DVB-T2 both are 0x20 here */
-			delivery_system = 0x20;
-			break;
+		delivery_system = 0x20;
+		break;
 	case SYS_DVBC_ANNEX_A:
-			delivery_system = 0x30;
-			break;
+	case SYS_DVBC_ANNEX_B:
+		delivery_system = 0x30;
+		break;
+	case SYS_ISDBT:
+		delivery_system = 0x40;
+		break;
 	default:
 			ret = -EINVAL;
 			goto err;
@@ -317,6 +343,7 @@
 	if (ret)
 		goto err;
 
+	/* set IF port */
 	if (dev->chiptype == SI2157_CHIPTYPE_SI2146)
 		memcpy(cmd.args, "\x14\x00\x02\x07\x00\x01", 6);
 	else
@@ -328,6 +355,15 @@
 	if (ret)
 		goto err;
 
+	/* set LIF out amp */
+	memcpy(cmd.args, "\x14\x00\x07\x07\x94\x20", 6);
+	cmd.args[5] = delivery_system == 0x30 ? 0x2B : 0x20;
+	cmd.wlen = 6;
+	cmd.rlen = 4;
+	ret = si2157_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
 	/* set if frequency if needed */
 	if (if_frequency != dev->if_frequency) {
 		memcpy(cmd.args, "\x14\x00\x06\x07", 4);
@@ -371,7 +407,7 @@
 
 static const struct dvb_tuner_ops si2157_ops = {
 	.info = {
-		.name           = "Silicon Labs Si2146/2147/2148/2157/2158",
+		.name           = "Silicon Labs Si2141/Si2146/2147/2148/2157/2158",
 		.frequency_min  = 42000000,
 		.frequency_max  = 870000000,
 	},
@@ -400,12 +436,17 @@
 	if (ret)
 		goto err;
 
+	c->strength.len = 2;
 	c->strength.stat[0].scale = FE_SCALE_DECIBEL;
-	c->strength.stat[0].svalue = (s8) cmd.args[3] * 1000;
+	c->strength.stat[0].svalue = (s8)cmd.args[3] * 1000;
+
+	c->strength.stat[1].scale = FE_SCALE_RELATIVE;
+	c->strength.stat[1].uvalue = (100 + (s8)cmd.args[3]) * 656;
 
 	schedule_delayed_work(&dev->stat_work, msecs_to_jiffies(2000));
 	return;
 err:
+	c->strength.len = 1;
 	c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	dev_dbg(&client->dev, "failed=%d\n", ret);
 }
@@ -471,6 +512,7 @@
 #endif
 
 	dev_info(&client->dev, "Silicon Labs %s successfully attached\n",
+			dev->chiptype == SI2157_CHIPTYPE_SI2141 ?  "Si2141" :
 			dev->chiptype == SI2157_CHIPTYPE_SI2146 ?
 			"Si2146" : "Si2147/2148/2157/2158");
 
@@ -508,6 +550,7 @@
 static const struct i2c_device_id si2157_id_table[] = {
 	{"si2157", SI2157_CHIPTYPE_SI2157},
 	{"si2146", SI2157_CHIPTYPE_SI2146},
+	{"si2141", SI2157_CHIPTYPE_SI2141},
 	{}
 };
 MODULE_DEVICE_TABLE(i2c, si2157_id_table);
@@ -524,7 +567,8 @@
 
 module_i2c_driver(si2157_driver);
 
-MODULE_DESCRIPTION("Silicon Labs Si2146/2147/2148/2157/2158 silicon tuner driver");
+MODULE_DESCRIPTION("Silicon Labs Si2141/Si2146/2147/2148/2157/2158 silicon tuner driver");
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
 MODULE_LICENSE("GPL");
 MODULE_FIRMWARE(SI2158_A20_FIRMWARE);
+MODULE_FIRMWARE(SI2141_A10_FIRMWARE);
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/si2157_priv.h" "b/drivers/media/tuners/si2157_priv.h"
--- "a/drivers/media/tuners/si2157_priv.h"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/tuners/si2157_priv.h"	2017-12-07 05:52:26.000000000 +0800
@@ -40,9 +40,6 @@
 
 };
 
-#define SI2157_CHIPTYPE_SI2157 0
-#define SI2157_CHIPTYPE_SI2146 1
-
 /* firmware command struct */
 #define SI2157_ARGLEN      30
 struct si2157_cmd {
@@ -51,6 +48,11 @@
 	unsigned rlen;
 };
 
+#define SI2157_CHIPTYPE_SI2157 0
+#define SI2157_CHIPTYPE_SI2146 1
+#define SI2157_CHIPTYPE_SI2141 2
+
 #define SI2158_A20_FIRMWARE "dvb-tuner-si2158-a20-01.fw"
+#define SI2141_A10_FIRMWARE "dvb-tuner-si2141-a10-01.fw"
 
 #endif
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/tda18273.c" "b/drivers/media/tuners/tda18273.c"
--- "a/drivers/media/tuners/tda18273.c"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/tuners/tda18273.c"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,2153 @@
+/*
+	tda18273.c - driver for the NXP TDA18273 silicon tuner
+	Copyright (C) 2014 CrazyCat <crazycat69@narod.ru>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "dvb_frontend.h"
+
+#include "tda18273_priv.h"
+
+static unsigned int verbose;
+module_param(verbose, int, 0644);
+MODULE_PARM_DESC(verbose, "Set Verbosity level");
+
+#define FE_ERROR				0
+#define FE_NOTICE				1
+#define FE_INFO					2
+#define FE_DEBUG				3
+#define FE_DEBUGREG				4
+
+#define dprintk(__y, __z, format, arg...) do {						\
+	if (__z) {									\
+		if	((verbose > FE_ERROR) && (verbose > __y))			\
+			printk(KERN_ERR "%s: " format "\n", __func__ , ##arg);		\
+		else if	((verbose > FE_NOTICE) && (verbose > __y))			\
+			printk(KERN_NOTICE "%s: " format "\n", __func__ , ##arg);	\
+		else if ((verbose > FE_INFO) && (verbose > __y))			\
+			printk(KERN_INFO "%s: " format "\n", __func__ , ##arg);		\
+		else if ((verbose > FE_DEBUG) && (verbose > __y))			\
+			printk(KERN_DEBUG "%s: " format "\n", __func__ , ##arg);	\
+	} else {									\
+		if (verbose > __y)							\
+			printk(format, ##arg);						\
+	}										\
+} while (0)
+
+#define TDA18273_REG_ADD_SZ                             (0x01)
+#define TDA18273_REG_DATA_MAX_SZ                        (0x01)
+#define TDA18273_REG_MAP_NB_BYTES                       (0x6D)
+
+#define TDA18273_REG_DATA_LEN(_FIRST_REG, _LAST_REG)    ( (_LAST_REG.Address - _FIRST_REG.Address) + 1)
+
+struct tda18273_state {
+	struct dvb_frontend	*fe;
+	struct i2c_adapter	*i2c;
+	u8	i2c_addr;
+	
+	unsigned int if_freq;
+	unsigned int freq_hz;
+	unsigned int bandwidth;
+	unsigned char freq_band;
+	unsigned char agc_mode;
+	unsigned char pll_step;
+	unsigned char pll_step_val;
+	unsigned char pll_charge_pump;
+
+	unsigned int power_state;
+	unsigned char regmap[TDA18273_REG_MAP_NB_BYTES];
+	
+	pTDA18273Object_t	pObj;
+};
+
+TDA18273Object_t gTDA18273Instance = 
+{
+	0,
+	0,
+	0,
+	TDA18273_StandardMode_Unknown,
+	NULL,
+   	TDA18273_INSTANCE_CUSTOM_STD_DEF
+};
+
+
+/* TDA18273 Register ID_byte_1 0x00 */
+const TDA18273_BitField_t gTDA18273_Reg_ID_byte_1 = { 0x00, 0x00, 0x08, 0x00 };
+/* MS bit(s): Indicate if Device is a Master or a Slave */
+/*  1 => Master device */
+/*  0 => Slave device */
+const TDA18273_BitField_t gTDA18273_Reg_ID_byte_1__MS = { 0x00, 0x07, 0x01, 0x00 };
+/* Ident_1 bit(s): MSB of device identifier */
+const TDA18273_BitField_t gTDA18273_Reg_ID_byte_1__Ident_1 = { 0x00, 0x00, 0x07, 0x00 };
+
+
+/* TDA18273 Register ID_byte_2 0x01 */
+const TDA18273_BitField_t gTDA18273_Reg_ID_byte_2 = { 0x01, 0x00, 0x08, 0x00 };
+/* Ident_2 bit(s): LSB of device identifier */
+const TDA18273_BitField_t gTDA18273_Reg_ID_byte_2__Ident_2 = { 0x01, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register ID_byte_3 0x02 */
+const TDA18273_BitField_t gTDA18273_Reg_ID_byte_3 = { 0x02, 0x00, 0x08, 0x00 };
+/* Major_rev bit(s): Major revision of device */
+const TDA18273_BitField_t gTDA18273_Reg_ID_byte_3__Major_rev = { 0x02, 0x04, 0x04, 0x00 };
+/* Major_rev bit(s): Minor revision of device */
+const TDA18273_BitField_t gTDA18273_Reg_ID_byte_3__Minor_rev = { 0x02, 0x00, 0x04, 0x00 };
+
+
+/* TDA18273 Register Thermo_byte_1 0x03 */
+const TDA18273_BitField_t gTDA18273_Reg_Thermo_byte_1 = { 0x03, 0x00, 0x08, 0x00 };
+/* TM_D bit(s): Device temperature */
+const TDA18273_BitField_t gTDA18273_Reg_Thermo_byte_1__TM_D = { 0x03, 0x00, 0x07, 0x00 };
+
+
+/* TDA18273 Register Thermo_byte_2 0x04 */
+const TDA18273_BitField_t gTDA18273_Reg_Thermo_byte_2 = { 0x04, 0x00, 0x08, 0x00 };
+/* TM_ON bit(s): Set device temperature measurement to ON or OFF */
+/*  1 => Temperature measurement ON */
+/*  0 => Temperature measurement OFF */
+const TDA18273_BitField_t gTDA18273_Reg_Thermo_byte_2__TM_ON = { 0x04, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register Power_state_byte_1 0x05 */
+const TDA18273_BitField_t gTDA18273_Reg_Power_state_byte_1 = { 0x05, 0x00, 0x08, 0x00 };
+/* POR bit(s): Indicates that device just powered ON */
+/*  1 => POR: No access done to device */
+/*  0 => At least one access has been done to device */
+const TDA18273_BitField_t gTDA18273_Reg_Power_state_byte_1__POR = { 0x05, 0x07, 0x01, 0x00 };
+/* AGCs_Lock bit(s): Indicates that AGCs are locked */
+/*  1 => AGCs locked */
+/*  0 => AGCs not locked */
+const TDA18273_BitField_t gTDA18273_Reg_Power_state_byte_1__AGCs_Lock = { 0x05, 0x02, 0x01, 0x00 };
+/* Vsync_Lock bit(s): Indicates that VSync is locked */
+/*  1 => VSync locked */
+/*  0 => VSync not locked */
+const TDA18273_BitField_t gTDA18273_Reg_Power_state_byte_1__Vsync_Lock = { 0x05, 0x01, 0x01, 0x00 };
+/* LO_Lock bit(s): Indicates that LO is locked */
+/*  1 => LO locked */
+/*  0 => LO not locked */
+const TDA18273_BitField_t gTDA18273_Reg_Power_state_byte_1__LO_Lock = { 0x05, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register Power_state_byte_2 0x06 */
+const TDA18273_BitField_t gTDA18273_Reg_Power_state_byte_2 = { 0x06, 0x00, 0x08, 0x00 };
+/* SM bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Power_state_byte_2__SM = { 0x06, 0x01, 0x01, 0x00 };
+/* SM_XT bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Power_state_byte_2__SM_XT = { 0x06, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register Input_Power_Level_byte 0x07 */
+const TDA18273_BitField_t gTDA18273_Reg_Input_Power_Level_byte = { 0x07, 0x00, 0x08, 0x00 };
+/* Power_Level bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Input_Power_Level_byte__Power_Level = { 0x07, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register IRQ_status 0x08 */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_status = { 0x08, 0x00, 0x08, 0x00 };
+/* IRQ_status bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_status__IRQ_status = { 0x08, 0x07, 0x01, 0x00 };
+/* MSM_XtalCal_End bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_status__MSM_XtalCal_End = { 0x08, 0x05, 0x01, 0x00 };
+/* MSM_RSSI_End bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_status__MSM_RSSI_End = { 0x08, 0x04, 0x01, 0x00 };
+/* MSM_LOCalc_End bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_status__MSM_LOCalc_End = { 0x08, 0x03, 0x01, 0x00 };
+/* MSM_RFCal_End bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_status__MSM_RFCal_End = { 0x08, 0x02, 0x01, 0x00 };
+/* MSM_IRCAL_End bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_status__MSM_IRCAL_End = { 0x08, 0x01, 0x01, 0x00 };
+/* MSM_RCCal_End bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_status__MSM_RCCal_End = { 0x08, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register IRQ_enable 0x09 */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_enable = { 0x09, 0x00, 0x08, 0x00 };
+/* IRQ_Enable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_enable__IRQ_Enable = { 0x09, 0x07, 0x01, 0x00 };
+/* MSM_XtalCal_Enable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_enable__MSM_XtalCal_Enable = { 0x09, 0x05, 0x01, 0x00 };
+/* MSM_RSSI_Enable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_enable__MSM_RSSI_Enable = { 0x09, 0x04, 0x01, 0x00 };
+/* MSM_LOCalc_Enable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_enable__MSM_LOCalc_Enable = { 0x09, 0x03, 0x01, 0x00 };
+/* MSM_RFCal_Enable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_enable__MSM_RFCal_Enable = { 0x09, 0x02, 0x01, 0x00 };
+/* MSM_IRCAL_Enable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_enable__MSM_IRCAL_Enable = { 0x09, 0x01, 0x01, 0x00 };
+/* MSM_RCCal_Enable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_enable__MSM_RCCal_Enable = { 0x09, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register IRQ_clear 0x0A */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_clear = { 0x0A, 0x00, 0x08, 0x00 };
+/* IRQ_Clear bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_clear__IRQ_Clear = { 0x0A, 0x07, 0x01, 0x00 };
+/* MSM_XtalCal_Clear bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_clear__MSM_XtalCal_Clear = { 0x0A, 0x05, 0x01, 0x00 };
+/* MSM_RSSI_Clear bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_clear__MSM_RSSI_Clear = { 0x0A, 0x04, 0x01, 0x00 };
+/* MSM_LOCalc_Clear bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_clear__MSM_LOCalc_Clear = { 0x0A, 0x03, 0x01, 0x00 };
+/* MSM_RFCal_Clear bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_clear__MSM_RFCal_Clear = { 0x0A, 0x02, 0x01, 0x00 };
+/* MSM_IRCAL_Clear bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_clear__MSM_IRCAL_Clear = { 0x0A, 0x01, 0x01, 0x00 };
+/* MSM_RCCal_Clear bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_clear__MSM_RCCal_Clear = { 0x0A, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register IRQ_set 0x0B */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_set = { 0x0B, 0x00, 0x08, 0x00 };
+/* IRQ_Set bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_set__IRQ_Set = { 0x0B, 0x07, 0x01, 0x00 };
+/* MSM_XtalCal_Set bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_set__MSM_XtalCal_Set = { 0x0B, 0x05, 0x01, 0x00 };
+/* MSM_RSSI_Set bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_set__MSM_RSSI_Set = { 0x0B, 0x04, 0x01, 0x00 };
+/* MSM_LOCalc_Set bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_set__MSM_LOCalc_Set = { 0x0B, 0x03, 0x01, 0x00 };
+/* MSM_RFCal_Set bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_set__MSM_RFCal_Set = { 0x0B, 0x02, 0x01, 0x00 };
+/* MSM_IRCAL_Set bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_set__MSM_IRCAL_Set = { 0x0B, 0x01, 0x01, 0x00 };
+/* MSM_RCCal_Set bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IRQ_set__MSM_RCCal_Set = { 0x0B, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register AGC1_byte_1 0x0C */
+const TDA18273_BitField_t gTDA18273_Reg_AGC1_byte_1 = { 0x0C, 0x00, 0x08, 0x00 };
+/* AGC1_TOP bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC1_byte_1__AGC1_TOP = { 0x0C, 0x00, 0x04, 0x00 };
+
+
+/* TDA18273 Register AGC1_byte_2 0x0D */
+const TDA18273_BitField_t gTDA18273_Reg_AGC1_byte_2 = { 0x0D, 0x00, 0x08, 0x00 };
+/* AGC1_Top_Mode_Val bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC1_byte_2__AGC1_Top_Mode_Val = { 0x0D, 0x03, 0x02, 0x00 };
+/* AGC1_Top_Mode bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC1_byte_2__AGC1_Top_Mode = { 0x0D, 0x00, 0x03, 0x00 };
+
+
+/* TDA18273 Register AGC2_byte_1 0x0E */
+const TDA18273_BitField_t gTDA18273_Reg_AGC2_byte_1 = { 0x0E, 0x00, 0x08, 0x00 };
+/* AGC2_TOP bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC2_byte_1__AGC2_TOP = { 0x0E, 0x00, 0x03, 0x00 };
+
+
+/* TDA18273 Register AGCK_byte_1 0x0F */
+const TDA18273_BitField_t gTDA18273_Reg_AGCK_byte_1 = { 0x0F, 0x00, 0x08, 0x00 };
+/* AGCs_Up_Step_assym bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCK_byte_1__AGCs_Up_Step_assym = { 0x0F, 0x06, 0x02, 0x00 };
+/* Pulse_Shaper_Disable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCK_byte_1__Pulse_Shaper_Disable = { 0x0F, 0x04, 0x01, 0x00 };
+/* AGCK_Step bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCK_byte_1__AGCK_Step = { 0x0F, 0x02, 0x02, 0x00 };
+/* AGCK_Mode bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCK_byte_1__AGCK_Mode = { 0x0F, 0x00, 0x02, 0x00 };
+
+
+/* TDA18273 Register RF_AGC_byte 0x10 */
+const TDA18273_BitField_t gTDA18273_Reg_RF_AGC_byte = { 0x10, 0x00, 0x08, 0x00 };
+/* PD_AGC_Adapt3x bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_AGC_byte__PD_AGC_Adapt3x = { 0x10, 0x06, 0x02, 0x00 };
+/* RFAGC_Adapt_TOP bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_AGC_byte__RFAGC_Adapt_TOP = { 0x10, 0x04, 0x02, 0x00 };
+/* RFAGC_Low_BW bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_AGC_byte__RFAGC_Low_BW = { 0x10, 0x03, 0x01, 0x00 };
+/* RFAGC_Top bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_AGC_byte__RFAGC_Top = { 0x10, 0x00, 0x03, 0x00 };
+
+
+/* TDA18273 Register W_Filter_byte 0x11 */
+const TDA18273_BitField_t gTDA18273_Reg_W_Filter_byte = { 0x11, 0x00, 0x08, 0x00 };
+/* VHF_III_mode bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_W_Filter_byte__VHF_III_mode = { 0x11, 0x07, 0x01, 0x00 };
+/* RF_Atten_3dB bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_W_Filter_byte__RF_Atten_3dB = { 0x11, 0x06, 0x01, 0x00 };
+/* W_Filter_Enable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_W_Filter_byte__W_Filter_Enable = { 0x11, 0x05, 0x01, 0x00 };
+/* W_Filter_Bypass bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_W_Filter_byte__W_Filter_Bypass = { 0x11, 0x04, 0x01, 0x00 };
+/* W_Filter bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_W_Filter_byte__W_Filter = { 0x11, 0x02, 0x02, 0x00 };
+/* W_Filter_Offset bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_W_Filter_byte__W_Filter_Offset = { 0x11, 0x00, 0x02, 0x00 };
+
+
+/* TDA18273 Register IR_Mixer_byte_1 0x12 */
+const TDA18273_BitField_t gTDA18273_Reg_IR_Mixer_byte_1 = { 0x12, 0x00, 0x08, 0x00 };
+/* S2D_Gain bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IR_Mixer_byte_1__S2D_Gain = { 0x12, 0x04, 0x02, 0x00 };
+/* IR_Mixer_Top bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IR_Mixer_byte_1__IR_Mixer_Top = { 0x12, 0x00, 0x04, 0x00 };
+
+
+/* TDA18273 Register AGC5_byte_1 0x13 */
+const TDA18273_BitField_t gTDA18273_Reg_AGC5_byte_1 = { 0x13, 0x00, 0x08, 0x00 };
+/* AGCs_Do_Step_assym bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC5_byte_1__AGCs_Do_Step_assym = { 0x13, 0x05, 0x02, 0x00 };
+/* AGC5_Ana bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC5_byte_1__AGC5_Ana = { 0x13, 0x04, 0x01, 0x00 };
+/* AGC5_TOP bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC5_byte_1__AGC5_TOP = { 0x13, 0x00, 0x04, 0x00 };
+
+
+/* TDA18273 Register IF_AGC_byte 0x14 */
+const TDA18273_BitField_t gTDA18273_Reg_IF_AGC_byte = { 0x14, 0x00, 0x08, 0x00 };
+/* IFnotchToRSSI bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IF_AGC_byte__IFnotchToRSSI = { 0x14, 0x07, 0x01, 0x00 };
+/* LPF_DCOffset_Corr bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IF_AGC_byte__LPF_DCOffset_Corr = { 0x14, 0x06, 0x01, 0x00 };
+/* IF_level bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IF_AGC_byte__IF_level = { 0x14, 0x00, 0x03, 0x00 };
+
+
+/* TDA18273 Register IF_Byte_1 0x15 */
+const TDA18273_BitField_t gTDA18273_Reg_IF_Byte_1 = { 0x15, 0x00, 0x08, 0x00 };
+/* IF_HP_Fc bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IF_Byte_1__IF_HP_Fc = { 0x15, 0x06, 0x02, 0x00 };
+/* IF_ATSC_Notch bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IF_Byte_1__IF_ATSC_Notch = { 0x15, 0x05, 0x01, 0x00 };
+/* LP_FC_Offset bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IF_Byte_1__LP_FC_Offset = { 0x15, 0x03, 0x02, 0x00 };
+/* LP_Fc bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IF_Byte_1__LP_Fc = { 0x15, 0x00, 0x03, 0x00 };
+
+
+/* TDA18273 Register Reference_Byte 0x16 */
+const TDA18273_BitField_t gTDA18273_Reg_Reference_Byte = { 0x16, 0x00, 0x08, 0x00 };
+/* Digital_Clock_Mode bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Reference_Byte__Digital_Clock_Mode = { 0x16, 0x06, 0x02, 0x00 };
+/* XTout bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Reference_Byte__XTout = { 0x16, 0x00, 0x02, 0x00 };
+
+
+/* TDA18273 Register IF_Frequency_byte 0x17 */
+const TDA18273_BitField_t gTDA18273_Reg_IF_Frequency_byte = { 0x17, 0x00, 0x08, 0x00 };
+/* IF_Freq bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IF_Frequency_byte__IF_Freq = { 0x17, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register RF_Frequency_byte_1 0x18 */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Frequency_byte_1 = { 0x18, 0x00, 0x08, 0x00 };
+/* RF_Freq_1 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Frequency_byte_1__RF_Freq_1 = { 0x18, 0x00, 0x04, 0x00 };
+
+
+/* TDA18273 Register RF_Frequency_byte_2 0x19 */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Frequency_byte_2 = { 0x19, 0x00, 0x08, 0x00 };
+/* RF_Freq_2 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Frequency_byte_2__RF_Freq_2 = { 0x19, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register RF_Frequency_byte_3 0x1A */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Frequency_byte_3 = { 0x1A, 0x00, 0x08, 0x00 };
+/* RF_Freq_3 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Frequency_byte_3__RF_Freq_3 = { 0x1A, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register MSM_byte_1 0x1B */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_1 = { 0x1B, 0x00, 0x08, 0x00 };
+/* RSSI_Meas bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_1__RSSI_Meas = { 0x1B, 0x07, 0x01, 0x00 };
+/* RF_CAL_AV bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_1__RF_CAL_AV = { 0x1B, 0x06, 0x01, 0x00 };
+/* RF_CAL bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_1__RF_CAL = { 0x1B, 0x05, 0x01, 0x00 };
+/* IR_CAL_Loop bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_1__IR_CAL_Loop = { 0x1B, 0x04, 0x01, 0x00 };
+/* IR_Cal_Image bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_1__IR_Cal_Image = { 0x1B, 0x03, 0x01, 0x00 };
+/* IR_CAL_Wanted bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_1__IR_CAL_Wanted = { 0x1B, 0x02, 0x01, 0x00 };
+/* RC_Cal bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_1__RC_Cal = { 0x1B, 0x01, 0x01, 0x00 };
+/* Calc_PLL bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_1__Calc_PLL = { 0x1B, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register MSM_byte_2 0x1C */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_2 = { 0x1C, 0x00, 0x08, 0x00 };
+/* XtalCal_Launch bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_2__XtalCal_Launch = { 0x1C, 0x01, 0x01, 0x00 };
+/* MSM_Launch bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_MSM_byte_2__MSM_Launch = { 0x1C, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register PowerSavingMode 0x1D */
+const TDA18273_BitField_t gTDA18273_Reg_PowerSavingMode = { 0x1D, 0x00, 0x08, 0x00 };
+/* PSM_AGC1 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_PowerSavingMode__PSM_AGC1 = { 0x1D, 0x07, 0x01, 0x00 };
+/* PSM_Bandsplit_Filter bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_PowerSavingMode__PSM_Bandsplit_Filter = { 0x1D, 0x05, 0x02, 0x00 };
+/* PSM_RFpoly bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_PowerSavingMode__PSM_RFpoly = { 0x1D, 0x04, 0x01, 0x00 };
+/* PSM_Mixer bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_PowerSavingMode__PSM_Mixer = { 0x1D, 0x03, 0x01, 0x00 };
+/* PSM_Ifpoly bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_PowerSavingMode__PSM_Ifpoly = { 0x1D, 0x02, 0x01, 0x00 };
+/* PSM_Lodriver bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_PowerSavingMode__PSM_Lodriver = { 0x1D, 0x00, 0x02, 0x00 };
+
+
+/* TDA18273 Register Power_Level_byte_2 0x1E */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Level_byte_2 = { 0x1E, 0x00, 0x08, 0x00 };
+/* PD_PLD_read bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Level_byte_2__PD_PLD_read = { 0x1E, 0x07, 0x01, 0x00 };
+/* IR_Target bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Level_byte_2__PLD_Temp_Slope = { 0x1E, 0x05, 0x02, 0x00 };
+/* IR_GStep bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Level_byte_2__PLD_Gain_Corr = { 0x1E, 0x00, 0x05, 0x00 };
+
+
+/* TDA18273 Register Adapt_Top_byte 0x1F */
+const TDA18273_BitField_t gTDA18273_Reg_Adapt_Top_byte = { 0x1F, 0x00, 0x08, 0x00 };
+/* Fast_Mode_AGC bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Adapt_Top_byte__Fast_Mode_AGC = { 0x1F, 0x06, 0x01, 0x00 };
+/* Range_LNA_Adapt bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Adapt_Top_byte__Range_LNA_Adapt = { 0x1F, 0x05, 0x01, 0x00 };
+/* Index_K_LNA_Adapt bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Adapt_Top_byte__Index_K_LNA_Adapt = { 0x1F, 0x03, 0x02, 0x00 };
+/* Index_K_Top_Adapt bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Adapt_Top_byte__Index_K_Top_Adapt = { 0x1F, 0x01, 0x02, 0x00 };
+/* Ovld_Udld_FastUp bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Adapt_Top_byte__Ovld_Udld_FastUp = { 0x1F, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register Vsync_byte 0x20 */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_byte = { 0x20, 0x00, 0x08, 0x00 };
+/* Neg_modulation bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_byte__Neg_modulation = { 0x20, 0x07, 0x01, 0x00 };
+/* Tracer_Step bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_byte__Tracer_Step = { 0x20, 0x05, 0x02, 0x00 };
+/* Vsync_int bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_byte__Vsync_int = { 0x20, 0x04, 0x01, 0x00 };
+/* Vsync_Thresh bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_byte__Vsync_Thresh = { 0x20, 0x02, 0x02, 0x00 };
+/* Vsync_Len bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_byte__Vsync_Len = { 0x20, 0x00, 0x02, 0x00 };
+
+
+/* TDA18273 Register Vsync_Mgt_byte 0x21 */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_Mgt_byte = { 0x21, 0x00, 0x08, 0x00 };
+/* PD_Vsync_Mgt bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_Mgt_byte__PD_Vsync_Mgt = { 0x21, 0x07, 0x01, 0x00 };
+/* PD_Ovld bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_Mgt_byte__PD_Ovld = { 0x21, 0x06, 0x01, 0x00 };
+/* PD_Ovld_RF bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_Mgt_byte__PD_Ovld_RF = { 0x21, 0x05, 0x01, 0x00 };
+/* AGC_Ovld_TOP bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_Mgt_byte__AGC_Ovld_TOP = { 0x21, 0x02, 0x03, 0x00 };
+/* Up_Step_Ovld bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_Mgt_byte__Up_Step_Ovld = { 0x21, 0x01, 0x01, 0x00 };
+/* AGC_Ovld_Timer bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Vsync_Mgt_byte__AGC_Ovld_Timer = { 0x21, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register IR_Mixer_byte_2 0x22 */
+const TDA18273_BitField_t gTDA18273_Reg_IR_Mixer_byte_2 = { 0x22, 0x00, 0x08, 0x00 };
+/* IR_Mixer_loop_off bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IR_Mixer_byte_2__IR_Mixer_loop_off = { 0x22, 0x07, 0x01, 0x00 };
+/* IR_Mixer_Do_step bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IR_Mixer_byte_2__IR_Mixer_Do_step = { 0x22, 0x05, 0x02, 0x00 };
+/* Hi_Pass bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IR_Mixer_byte_2__Hi_Pass = { 0x22, 0x01, 0x01, 0x00 };
+/* IF_Notch bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IR_Mixer_byte_2__IF_Notch = { 0x22, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register AGC1_byte_3 0x23 */
+const TDA18273_BitField_t gTDA18273_Reg_AGC1_byte_3 = { 0x23, 0x00, 0x08, 0x00 };
+/* AGC1_loop_off bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC1_byte_3__AGC1_loop_off = { 0x23, 0x07, 0x01, 0x00 };
+/* AGC1_Do_step bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC1_byte_3__AGC1_Do_step = { 0x23, 0x05, 0x02, 0x00 };
+/* Force_AGC1_gain bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC1_byte_3__Force_AGC1_gain = { 0x23, 0x04, 0x01, 0x00 };
+/* AGC1_Gain bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC1_byte_3__AGC1_Gain = { 0x23, 0x00, 0x04, 0x00 };
+
+
+/* TDA18273 Register RFAGCs_Gain_byte_1 0x24 */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_1 = { 0x24, 0x00, 0x08, 0x00 };
+/* PLD_DAC_Scale bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_1__PLD_DAC_Scale = { 0x24, 0x07, 0x01, 0x00 };
+/* PLD_CC_Enable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_1__PLD_CC_Enable = { 0x24, 0x06, 0x01, 0x00 };
+/* PLD_Temp_Enable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_1__PLD_Temp_Enable = { 0x24, 0x05, 0x01, 0x00 };
+/* TH_AGC_Adapt34 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_1__TH_AGC_Adapt34 = { 0x24, 0x04, 0x01, 0x00 };
+/* RFAGC_Sense_Enable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_1__RFAGC_Sense_Enable = { 0x24, 0x02, 0x01, 0x00 };
+/* RFAGC_K_Bypass bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_1__RFAGC_K_Bypass = { 0x24, 0x01, 0x01, 0x00 };
+/* RFAGC_K_8 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_1__RFAGC_K_8 = { 0x24, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register RFAGCs_Gain_byte_2 0x25 */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_2 = { 0x25, 0x00, 0x08, 0x00 };
+/* RFAGC_K bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_2__RFAGC_K = { 0x25, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register AGC5_byte_2 0x26 */
+const TDA18273_BitField_t gTDA18273_Reg_AGC5_byte_2 = { 0x26, 0x00, 0x08, 0x00 };
+/* AGC5_loop_off bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC5_byte_2__AGC5_loop_off = { 0x26, 0x07, 0x01, 0x00 };
+/* AGC5_Do_step bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC5_byte_2__AGC5_Do_step = { 0x26, 0x05, 0x02, 0x00 };
+/* Force_AGC5_gain bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC5_byte_2__Force_AGC5_gain = { 0x26, 0x03, 0x01, 0x00 };
+/* AGC5_Gain bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGC5_byte_2__AGC5_Gain = { 0x26, 0x00, 0x03, 0x00 };
+
+
+/* TDA18273 Register RF_Cal_byte_1 0x27 */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_1 = { 0x27, 0x00, 0x08, 0x00 };
+/* RFCAL_Offset_Cprog0 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_1__RFCAL_Offset_Cprog0 = { 0x27, 0x06, 0x02, 0x00 };
+/* RFCAL_Offset_Cprog1 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_1__RFCAL_Offset_Cprog1 = { 0x27, 0x04, 0x02, 0x00 };
+/* RFCAL_Offset_Cprog2 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_1__RFCAL_Offset_Cprog2 = { 0x27, 0x02, 0x02, 0x00 };
+/* RFCAL_Offset_Cprog3 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_1__RFCAL_Offset_Cprog3 = { 0x27, 0x00, 0x02, 0x00 };
+
+
+/* TDA18273 Register RF_Cal_byte_2 0x28 */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_2 = { 0x28, 0x00, 0x08, 0x00 };
+/* RFCAL_Offset_Cprog4 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_2__RFCAL_Offset_Cprog4 = { 0x28, 0x06, 0x02, 0x00 };
+/* RFCAL_Offset_Cprog5 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_2__RFCAL_Offset_Cprog5 = { 0x28, 0x04, 0x02, 0x00 };
+/* RFCAL_Offset_Cprog6 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_2__RFCAL_Offset_Cprog6 = { 0x28, 0x02, 0x02, 0x00 };
+/* RFCAL_Offset_Cprog7 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_2__RFCAL_Offset_Cprog7 = { 0x28, 0x00, 0x02, 0x00 };
+
+
+/* TDA18273 Register RF_Cal_byte_3 0x29 */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_3 = { 0x29, 0x00, 0x08, 0x00 };
+/* RFCAL_Offset_Cprog8 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_3__RFCAL_Offset_Cprog8 = { 0x29, 0x06, 0x02, 0x00 };
+/* RFCAL_Offset_Cprog9 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_3__RFCAL_Offset_Cprog9 = { 0x29, 0x04, 0x02, 0x00 };
+/* RFCAL_Offset_Cprog10 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_3__RFCAL_Offset_Cprog10 = { 0x29, 0x02, 0x02, 0x00 };
+/* RFCAL_Offset_Cprog11 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Cal_byte_3__RFCAL_Offset_Cprog11 = { 0x29, 0x00, 0x02, 0x00 };
+
+
+/* TDA18273 Register Bandsplit_Filter_byte 0x2A */
+const TDA18273_BitField_t gTDA18273_Reg_Bandsplit_Filter_byte = { 0x2A, 0x00, 0x08, 0x00 };
+/* Bandsplit_Filter_SubBand bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Bandsplit_Filter_byte__Bandsplit_Filter_SubBand = { 0x2A, 0x00, 0x02, 0x00 };
+
+
+/* TDA18273 Register RF_Filters_byte_1 0x2B */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Filters_byte_1 = { 0x2B, 0x00, 0x08, 0x00 };
+/* RF_Filter_Bypass bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Filters_byte_1__RF_Filter_Bypass = { 0x2B, 0x07, 0x01, 0x00 };
+/* AGC2_loop_off bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Filters_byte_1__AGC2_loop_off = { 0x2B, 0x05, 0x01, 0x00 };
+/* Force_AGC2_gain bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Filters_byte_1__Force_AGC2_gain = { 0x2B, 0x04, 0x01, 0x00 };
+/* RF_Filter_Gv bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Filters_byte_1__RF_Filter_Gv = { 0x2B, 0x02, 0x02, 0x00 };
+/* RF_Filter_Band bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Filters_byte_1__RF_Filter_Band = { 0x2B, 0x00, 0x02, 0x00 };
+
+
+/* TDA18273 Register RF_Filters_byte_2 0x2C */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Filters_byte_2 = { 0x2C, 0x00, 0x08, 0x00 };
+/* RF_Filter_Cap bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Filters_byte_2__RF_Filter_Cap = { 0x2C, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register RF_Filters_byte_3 0x2D */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Filters_byte_3 = { 0x2D, 0x00, 0x08, 0x00 };
+/* AGC2_Do_step bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Filters_byte_3__AGC2_Do_step = { 0x2D, 0x06, 0x02, 0x00 };
+/* Gain_Taper bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Filters_byte_3__Gain_Taper = { 0x2D, 0x00, 0x06, 0x00 };
+
+
+/* TDA18273 Register RF_Band_Pass_Filter_byte 0x2E */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Band_Pass_Filter_byte = { 0x2E, 0x00, 0x08, 0x00 };
+/* RF_BPF_Bypass bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Band_Pass_Filter_byte__RF_BPF_Bypass = { 0x2E, 0x07, 0x01, 0x00 };
+/* RF_BPF bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RF_Band_Pass_Filter_byte__RF_BPF = { 0x2E, 0x00, 0x03, 0x00 };
+
+
+/* TDA18273 Register CP_Current_byte 0x2F */
+const TDA18273_BitField_t gTDA18273_Reg_CP_Current_byte = { 0x2F, 0x00, 0x08, 0x00 };
+/* LO_CP_Current bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_CP_Current_byte__LO_CP_Current = { 0x2F, 0x07, 0x01, 0x00 };
+/* N_CP_Current bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_CP_Current_byte__N_CP_Current = { 0x2F, 0x00, 0x07, 0x00 };
+
+
+/* TDA18273 Register AGCs_DetOut_byte 0x30 */
+const TDA18273_BitField_t gTDA18273_Reg_AGCs_DetOut_byte = { 0x30, 0x00, 0x08, 0x00 };
+/* Up_AGC5 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCs_DetOut_byte__Up_AGC5 = { 0x30, 0x07, 0x01, 0x00 };
+/* Do_AGC5 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCs_DetOut_byte__Do_AGC5 = { 0x30, 0x06, 0x01, 0x00 };
+/* Up_AGC4 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCs_DetOut_byte__Up_AGC4 = { 0x30, 0x05, 0x01, 0x00 };
+/* Do_AGC4 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCs_DetOut_byte__Do_AGC4 = { 0x30, 0x04, 0x01, 0x00 };
+/* Up_AGC2 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCs_DetOut_byte__Up_AGC2 = { 0x30, 0x03, 0x01, 0x00 };
+/* Do_AGC2 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCs_DetOut_byte__Do_AGC2 = { 0x30, 0x02, 0x01, 0x00 };
+/* Up_AGC1 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCs_DetOut_byte__Up_AGC1 = { 0x30, 0x01, 0x01, 0x00 };
+/* Do_AGC1 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_AGCs_DetOut_byte__Do_AGC1 = { 0x30, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register RFAGCs_Gain_byte_3 0x31 */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_3 = { 0x31, 0x00, 0x08, 0x00 };
+/* AGC2_Gain_Read bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_3__AGC2_Gain_Read = { 0x31, 0x04, 0x02, 0x00 };
+/* AGC1_Gain_Read bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_3__AGC1_Gain_Read = { 0x31, 0x00, 0x04, 0x00 };
+
+
+/* TDA18273 Register RFAGCs_Gain_byte_4 0x32 */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_4 = { 0x32, 0x00, 0x08, 0x00 };
+/* Cprog_Read bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_4__Cprog_Read = { 0x32, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register RFAGCs_Gain_byte_5 0x33 */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_5 = { 0x33, 0x00, 0x08, 0x00 };
+/* RFAGC_Read_K_8 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_5__RFAGC_Read_K_8 = { 0x33, 0x07, 0x01, 0x00 };
+/* Do_AGC1bis bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_5__Do_AGC1bis = { 0x33, 0x06, 0x01, 0x00 };
+/* AGC1_Top_Adapt_Low bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_5__AGC1_Top_Adapt_Low = { 0x33, 0x05, 0x01, 0x00 };
+/* Up_LNA_Adapt bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_5__Up_LNA_Adapt = { 0x33, 0x04, 0x01, 0x00 };
+/* Do_LNA_Adapt bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_5__Do_LNA_Adapt = { 0x33, 0x03, 0x01, 0x00 };
+/* TOP_AGC3_Read bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_5__TOP_AGC3_Read = { 0x33, 0x00, 0x03, 0x00 };
+
+
+/* TDA18273 Register RFAGCs_Gain_byte_6 0x34 */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_6 = { 0x34, 0x00, 0x08, 0x00 };
+/* RFAGC_Read_K bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RFAGCs_Gain_byte_6__RFAGC_Read_K = { 0x34, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register IFAGCs_Gain_byte 0x35 */
+const TDA18273_BitField_t gTDA18273_Reg_IFAGCs_Gain_byte = { 0x35, 0x00, 0x08, 0x00 };
+/* AGC5_Gain_Read bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IFAGCs_Gain_byte__AGC5_Gain_Read = { 0x35, 0x03, 0x03, 0x00 };
+/* AGC4_Gain_Read bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IFAGCs_Gain_byte__AGC4_Gain_Read = { 0x35, 0x00, 0x03, 0x00 };
+
+
+/* TDA18273 Register RSSI_byte_1 0x36 */
+const TDA18273_BitField_t gTDA18273_Reg_RSSI_byte_1 = { 0x36, 0x00, 0x08, 0x00 };
+/* RSSI bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RSSI_byte_1__RSSI = { 0x36, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register RSSI_byte_2 0x37 */
+const TDA18273_BitField_t gTDA18273_Reg_RSSI_byte_2 = { 0x37, 0x00, 0x08, 0x00 };
+/* RSSI_AV bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RSSI_byte_2__RSSI_AV = { 0x37, 0x05, 0x01, 0x00 };
+/* RSSI_Cap_Reset_En bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RSSI_byte_2__RSSI_Cap_Reset_En = { 0x37, 0x03, 0x01, 0x00 };
+/* RSSI_Cap_Val bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RSSI_byte_2__RSSI_Cap_Val = { 0x37, 0x02, 0x01, 0x00 };
+/* RSSI_Ck_Speed bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RSSI_byte_2__RSSI_Ck_Speed = { 0x37, 0x01, 0x01, 0x00 };
+/* RSSI_Dicho_not bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_RSSI_byte_2__RSSI_Dicho_not = { 0x37, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register Misc_byte 0x38 */
+const TDA18273_BitField_t gTDA18273_Reg_Misc_byte = { 0x38, 0x00, 0x08, 0x00 };
+/* RFCALPOR_I2C bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Misc_byte__RFCALPOR_I2C = { 0x38, 0x06, 0x01, 0x00 };
+/* PD_Underload bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Misc_byte__PD_Underload = { 0x38, 0x05, 0x01, 0x00 };
+/* DDS_Polarity bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Misc_byte__DDS_Polarity = { 0x38, 0x04, 0x01, 0x00 };
+/* IRQ_Mode bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Misc_byte__IRQ_Mode = { 0x38, 0x01, 0x01, 0x00 };
+/* IRQ_Polarity bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Misc_byte__IRQ_Polarity = { 0x38, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_0 0x39 */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_0 = { 0x39, 0x00, 0x08, 0x00 };
+/* rfcal_log_0 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_0__rfcal_log_0 = { 0x39, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_1 0x3A */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_1 = { 0x3A, 0x00, 0x08, 0x00 };
+/* rfcal_log_1 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_1__rfcal_log_1 = { 0x3A, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_2 0x3B */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_2 = { 0x3B, 0x00, 0x08, 0x00 };
+/* rfcal_log_2 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_2__rfcal_log_2 = { 0x3B, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_3 0x3C */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_3 = { 0x3C, 0x00, 0x08, 0x00 };
+/* rfcal_log_3 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_3__rfcal_log_3 = { 0x3C, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_4 0x3D */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_4 = { 0x3D, 0x00, 0x08, 0x00 };
+/* rfcal_log_4 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_4__rfcal_log_4 = { 0x3D, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_5 0x3E */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_5 = { 0x3E, 0x00, 0x08, 0x00 };
+/* rfcal_log_5 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_5__rfcal_log_5 = { 0x3E, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_6 0x3F */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_6 = { 0x3F, 0x00, 0x08, 0x00 };
+/* rfcal_log_6 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_6__rfcal_log_6 = { 0x3F, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_7 0x40 */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_7 = { 0x40, 0x00, 0x08, 0x00 };
+/* rfcal_log_7 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_7__rfcal_log_7 = { 0x40, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_8 0x41 */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_8 = { 0x41, 0x00, 0x08, 0x00 };
+/* rfcal_log_8 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_8__rfcal_log_8 = { 0x41, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_9 0x42 */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_9 = { 0x42, 0x00, 0x08, 0x00 };
+/* rfcal_log_9 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_9__rfcal_log_9 = { 0x42, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_10 0x43 */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_10 = { 0x43, 0x00, 0x08, 0x00 };
+/* rfcal_log_10 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_10__rfcal_log_10 = { 0x43, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register rfcal_log_11 0x44 */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_11 = { 0x44, 0x00, 0x08, 0x00 };
+/* rfcal_log_11 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_rfcal_log_11__rfcal_log_11 = { 0x44, 0x00, 0x08, 0x00 };
+
+
+
+/* TDA18273 Register Main_Post_Divider_byte 0x51 */
+const TDA18273_BitField_t gTDA18273_Reg_Main_Post_Divider_byte = { 0x51, 0x00, 0x08, 0x00 };
+/* LOPostDiv bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Main_Post_Divider_byte__LOPostDiv = { 0x51, 0x04, 0x03, 0x00 };
+/* LOPresc bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Main_Post_Divider_byte__LOPresc = { 0x51, 0x00, 0x04, 0x00 };
+
+
+/* TDA18273 Register Sigma_delta_byte_1 0x52 */
+const TDA18273_BitField_t gTDA18273_Reg_Sigma_delta_byte_1 = { 0x52, 0x00, 0x08, 0x00 };
+/* LO_Int bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Sigma_delta_byte_1__LO_Int = { 0x52, 0x00, 0x07, 0x00 };
+
+
+/* TDA18273 Register Sigma_delta_byte_2 0x53 */
+const TDA18273_BitField_t gTDA18273_Reg_Sigma_delta_byte_2 = { 0x53, 0x00, 0x08, 0x00 };
+/* LO_Frac_2 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Sigma_delta_byte_2__LO_Frac_2 = { 0x53, 0x00, 0x07, 0x00 };
+
+
+/* TDA18273 Register Sigma_delta_byte_3 0x54 */
+const TDA18273_BitField_t gTDA18273_Reg_Sigma_delta_byte_3 = { 0x54, 0x00, 0x08, 0x00 };
+/* LO_Frac_1 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Sigma_delta_byte_3__LO_Frac_1 = { 0x54, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register Sigma_delta_byte_4 0x55 */
+const TDA18273_BitField_t gTDA18273_Reg_Sigma_delta_byte_4 = { 0x55, 0x00, 0x08, 0x00 };
+/* LO_Frac_0 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Sigma_delta_byte_4__LO_Frac_0 = { 0x55, 0x00, 0x08, 0x00 };
+
+
+/* TDA18273 Register Sigma_delta_byte_5 0x56 */
+const TDA18273_BitField_t gTDA18273_Reg_Sigma_delta_byte_5 = { 0x56, 0x00, 0x08, 0x00 };
+/* N_K_correct_manual bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Sigma_delta_byte_5__N_K_correct_manual = { 0x56, 0x01, 0x01, 0x00 };
+/* LO_Calc_Disable bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Sigma_delta_byte_5__LO_Calc_Disable = { 0x56, 0x00, 0x01, 0x00 };
+
+
+/* TDA18273 Register Regulators_byte 0x58 */
+const TDA18273_BitField_t gTDA18273_Reg_Regulators_byte = { 0x58, 0x00, 0x08, 0x00 };
+/* RF_Reg bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Regulators_byte__RF_Reg = { 0x58, 0x02, 0x02, 0x00 };
+
+
+/* TDA18273 Register IR_Cal_byte_5 0x5B */
+const TDA18273_BitField_t gTDA18273_Reg_IR_Cal_byte_5 = { 0x5B, 0x00, 0x08, 0x00 };
+/* Mixer_Gain_Bypass bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IR_Cal_byte_5__Mixer_Gain_Bypass = { 0x5B, 0x07, 0x01, 0x00 };
+/* IR_Mixer_Gain bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_IR_Cal_byte_5__IR_Mixer_Gain = { 0x5B, 0x04, 0x03, 0x00 };
+
+
+/* TDA18273 Register Power_Down_byte_2 0x5F */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Down_byte_2 = { 0x5F, 0x00, 0x08, 0x00 };
+/* PD_LNA bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Down_byte_2__PD_LNA = { 0x5F, 0x07, 0x01, 0x00 };
+/* PD_Det4 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Down_byte_2__PD_Det4 = { 0x5F, 0x03, 0x01, 0x00 };
+/* PD_Det3 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Down_byte_2__PD_Det3 = { 0x5F, 0x02, 0x01, 0x00 };
+/* PD_Det1 bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Down_byte_2__PD_Det1 = { 0x5F, 0x00, 0x01, 0x00 };
+
+/* TDA18273 Register Power_Down_byte_3 0x60 */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Down_byte_3 = { 0x60, 0x00, 0x08, 0x00 };
+/* Force_Soft_Reset bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Down_byte_3__Force_Soft_Reset = { 0x60, 0x01, 0x01, 0x00 };
+/* Soft_Reset bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Power_Down_byte_3__Soft_Reset = { 0x60, 0x00, 0x01, 0x00 };
+
+/* TDA18273 Register Charge_pump_byte 0x64 */
+const TDA18273_BitField_t gTDA18273_Reg_Charge_pump_byte = { 0x64, 0x00, 0x08, 0x00 };
+/* ICP_Bypass bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Charge_pump_byte__ICP_Bypass = { 0x64, 0x07, 0x01, 0x00 };
+/* ICP bit(s):  */
+const TDA18273_BitField_t gTDA18273_Reg_Charge_pump_byte__ICP = { 0x64, 0x00, 0x02, 0x00 };
+
+
+static int tda18273_readreg(struct tda18273_state *priv, unsigned char reg, unsigned char *val)
+{
+	int ret = TDA_RESULT_SUCCESS;
+	struct dvb_frontend *fe	= priv->fe;
+
+	struct i2c_msg msg[2] = {
+		{ .addr = priv->i2c_addr,
+			.flags = 0, .buf = &reg, .len = 1},
+		{ .addr = priv->i2c_addr,
+			.flags = I2C_M_RD, .buf = val, .len = 1},
+	};
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	
+	ret = i2c_transfer(priv->i2c, msg, 2);
+	
+	if (ret != 2) {
+		dprintk(FE_ERROR, 1, "I2C read failed");
+		ret = TDA_RESULT_I2C_READ_FAILURE;
+	}
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	
+	return ret;
+}
+
+static int tda18273_readregs(struct tda18273_state *priv, const TDA18273_BitField_t* pBitField, unsigned char *val, tmbslFrontEndBusAccess_t eBusAccess)
+{
+	unsigned char RegAddr = 0;
+	unsigned char RegMask = 0;
+	unsigned char RegData = 0;
+	unsigned char* pRegData = NULL;
+	
+	RegAddr = pBitField->Address;
+	
+	if(RegAddr < TDA18273_REG_MAP_NB_BYTES)	{
+		pRegData = (unsigned char *)(&(priv->regmap)) + RegAddr;
+	} else {
+		pRegData = &RegData;
+	}
+	
+	if((eBusAccess & Bus_NoRead) == 0x00) {
+		if(tda18273_readreg(priv, RegAddr, pRegData) == TDA_RESULT_I2C_READ_FAILURE) {
+			return TDA_RESULT_I2C_READ_FAILURE;
+		}
+	}
+	
+	*val = *pRegData;
+	
+	RegMask = ((1 << pBitField->WidthInBits) - 1) << pBitField->PositionInBits;
+	
+	*val &= RegMask;
+	*val = (*val) >> pBitField->PositionInBits;
+
+	return TDA_RESULT_SUCCESS;
+}
+
+static int tda18273_readregmap(struct tda18273_state *priv, unsigned char reg, unsigned int len)
+{
+	int ret, i;
+	unsigned char* pRegData = NULL;
+	
+	if((reg < TDA18273_REG_MAP_NB_BYTES) && ((reg + len) <= TDA18273_REG_MAP_NB_BYTES)) {
+		pRegData = (unsigned char *)(&(priv->regmap)) + reg;
+		
+		for(i=0; i<len; i++) {
+			/* Read data from TDA18273 */
+			ret = tda18273_readreg(priv, (reg + i), (pRegData + i));
+		}
+	}
+	
+	return 0;
+}
+
+static int tda18273_writereg(struct tda18273_state *priv, unsigned char reg, unsigned char val)
+{
+	int ret = TDA_RESULT_SUCCESS;
+	struct dvb_frontend *fe	= priv->fe;
+	unsigned char tmp[2] = {reg, val};
+	
+	struct i2c_msg msg = { 
+		.addr = priv->i2c_addr,
+		.flags = 0, .buf = tmp, .len = 2};
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	
+	ret = i2c_transfer(priv->i2c, &msg, 1);
+	
+	if (ret != 1) {
+		dprintk(FE_ERROR, 1, "I2C write failed");
+		ret = TDA_RESULT_I2C_READ_FAILURE;
+	}
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	
+	return ret;
+}
+
+static int tda18273_writeregs(struct tda18273_state *priv, const TDA18273_BitField_t* pBitField, unsigned char val, tmbslFrontEndBusAccess_t eBusAccess)
+{
+	unsigned char RegAddr = 0;
+	unsigned char RegData = 0;
+	unsigned char RegMask = 0;
+	unsigned char* pRegData = NULL;
+
+	RegAddr = pBitField->Address;
+	
+	if(RegAddr < TDA18273_REG_MAP_NB_BYTES)	{
+		pRegData = (unsigned char *)(&(priv->regmap)) + RegAddr;
+	} else {
+		pRegData = &RegData;
+	}
+
+	if((eBusAccess & Bus_NoRead) == 0x00) {
+		if(tda18273_readreg(priv, RegAddr, pRegData) == TDA_RESULT_I2C_READ_FAILURE) {
+			return TDA_RESULT_I2C_READ_FAILURE;
+		}
+	}
+	
+	RegMask = (1 << pBitField->WidthInBits) - 1;
+	val &= RegMask;
+
+	RegMask = RegMask << pBitField->PositionInBits;
+	*pRegData &= (UInt8)(~RegMask);
+	*pRegData |= val << pBitField->PositionInBits;
+
+	if((eBusAccess & Bus_NoWrite) == 0x00) {
+		if(tda18273_writereg(priv, RegAddr, *pRegData) == TDA_RESULT_I2C_READ_FAILURE) {
+			return TDA_RESULT_I2C_READ_FAILURE;
+		}
+	}
+	
+	return TDA_RESULT_SUCCESS;
+}
+
+static int tda18273_writeregmap(struct tda18273_state *priv, unsigned char reg, unsigned int len)
+{
+	int ret, i;
+	unsigned char* pRegData = NULL;
+	
+	if((reg < TDA18273_REG_MAP_NB_BYTES) && ((reg + len) <= TDA18273_REG_MAP_NB_BYTES)) {
+		pRegData = (unsigned char *)(&(priv->regmap)) + reg;
+		
+		for(i=0; i<len; i++) {
+			/* Write data from TDA18273 */
+			ret = tda18273_writereg(priv, (reg + i), *(pRegData + i));
+		}
+	}
+	
+	return 0;
+}
+
+static void tda18273_regall_debug(struct tda18273_state *priv)
+{
+	int i;
+	unsigned char val=0;
+
+	for(i=0; i<0x45; i++) {
+		tda18273_readreg(priv, i, &val);
+		dprintk(FE_DEBUGREG, 1, "addr : 0x%02x  =>  data : 0x%02x", i, val);
+	}
+}
+
+static int tda18273_get_lock_status(struct tda18273_state *priv, unsigned short *lock_status)
+{
+	int ret;
+	unsigned char val=0;
+	unsigned char val_lo=0;
+
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_Power_state_byte_1__LO_Lock, &val_lo, Bus_RW);
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_IRQ_status__IRQ_status, &val, Bus_RW);
+	*lock_status = val & val_lo;
+
+	dprintk(FE_INFO, 1, "lock=0x%02X/0x%02x, lock_status=0x%x", val, val_lo, *lock_status);
+
+	return 0;
+}
+
+static int tda18273_pwr_state(struct dvb_frontend *fe, int pwr_state)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	int ret=0;
+
+	if(priv->power_state != pwr_state) {
+		if(pwr_state == tmPowerOn) {
+			/* Set TDA18273 power state to Normal Mode */
+			ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_Down_byte_2__PD_LNA, 0x1, Bus_RW);				/* PD LNA */
+			ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_Down_byte_2__PD_Det1, 0x1, Bus_NoRead);			/* PD Detector AGC1 */
+			ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC1_byte_3__AGC1_loop_off, 0x1, Bus_RW);				/* AGC1 Detector loop off */
+			ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_state_byte_2, TDA18273_SM_NONE, Bus_RW);
+			ret = tda18273_writeregs(priv, &gTDA18273_Reg_Reference_Byte__Digital_Clock_Mode, 0x03, Bus_RW);		/* Set digital clock mode to sub-LO if normal mode is entered */
+		} else if(pwr_state == tmPowerStandby) {
+			/* Set TDA18273 power state to standby with Xtal ON */
+			ret = tda18273_writeregs(priv, &gTDA18273_Reg_Reference_Byte__Digital_Clock_Mode, 0x00, Bus_RW);
+			ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_state_byte_2, 0x02, Bus_RW);
+		}
+
+		priv->power_state = pwr_state;
+	}
+
+	return 0;
+}
+
+static int tda18273_firstpass_lnapwr(struct dvb_frontend *fe)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	
+	int ret;
+	
+	/* PD LNA */
+    ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_Down_byte_2__PD_LNA, 0x1, Bus_RW);
+	/* PD Detector AGC1 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_Down_byte_2__PD_Det1, 0x1, Bus_NoRead);
+	/* AGC1 Detector loop off */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC1_byte_3__AGC1_loop_off, 0x1, Bus_RW);
+        
+	return 0;
+}
+
+static int tda18273_lastpass_lnapwr(struct dvb_frontend *fe)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	
+	unsigned char val = 0;
+	int ret;
+	
+	/* Check if LNA is PD */
+    ret = tda18273_readregs(priv, &gTDA18273_Reg_Power_Down_byte_2__PD_LNA, &val, Bus_NoWrite);
+
+	if(val == 1) {
+		/* LNA is Powered Down, so power it up */
+		/* Force gain to -10dB */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC1_byte_3__AGC1_Gain, 0x0, Bus_RW);
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC1_byte_3__Force_AGC1_gain, 0x1, Bus_NoRead);
+		/* PD LNA */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_Down_byte_2__PD_LNA, 0x0, Bus_NoRead);
+		/* Release LNA gain control */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC1_byte_3__Force_AGC1_gain, 0x0, Bus_NoRead);
+		/* PD Detector AGC1 */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_Down_byte_2__PD_Det1, 0x0, Bus_NoRead);
+		/* AGC1 Detector loop off */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC1_byte_3__AGC1_loop_off, 0x0, Bus_NoRead);
+	}
+    
+	return 0;
+}
+
+static int tda18273_llpwr_state(struct dvb_frontend *fe, int llpwr_state)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	
+	unsigned char val = 0;
+	int ret;
+	
+	if(llpwr_state == TDA18273_PowerNormalMode) {
+		/* If we come from any standby mode, then power on the IC with LNA off */
+        /* Then powering on LNA with the minimal gain on AGC1 to avoid glitches at RF input will */
+        /* be done during SetRF */
+
+        /* Workaround to limit the spurs occurence on RF input, do it before entering normal mode */
+        /* PD LNA */
+		ret = tda18273_firstpass_lnapwr(fe);
+        ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_state_byte_2, TDA18273_SM_NONE, Bus_RW);
+		/* Set digital clock mode to sub-LO if normal mode is entered */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Reference_Byte__Digital_Clock_Mode, 0x03, Bus_RW);
+
+        /* Reset val to use it as a flag for below test */
+        val = 0;
+	} else if(llpwr_state == TDA18273_PowerStandbyWithXtalOn) {
+		val = TDA18273_SM;
+	} else if(llpwr_state == TDA18273_PowerStandby) {
+		/* power state not supported */
+		val = TDA18273_SM|TDA18273_SM_XT;
+	}
+	
+	if(val) {
+		/* Set digital clock mode to 16 Mhz before entering standby */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Reference_Byte__Digital_Clock_Mode, 0x00, Bus_RW);
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_state_byte_2, val, Bus_RW);
+	}
+	
+	return 0;
+}
+
+static int tda18273_check_calcpll(struct dvb_frontend *fe)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+
+	int ret;
+	unsigned char val;
+
+    /* Check if Calc_PLL algorithm is in automatic mode */
+    ret = tda18273_readregs(priv, &gTDA18273_Reg_Sigma_delta_byte_5__LO_Calc_Disable, &val, Bus_None);
+    
+    if(val != 0x00) {
+        /* Enable Calc_PLL algorithm by putting PLL in automatic mode */
+        ret = tda18273_writeregs(priv, &gTDA18273_Reg_Sigma_delta_byte_5__N_K_correct_manual, 0x00, Bus_None);
+        ret = tda18273_writeregs(priv, &gTDA18273_Reg_Sigma_delta_byte_5__LO_Calc_Disable, 0x00, Bus_NoRead);
+    } 
+	
+	return 0;
+}
+
+static int tda18273_set_msm(struct dvb_frontend *fe, unsigned char val, int launch)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	int ret;
+	
+	/* Set state machine and Launch it */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_MSM_byte_1, val, Bus_None);
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_MSM_byte_2__MSM_Launch, 0x01, Bus_None);
+	ret = tda18273_writeregmap(priv, gTDA18273_Reg_MSM_byte_1.Address, (launch ? 0x02 : 0x01));
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_MSM_byte_2__MSM_Launch, 0x00, Bus_None);
+	
+	return 0;
+}
+
+static int tda18273_override_bandsplit(struct dvb_frontend *fe)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	
+	int ret;
+	unsigned char Bandsplit = 0;
+	unsigned char uPrevPSM_Bandsplit_Filter = 0;
+	unsigned char PSM_Bandsplit_Filter = 0;
+	
+	/* Setting PSM bandsplit at -3.9 mA for some RF frequencies */
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_Bandsplit_Filter_byte__Bandsplit_Filter_SubBand, &Bandsplit, Bus_None);
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_PowerSavingMode__PSM_Bandsplit_Filter, &uPrevPSM_Bandsplit_Filter, Bus_None);
+	
+	switch(Bandsplit)
+	{
+		default:
+		case 0:	/* LPF0 133MHz - LPF1 206MHz - HPF0 422MHz */
+				if(priv->pObj->uProgRF < 133000000) {
+					/* Set PSM bandsplit at -3.9 mA */
+					PSM_Bandsplit_Filter = 0x03;
+				} else {
+					/* Set PSM bandsplit at nominal */
+					PSM_Bandsplit_Filter = 0x02;
+				}
+			break;
+		case 1:	/* LPF0 139MHz - LPF1 218MHz - HPF0 446MHz */
+				if(priv->pObj->uProgRF < 139000000) {
+					/* Set PSM bandsplit at -3.9 mA */
+					PSM_Bandsplit_Filter = 0x03;
+				} else {
+					/* Set PSM bandsplit at nominal */
+					PSM_Bandsplit_Filter = 0x02;
+				}
+			break;
+		case 2:	/* LPF0 145MHz - LPF1 230MHz - HPF0 470MHz */
+				if(priv->pObj->uProgRF < 145000000) {
+					/* Set PSM bandsplit at -3.9 mA */
+					PSM_Bandsplit_Filter = 0x03;
+				} else {
+					/* Set PSM bandsplit at nominal */
+					PSM_Bandsplit_Filter = 0x02;
+				}
+			break;
+		case 3: /* LPF0 151MHz - LPF1 242MHz - HPF0 494MHz */
+				if(priv->pObj->uProgRF < 151000000) {
+					/* Set PSM bandsplit at -3.9 mA */
+					PSM_Bandsplit_Filter = 0x03;
+				} else {
+					/* Set PSM bandsplit at nominal */
+					PSM_Bandsplit_Filter = 0x02;
+				}
+			break;
+	}
+	
+	if(uPrevPSM_Bandsplit_Filter != PSM_Bandsplit_Filter) {
+		/* Write PSM bandsplit */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_PowerSavingMode__PSM_Bandsplit_Filter, PSM_Bandsplit_Filter, Bus_NoRead);
+	}
+    
+	return 0;
+}
+
+static int tda18273_set_standardmode(struct dvb_frontend *fe, TDA18273StandardMode_t StandardMode)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	int ret;
+	
+	unsigned char wantedValue=0;
+	unsigned char checked=0;
+	
+	priv->pObj->StandardMode = StandardMode;
+	
+	if((priv->pObj->StandardMode > TDA18273_StandardMode_Unknown) && (priv->pObj->StandardMode < TDA18273_StandardMode_Max)) {
+		/* Update standard map pointer */
+		priv->pObj->pStandard = &priv->pObj->Std_Array[priv->pObj->StandardMode - 1];
+		
+		/****************************************************************/
+		/* IF SELECTIVITY Settings                                      */
+		/****************************************************************/
+		/* Set LPF */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_IF_Byte_1__LP_Fc, priv->pObj->pStandard->LPF, Bus_None);
+		/* Set LPF Offset */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_IF_Byte_1__LP_FC_Offset, priv->pObj->pStandard->LPF_Offset, Bus_None);
+		/* Set DC_Notch_IF_PPF */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_IR_Mixer_byte_2__IF_Notch, priv->pObj->pStandard->DC_Notch_IF_PPF, Bus_None);
+		/* Enable/disable HPF */
+		if(priv->pObj->pStandard->IF_HPF == TDA18273_IF_HPF_Disabled) {
+			ret = tda18273_writeregs(priv, &gTDA18273_Reg_IR_Mixer_byte_2__Hi_Pass, 0x00, Bus_None);
+		} else {
+			ret = tda18273_writeregs(priv, &gTDA18273_Reg_IR_Mixer_byte_2__Hi_Pass, 0x01, Bus_None);
+		    /* Set IF HPF */
+		    ret = tda18273_writeregs(priv, &gTDA18273_Reg_IF_Byte_1__IF_HP_Fc, (UInt8)(priv->pObj->pStandard->IF_HPF - 1), Bus_None);
+		}
+		/* Set IF Notch */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_IF_Byte_1__IF_ATSC_Notch, priv->pObj->pStandard->IF_Notch, Bus_None);
+		/* Set IF notch to RSSI */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_IF_AGC_byte__IFnotchToRSSI, priv->pObj->pStandard->IFnotchToRSSI, Bus_None);
+				
+		/****************************************************************/
+		/* AGC TOP Settings                                             */
+		/****************************************************************/
+		/* Set AGC1 TOP I2C DN/UP */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC1_byte_1__AGC1_TOP, priv->pObj->pStandard->AGC1_TOP_I2C_DN_UP, Bus_None);
+		/* Set AGC1 Adapt TOP DN/UP */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC1_byte_2__AGC1_Top_Mode_Val, priv->pObj->pStandard->AGC1_Adapt_TOP_DN_UP, Bus_None);
+		/* Set AGC1 DN Time Constant */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC1_byte_3__AGC1_Do_step, priv->pObj->pStandard->AGC1_DN_Time_Constant, Bus_None);
+		/* Set AGC1 mode */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC1_byte_2__AGC1_Top_Mode, priv->pObj->pStandard->AGC1_Mode, Bus_None);
+		/* Set Range_LNA_Adapt */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Adapt_Top_byte__Range_LNA_Adapt, priv->pObj->pStandard->Range_LNA_Adapt, Bus_None);
+		/* Set LNA_Adapt_RFAGC_Gv_Threshold */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Adapt_Top_byte__Index_K_LNA_Adapt, priv->pObj->pStandard->LNA_Adapt_RFAGC_Gv_Threshold, Bus_None);
+		/* Set AGC1_Top_Adapt_RFAGC_Gv_Threshold */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Adapt_Top_byte__Index_K_Top_Adapt, priv->pObj->pStandard->AGC1_Top_Adapt_RFAGC_Gv_Threshold, Bus_None);
+		/* Set AGC2 TOP DN/UP */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC2_byte_1__AGC2_TOP, priv->pObj->pStandard->AGC2_TOP_DN_UP, Bus_None);
+		/* Set AGC2 DN Time Constant */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Filters_byte_3__AGC2_Do_step, priv->pObj->pStandard->AGC2_DN_Time_Constant, Bus_None);
+		/* Set AGC4 TOP DN/UP */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_IR_Mixer_byte_1__IR_Mixer_Top, priv->pObj->pStandard->AGC4_TOP_DN_UP, Bus_None);
+		/* Set AGC5 TOP DN/UP */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC5_byte_1__AGC5_TOP, priv->pObj->pStandard->AGC5_TOP_DN_UP, Bus_None);
+		/* Set AGC3_Top_Adapt_Algorithm */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_AGC_byte__PD_AGC_Adapt3x, priv->pObj->pStandard->AGC3_Top_Adapt_Algorithm, Bus_None);
+		/* Set AGC Overload TOP */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Vsync_Mgt_byte__AGC_Ovld_TOP, priv->pObj->pStandard->AGC_Overload_TOP, Bus_None);
+		/* Set Adapt TOP 34 Gain Threshold */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_RFAGCs_Gain_byte_1__TH_AGC_Adapt34, priv->pObj->pStandard->TH_AGC_Adapt34, Bus_None);
+		/* Set RF atten 3dB */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_W_Filter_byte__RF_Atten_3dB, priv->pObj->pStandard->RF_Atten_3dB, Bus_None);
+		/* Set IF Output Level */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_IF_AGC_byte__IF_level, priv->pObj->pStandard->IF_Output_Level, Bus_None);
+		/* Set S2D gain */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_IR_Mixer_byte_1__S2D_Gain, priv->pObj->pStandard->S2D_Gain, Bus_None);
+		/* Set Negative modulation, write into register directly because vsync_int bit is checked afterwards */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Vsync_byte__Neg_modulation, priv->pObj->pStandard->Negative_Modulation, Bus_RW);
+		
+		/****************************************************************/
+		/* GSK Settings                                                 */
+		/****************************************************************/
+		/* Set AGCK Step */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGCK_byte_1__AGCK_Step, priv->pObj->pStandard->AGCK_Steps, Bus_None);
+		/* Set AGCK Time Constant */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGCK_byte_1__AGCK_Mode, priv->pObj->pStandard->AGCK_Time_Constant, Bus_None);
+		/* Set AGC5 HPF */
+		wantedValue = priv->pObj->pStandard->AGC5_HPF;
+		if(priv->pObj->pStandard->AGC5_HPF == TDA18273_AGC5_HPF_Enabled) {
+			/* Check if Internal Vsync is selected */
+			ret = tda18273_readregs(priv, &gTDA18273_Reg_Vsync_byte__Vsync_int, &checked, Bus_RW);
+
+			if(checked == 0) {
+				/* Internal Vsync is OFF, so override setting to OFF */
+				wantedValue = TDA18273_AGC5_HPF_Disabled;
+			}
+		}
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGC5_byte_1__AGC5_Ana, wantedValue, Bus_None);
+		/* Set Pulse Shaper Disable */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_AGCK_byte_1__Pulse_Shaper_Disable, priv->pObj->pStandard->Pulse_Shaper_Disable, Bus_None);
+
+		/****************************************************************/
+		/* H3H5 Settings                                                */
+		/****************************************************************/
+		/* Set VHF_III_Mode */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_W_Filter_byte__VHF_III_mode, priv->pObj->pStandard->VHF_III_Mode, Bus_None);
+		
+		/****************************************************************/
+		/* PLL Settings                                                 */
+		/****************************************************************/
+		/* Set LO_CP_Current */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_CP_Current_byte__LO_CP_Current, priv->pObj->pStandard->LO_CP_Current, Bus_None);
+		
+		/****************************************************************/
+		/* IF Settings                                                  */
+		/****************************************************************/
+		/* Set IF */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_IF_Frequency_byte__IF_Freq, (UInt8)((priv->pObj->pStandard->IF - priv->pObj->pStandard->CF_Offset)/50000), Bus_None);
+
+		/****************************************************************/
+		/* MISC Settings                                                */
+		/****************************************************************/
+		/* Set PD Underload */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Misc_byte__PD_Underload, priv->pObj->pStandard->PD_Underload, Bus_None);
+
+		/****************************************************************/
+		/* Update Registers                                             */
+		/****************************************************************/
+		/* Write AGC1_byte_1 (0x0C) to IF_Byte_1 (0x15) Registers */
+		ret = tda18273_writeregmap(priv, gTDA18273_Reg_AGC1_byte_1.Address, TDA18273_REG_DATA_LEN(gTDA18273_Reg_AGC1_byte_1, gTDA18273_Reg_IF_Byte_1));
+		/* Write IF_Frequency_byte (0x17) Register */
+		ret = tda18273_writeregmap(priv, gTDA18273_Reg_IF_Frequency_byte.Address, 1);
+		/* Write Adapt_Top_byte (0x1F) Register */
+		ret = tda18273_writeregmap(priv, gTDA18273_Reg_Adapt_Top_byte.Address, 1);
+		/* Write Vsync_byte (0x20) to RFAGCs_Gain_byte_1 (0x24) Registers */
+		ret = tda18273_writeregmap(priv, gTDA18273_Reg_Vsync_byte.Address, TDA18273_REG_DATA_LEN(gTDA18273_Reg_Vsync_byte, gTDA18273_Reg_RFAGCs_Gain_byte_1));
+		/* Write RF_Filters_byte_3 (0x2D) Register */
+		ret = tda18273_writeregmap(priv, gTDA18273_Reg_RF_Filters_byte_3.Address, 1);
+		/* Write CP_Current_byte (0x2F) Register */
+		ret = tda18273_writeregmap(priv, gTDA18273_Reg_CP_Current_byte.Address, 1);
+		/* Write Misc_byte (0x38) Register */
+		ret = tda18273_writeregmap(priv, gTDA18273_Reg_Misc_byte.Address, 1);
+	}
+	
+	return 0;
+}
+
+typedef struct _TDA18273_PostDivPrescalerTableDef_
+{
+    unsigned int LO_max;
+    unsigned int LO_min;
+    unsigned char Prescaler;
+    unsigned char PostDiv;
+} TDA18273_PostDivPrescalerTableDef;
+
+/* Table that maps LO vs Prescaler & PostDiv values */
+static TDA18273_PostDivPrescalerTableDef PostDivPrescalerTable[35] =
+{
+    /* PostDiv 1 */
+    {974000, 852250, 7, 1},
+    {852250, 745719, 8, 1},
+    {757556, 662861, 9, 1},
+    {681800, 596575, 10, 1},
+    {619818, 542341, 11, 1},
+    {568167, 497146, 12, 1},
+    {524462, 458904, 13, 1},
+    /* PostDiv 2 */
+    {487000, 426125, 7, 2},
+    {426125, 372859, 8, 2},
+    {378778, 331431, 9, 2},
+    {340900, 298288, 10, 2},
+    {309909, 271170, 11, 2},
+    {284083, 248573, 12, 2},
+    {262231, 229452, 13, 2},
+    /* PostDiv 4 */
+    {243500, 213063, 7, 4},
+    {213063, 186430, 8, 4},
+    {189389, 165715, 9, 4},
+    {170450, 149144, 10, 4},
+    {154955, 135585, 11, 4},
+    {142042, 124286, 12, 4},
+    {131115, 114726, 13, 4},
+    /* PostDiv 8 */
+    {121750, 106531, 7, 8},
+    {106531, 93215, 8, 8},
+    {94694, 82858, 9, 8},
+    {85225, 74572, 10, 8},
+    {77477, 67793, 11, 8},
+    {71021, 62143, 12, 8},
+    {65558, 57363, 13, 8},
+    /* PostDiv 16 */
+    {60875, 53266, 7, 16},
+    {53266, 46607, 8, 16},
+    {47347, 41429, 9, 16},
+    {42613, 37286, 10, 16},
+    {38739, 33896, 11, 16},
+    {35510, 31072, 12, 16},
+    {32779, 28681, 13, 16}
+};
+
+static int tda18273_calculate_postdivandprescaler(unsigned int LO, int growingOrder, unsigned char* PostDiv, unsigned char* Prescaler)
+{
+	int ret = 0;
+	
+	unsigned char index;
+    unsigned char sizeTable = sizeof(PostDivPrescalerTable) / sizeof(TDA18273_PostDivPrescalerTableDef);
+
+    if(growingOrder == 1) {
+        /* Start from LO = 28.681 kHz */
+        for(index=(sizeTable-1); index>=0; index--) {
+            if((LO > PostDivPrescalerTable[index].LO_min) && (LO < PostDivPrescalerTable[index].LO_max)) {
+                /* We are at correct index in the table */
+                break;
+            }
+        }
+    } else {
+        /* Start from LO = 974000 kHz */
+        for(index=0; index<sizeTable; index++) {
+            if((LO > PostDivPrescalerTable[index].LO_min) && (LO < PostDivPrescalerTable[index].LO_max)) {
+                /* We are at correct index in the table */
+                break;
+            }
+        }
+    }
+
+    if((index == -1) || (index == sizeTable)) {
+        ret = -1;
+    } else {
+        /* Write Prescaler */
+        *Prescaler = PostDivPrescalerTable[index].Prescaler;
+
+        /* Decode PostDiv */
+        *PostDiv = PostDivPrescalerTable[index].PostDiv;
+    }
+	
+	return ret;
+}
+
+/* Middle of VCO frequency excursion : VCOmin + (VCOmax - VCOmin)/2 in KHz */
+#define TDA18273_MIDDLE_FVCO_RANGE ((6818000 - 5965750) / 2 + 5965750)
+
+static int tda18273_find_postdivandprescalerwithbettermargin(unsigned int LO, unsigned char* PostDiv, unsigned char* Prescaler)
+{
+	int ret;
+	
+	unsigned char PostDivGrowing;
+	unsigned char PrescalerGrowing;
+	unsigned char PostDivDecreasing = 0;
+	unsigned char PrescalerDecreasing = 0;
+	unsigned int  FCVOGrowing = 0;
+	unsigned int  DistanceFCVOGrowing = 0;
+	unsigned int  FVCODecreasing = 0;
+	unsigned int  DistanceFVCODecreasing = 0;
+	
+	/* Get the 2 possible values for PostDiv & Prescaler to find the one
+	which provides the better margin on LO */
+	ret = tda18273_calculate_postdivandprescaler(LO, 1, &PostDivGrowing, &PrescalerGrowing);
+	if(ret != -1) {
+		/* Calculate corresponding FVCO value in kHz */
+		FCVOGrowing = LO * PrescalerGrowing * PostDivGrowing;
+	}
+	
+	ret = tda18273_calculate_postdivandprescaler(LO, 0, &PostDivDecreasing, &PrescalerDecreasing);
+	if(ret != -1) {
+		/* Calculate corresponding FVCO value in kHz */
+		FVCODecreasing = LO * PrescalerDecreasing * PostDivDecreasing;
+	}
+
+	/* Now take the values that are providing the better margin, the goal is +-2 MHz on LO */
+	/* So take the point that is the nearest of (FVCOmax - FVCOmin)/2 = 6391,875 MHz */
+	if(FCVOGrowing != 0) {
+		if(FCVOGrowing >= TDA18273_MIDDLE_FVCO_RANGE) {
+			DistanceFCVOGrowing = FCVOGrowing - TDA18273_MIDDLE_FVCO_RANGE;
+		} else {
+			DistanceFCVOGrowing = TDA18273_MIDDLE_FVCO_RANGE - FCVOGrowing;
+		}
+	}
+	
+	if(FVCODecreasing != 0) {
+		if(FVCODecreasing >= TDA18273_MIDDLE_FVCO_RANGE) {
+			DistanceFVCODecreasing = FVCODecreasing - TDA18273_MIDDLE_FVCO_RANGE;
+		} else {
+			DistanceFVCODecreasing = TDA18273_MIDDLE_FVCO_RANGE - FVCODecreasing;
+		}
+	}
+	
+	if(FCVOGrowing == 0) {
+		if(FVCODecreasing == 0) {
+			/* No value at all are found */
+			ret = -1;
+		} else {
+			/* No value in growing mode, so take the decreasing ones */
+			*PostDiv = PostDivDecreasing;
+			*Prescaler = PrescalerDecreasing;
+		}
+	} else {
+		if(FVCODecreasing == 0) {
+			/* No value in decreasing mode, so take the growing ones */
+			*PostDiv = PostDivGrowing;
+			*Prescaler = PrescalerGrowing;
+		} else {
+			/* Find the value which are the nearest of the middle of VCO range */
+			if(DistanceFCVOGrowing <= DistanceFVCODecreasing) {
+				*PostDiv = PostDivGrowing;
+				*Prescaler = PrescalerGrowing;
+			} else {
+				*PostDiv = PostDivDecreasing;
+				*Prescaler = PrescalerDecreasing;
+			}
+		}
+	}
+	
+	return ret;
+}
+
+static int tda18273_calculate_nintkint(unsigned int LO, unsigned char PostDiv, unsigned char Prescaler, unsigned int* NInt, unsigned int* KInt)
+{
+	/* Algorithm that calculates N_K */
+    unsigned int FVCO = 0;
+    unsigned int N_K_prog = 0;
+
+    /* Algorithm that calculates N, K corrected */
+    unsigned int Nprime = 0;
+    unsigned int KforceK0_1 = 0;
+    unsigned int K2msb = 0;
+    unsigned int N0 = 0;
+    unsigned int Nm1 = 0;
+
+	/* Calculate N_K_Prog */
+	FVCO = LO * Prescaler * PostDiv;
+	N_K_prog = (FVCO * 128) / 125;
+	
+	/* Calculate N & K corrected values */
+	Nprime = N_K_prog & 0xFF0000;
+	
+	/* Force LSB to 1 */
+	KforceK0_1 = 2*(((N_K_prog - Nprime) << 7) / 2) + 1;
+	
+	/* Check MSB bit around 2 */
+	K2msb = KforceK0_1 >> 21;
+	if(K2msb < 1) {
+		N0 = 1;
+	} else {
+		if (K2msb >= 3) {
+			N0 = 1;
+		} else {
+			N0 = 0;
+		}
+	}
+	
+	if(K2msb < 1) {
+		Nm1 = 1;
+	} else {
+		Nm1 = 0;
+	}
+	
+	/* Calculate N */
+	*NInt = (2 * ((Nprime >> 16) - Nm1) + N0) - 128;
+	
+	/* Calculate K */
+	if(K2msb < 1) {
+		*KInt = KforceK0_1 + (2 << 21);
+	} else {
+		if (K2msb >= 3) {
+			*KInt = KforceK0_1 - (2 << 21);
+		} else {
+			*KInt = KforceK0_1;
+		}
+	}
+	
+	/* Force last 7 bits of K_int to 0x5D, as the IC is doing for spurs optimization */
+	*KInt &= 0xFFFFFF80;
+	*KInt |= 0x5D;
+	
+	return 0;
+}
+
+
+static int tda18273_set_pll(struct dvb_frontend *fe)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	
+	int ret;
+	
+	/* LO wanted = RF wanted + IF in KHz */
+    unsigned int LO = 0;
+
+    /* Algorithm that calculates PostDiv */
+    unsigned char PostDiv = 0; /* absolute value */
+    unsigned char LOPostDiv = 0; /* register value */
+
+    /* Algorithm that calculates Prescaler */
+    unsigned char Prescaler = 0;
+
+    /* Algorithm that calculates N, K */
+    unsigned int N_int = 0;
+    unsigned int K_int = 0;
+    
+	/* Calculate wanted LO = RF + IF in Hz */
+	LO = (priv->pObj->uRF + priv->pObj->uIF) / 1000;
+	
+	/* Calculate the best PostDiv and Prescaler : the ones that provide the best margin */
+	/* in case of fine tuning +-2 MHz */
+	ret = tda18273_find_postdivandprescalerwithbettermargin(LO, &PostDiv, &Prescaler);
+	
+	if(ret != -1) {
+		/* Program the PLL only if valid values are found, in that case err == TM_OK */
+		/* Decode PostDiv */
+		switch(PostDiv)	{
+			case 1:		LOPostDiv = 1;										break;
+			case 2:		LOPostDiv = 2;										break;
+			case 4:		LOPostDiv = 3;										break;
+			case 8:		LOPostDiv = 4;										break;
+			case 16:	LOPostDiv = 5;										break;
+			default:	dprintk(FE_INFO, 1, "%s *PostDiv value is wrong.", __func__);	break;
+		}
+		
+		/* Affect register map without writing into IC */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Main_Post_Divider_byte__LOPostDiv, LOPostDiv, Bus_None);
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Main_Post_Divider_byte__LOPresc, Prescaler, Bus_None);
+		/* Calculate N & K values of the PLL */
+		ret = tda18273_calculate_nintkint(LO, PostDiv, Prescaler, &N_int, &K_int);
+		/* Affect registers map without writing to IC */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Sigma_delta_byte_4__LO_Frac_0, (UInt8)(K_int & 0xFF), Bus_None);
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Sigma_delta_byte_3__LO_Frac_1, (UInt8)((K_int >> 8) & 0xFF), Bus_None);
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Sigma_delta_byte_2__LO_Frac_2, (UInt8)((K_int >> 16) & 0xFF), Bus_None);
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Sigma_delta_byte_1__LO_Int, (UInt8)(N_int & 0xFF), Bus_None);
+		/* Force manual selection mode : 0x3 at @0x56 */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Sigma_delta_byte_5__N_K_correct_manual, 0x01, Bus_None);
+		/* Force manual selection mode : 0x3 at @0x56 */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Sigma_delta_byte_5__LO_Calc_Disable, 0x01, Bus_None);
+		/* Write bytes Main_Post_Divider_byte (0x51) to Sigma_delta_byte_5 (0x56) */
+		ret = tda18273_writeregmap(priv, gTDA18273_Reg_Main_Post_Divider_byte.Address, TDA18273_REG_DATA_LEN(gTDA18273_Reg_Main_Post_Divider_byte, gTDA18273_Reg_Sigma_delta_byte_5));
+	}
+		
+	return 0;
+}
+
+static int tda18273_override_icp(struct dvb_frontend *fe, unsigned int uRF)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	
+	int ret;
+	unsigned int	uIF = 0;
+    unsigned char	ProgIF = 0;
+    unsigned char	LOPostdiv = 0;
+    unsigned char	LOPrescaler = 0;
+    unsigned int	FVCO = 0;
+    unsigned char	uICPBypass = 0;
+    unsigned char	ICP = 0;
+    unsigned char	uPrevICP = 0;
+    
+	/* Read PostDiv et Prescaler */
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_Main_Post_Divider_byte, &LOPostdiv, Bus_RW);
+	/* PostDiv */
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_Main_Post_Divider_byte__LOPostDiv, &LOPostdiv, Bus_NoRead);
+	/* Prescaler */
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_Main_Post_Divider_byte__LOPresc, &LOPrescaler, Bus_NoRead);
+	/* IF */
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_IF_Frequency_byte__IF_Freq, &ProgIF, Bus_NoRead);
+	/* Decode IF */
+	uIF = ProgIF*50000;
+	/* Decode PostDiv */
+	switch(LOPostdiv) {
+		case 1:		LOPostdiv = 1;		break;
+		case 2:		LOPostdiv = 2;		break;
+		case 3:		LOPostdiv = 4;		break;
+		case 4:		LOPostdiv = 8;		break;
+		case 5:		LOPostdiv = 16;		break;
+		default:	ret = -1;			break;
+	}
+	
+	if(ret != -1) {
+		/* Calculate FVCO in MHz*/
+		FVCO = LOPostdiv * LOPrescaler * ((uRF + uIF) / 1000000);
+		/* Set correct ICP */
+		if(FVCO < 6352) {
+			/* Set ICP to 01 (= 150)*/
+			ICP = 0x01;
+		} else if(FVCO < 6592) {
+			/* Set ICP to 10 (= 300)*/
+			ICP = 0x02;
+		} else {
+			/* Set ICP to 00 (= 500)*/
+			ICP = 0x00;
+		}
+		/* Get ICP_bypass bit */
+		ret = tda18273_readregs(priv, &gTDA18273_Reg_Charge_pump_byte__ICP_Bypass, &uICPBypass, Bus_RW);
+		/* Get ICP */
+		ret = tda18273_readregs(priv, &gTDA18273_Reg_Charge_pump_byte__ICP, &uPrevICP, Bus_NoRead);
+
+		if(uICPBypass == 0x0 || uPrevICP != ICP) {
+			/* Set ICP_bypass bit */
+			ret = tda18273_writeregs(priv, &gTDA18273_Reg_Charge_pump_byte__ICP_Bypass, 0x01, Bus_None);
+			/* Set ICP */
+			ret = tda18273_writeregs(priv, &gTDA18273_Reg_Charge_pump_byte__ICP, ICP, Bus_None);
+			/* Write Charge_pump_byte register */
+			ret = tda18273_writeregmap(priv, gTDA18273_Reg_Charge_pump_byte.Address, 1);
+		}
+	}
+    
+	return ret;
+}
+
+static int tda18273_override_digitalclock(struct dvb_frontend *fe, unsigned int uRF)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	
+	int ret;
+	unsigned char uDigClock = 0;
+    unsigned char uPrevDigClock = 0;
+    unsigned char uProgIF = 0;
+    
+	/* LO < 55 MHz then Digital Clock set to 16 MHz else subLO */
+	/* Read Current IF */
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_IF_Frequency_byte__IF_Freq, &uProgIF, Bus_NoWrite);
+	/* Read Current Digital Clock */
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_Reference_Byte__Digital_Clock_Mode, &uPrevDigClock, Bus_NoWrite);
+	/* LO = RF + IF */
+	if((uRF + (uProgIF*50000)) < 55000000) {
+		uDigClock = 0; /* '00' = 16 MHz */
+	} else {
+		uDigClock = 3; /* '11' = subLO */
+	}
+	
+	if(uPrevDigClock != uDigClock) {
+		/* Set Digital Clock bits */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_Reference_Byte__Digital_Clock_Mode, uDigClock, Bus_NoRead);
+	}
+    
+    return 0;
+}
+
+static int tda18273_set_rffreq(struct dvb_frontend *fe)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	
+	int ret;
+	unsigned int uRF=priv->pObj->uProgRF;
+	unsigned int uRFLocal=0;
+	
+	/* Set the proper settings depending on the standard & RF frequency */
+	/****************************************************************/
+	/* AGC TOP Settings                                             */
+	/****************************************************************/
+	/* Set AGC3 RF AGC Top */
+	if(uRF < priv->pObj->pStandard->Freq_Start_LTE) {
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_AGC_byte__RFAGC_Top, priv->pObj->pStandard->AGC3_TOP_I2C_Low_Band, Bus_RW);
+	} else {
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_AGC_byte__RFAGC_Top, priv->pObj->pStandard->AGC3_TOP_I2C_High_Band, Bus_RW);
+	}
+	/* Set AGC3 Adapt TOP */
+	if(uRF < priv->pObj->pStandard->Freq_Start_LTE) {
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_AGC_byte__RFAGC_Adapt_TOP, priv->pObj->pStandard->AGC3_Adapt_TOP_Low_Band, Bus_NoRead);
+	} else {
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_AGC_byte__RFAGC_Adapt_TOP, priv->pObj->pStandard->AGC3_Adapt_TOP_High_Band, Bus_NoRead);
+	}
+	/* Set IRQ_clear */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_IRQ_clear, TDA18273_IRQ_Global|TDA18273_IRQ_SetRF, Bus_NoRead);
+	/* Set RF */
+	uRFLocal = (uRF + 500) / 1000;
+	
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Frequency_byte_1__RF_Freq_1, (unsigned char)((uRFLocal & 0x00FF0000) >> 16), Bus_None);
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Frequency_byte_2__RF_Freq_2, (unsigned char)((uRFLocal & 0x0000FF00) >> 8), Bus_None);
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Frequency_byte_3__RF_Freq_3, (unsigned char)(uRFLocal & 0x000000FF), Bus_None);
+	ret = tda18273_writeregmap(priv, gTDA18273_Reg_RF_Frequency_byte_1.Address, TDA18273_REG_DATA_LEN(gTDA18273_Reg_RF_Frequency_byte_1, gTDA18273_Reg_RF_Frequency_byte_3));
+	/* Set state machine and Launch it */
+	ret = tda18273_set_msm(fe, TDA18273_MSM_SetRF, 0x1);
+	/* Wait for IRQ to trigger */
+	//ret = iTDA18273_WaitIRQ(pObj, 50, 5, TDA18273_IRQ_SetRF);
+	mdelay(50);
+	
+	/* Override the calculated PLL to get the best margin in case fine tuning is used */
+	/* which means set the PLL in manual mode that provides the best occurence of LO tuning (+-2 MHz) */
+	/* without touching PostDiv and Prescaler */
+	ret = tda18273_set_pll(fe);
+	/* Override ICP */
+	ret = tda18273_override_icp(fe, priv->pObj->uProgRF);
+	/* Override Digital Clock */
+	if(ret != -1) {
+		ret = tda18273_override_digitalclock(fe, priv->pObj->uProgRF);
+	}
+
+	return 0;
+}
+
+static int tda18273_set_rf(struct dvb_frontend *fe, unsigned int uRF)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+
+	priv->pObj->uRF = uRF;
+	priv->pObj->uProgRF = priv->pObj->uRF + priv->pObj->pStandard->CF_Offset;
+
+	tda18273_llpwr_state(fe, TDA18273_PowerNormalMode);
+	tda18273_lastpass_lnapwr(fe);
+	tda18273_check_calcpll(fe);
+	tda18273_override_bandsplit(fe);
+	tda18273_set_rffreq(fe);
+	
+	return 0;
+}
+
+static int tda18273_hw_reset(struct dvb_frontend *fe)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	int ret;
+	
+	tda18273_pwr_state(fe, tmPowerStandby);
+	tda18273_llpwr_state(fe, TDA18273_PowerNormalMode);
+	
+	/* Set digital clock mode to 16 Mhz before resetting the IC to avoid unclocking the digital part */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_Reference_Byte__Digital_Clock_Mode, 0x00, Bus_RW);
+	/* Perform a SW reset to reset the digital calibrations & the IC machine state */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_Down_byte_3, 0x03, Bus_RW);
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_Power_Down_byte_3, 0x00, Bus_NoRead);
+	/* Set power state on */
+	//ret = tda18273_llpwr_state(fe, TDA18273_PowerNormalMode);
+
+#if 0	
+	/* Only if tuner has a XTAL */
+	if(1) {		//if (priv->bBufferMode == False)
+		/* Reset XTALCAL_End bit */
+		/* Set IRQ_clear */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_IRQ_clear, TDA18273_IRQ_Global|TDA18273_IRQ_XtalCal|TDA18273_IRQ_HwInit|TDA18273_IRQ_IrCal, Bus_NoRead);
+		/* Launch XTALCAL */
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_MSM_byte_2__XtalCal_Launch, 0x01, Bus_NoRead);
+		ret = tda18273_writeregs(priv, &gTDA18273_Reg_MSM_byte_2__XtalCal_Launch, 0x00, Bus_None);
+		/* Wait XTALCAL_End bit */
+		//ret = iTDA18273_WaitXtalCal_End(priv, 100, 10);
+	}
+#endif
+
+	/* Read all bytes */
+	ret = tda18273_readregmap(priv, 0x00, TDA18273_REG_MAP_NB_BYTES);
+	/* Check if Calc_PLL algorithm is in automatic mode */
+	ret = tda18273_check_calcpll(fe);
+	/* Up_Step_Ovld: POR = 1 -> 0 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_Vsync_Mgt_byte__Up_Step_Ovld, 0x00, Bus_NoRead);
+	/* PLD_CC_Enable: POR = 1 -> 0 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RFAGCs_Gain_byte_1__PLD_CC_Enable, 0x00, Bus_NoRead);
+	/* RFCAL_Offset0 : 0 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Cal_byte_1__RFCAL_Offset_Cprog0, 0x00, Bus_None);
+	/* RFCAL_Offset1 : 0 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Cal_byte_1__RFCAL_Offset_Cprog1, 0x00, Bus_None);
+	/* RFCAL_Offset2 : 0 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Cal_byte_1__RFCAL_Offset_Cprog2, 0x00, Bus_None);
+	/* RFCAL_Offset3 : 0 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Cal_byte_1__RFCAL_Offset_Cprog3, 0x00, Bus_None);
+	/* RFCAL_Offset4 : 3 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Cal_byte_2__RFCAL_Offset_Cprog4, 0x03, Bus_None);
+	/* RFCAL_Offset5 : 0 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Cal_byte_2__RFCAL_Offset_Cprog5, 0x00, Bus_None);
+	/* RFCAL_Offset6 : 3 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Cal_byte_2__RFCAL_Offset_Cprog6, 0x03, Bus_None);
+	/* RFCAL_Offset7 : 3 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Cal_byte_2__RFCAL_Offset_Cprog7, 0x03, Bus_None);
+	/* RFCAL_Offset8 : 1 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RF_Cal_byte_3__RFCAL_Offset_Cprog8, 0x01, Bus_None);
+	/* Write RF_Cal_byte_1 (0x27) to RF_Cal_byte_3 (0x29) Registers */
+	ret = tda18273_writeregmap(priv, gTDA18273_Reg_RF_Cal_byte_1.Address, TDA18273_REG_DATA_LEN(gTDA18273_Reg_RF_Cal_byte_1, gTDA18273_Reg_RF_Cal_byte_3));
+	/* PLD_Temp_Enable: POR = 1 -> 0 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_RFAGCs_Gain_byte_1__PLD_Temp_Enable, 0x00, Bus_NoRead);
+	/* Power Down Vsync Management: POR = 0 -> 1 */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_Vsync_Mgt_byte__PD_Vsync_Mgt, 0x01, Bus_NoRead);
+	/* Set IRQ_clear */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_IRQ_clear, TDA18273_IRQ_Global|TDA18273_IRQ_HwInit|TDA18273_IRQ_IrCal, Bus_NoRead);
+	/* Set state machine (all CALs except IRCAL) and Launch it */
+	ret = tda18273_set_msm(fe, TDA18273_MSM_HwInit, 0x1);
+	/* Inform that init phase has started */
+	/* State reached after 500 ms max */
+	//ret = iTDA18273_WaitIRQ(priv, 500, 10, TDA18273_IRQ_HwInit);
+	mdelay(500);
+	/* Set IRQ_clear */
+	ret = tda18273_writeregs(priv, &gTDA18273_Reg_IRQ_clear, TDA18273_IRQ_Global|TDA18273_IRQ_HwInit|TDA18273_IRQ_IrCal, Bus_NoRead);
+	/* Launch IRCALs after all other CALs are finished */
+	ret = tda18273_set_msm(fe, TDA18273_MSM_IrCal, 0x1);
+	/* State reached after 500 ms max, 10 ms step due to CAL ~ 30ms */
+	//ret = iTDA18273_WaitIRQ(priv, 500, 10, TDA18273_IRQ_IrCal);
+	mdelay(500);
+
+	tda18273_llpwr_state(fe, TDA18273_PowerStandbyWithXtalOn);
+
+	return 0;
+}
+
+static int tda18273_hw_init(struct dvb_frontend *fe)
+{
+	tda18273_pwr_state(fe, tmPowerOn);
+	
+	tda18273_hw_reset(fe);
+
+	return 0;
+}
+
+static int tda18273_init(struct dvb_frontend *fe)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+	int ret;
+	unsigned char val=0;
+	unsigned short id=0;
+	unsigned char major;
+	unsigned char minor;
+	
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_ID_byte_1__Ident_1, &val, Bus_RW);
+	id = val << 8;
+	ret = tda18273_readregs(priv, &gTDA18273_Reg_ID_byte_2__Ident_2, &val, Bus_RW);
+	id |= val;
+	
+	if(ret == TDA_RESULT_SUCCESS) {
+		if(id == TDA_DEVICE_TYPE) {
+			ret = tda18273_readregs(priv, &gTDA18273_Reg_ID_byte_3__Major_rev, &major, Bus_RW);
+			ret = tda18273_readregs(priv, &gTDA18273_Reg_ID_byte_3__Minor_rev, &minor, Bus_RW);
+			dprintk(FE_INFO, 1, "id:%d / ver:%d.%d", id, major, minor);
+		} else {
+			return -1;
+		}
+	} else {
+		return -1;
+	}
+	
+	priv->pObj = &gTDA18273Instance;
+
+	tda18273_hw_init(fe);
+
+	return 0;
+}
+
+static int tda18273_get_status(struct dvb_frontend *fe, u32 *status)
+{
+	struct tda18273_state *priv = (struct tda18273_state*)fe->tuner_priv;
+	unsigned short lock_status = 0;
+	int ret = 0;
+
+	ret = tda18273_get_lock_status(priv, &lock_status);	
+	if (ret)
+		goto err;
+err:
+	dprintk(FE_DEBUG, 1, "ret=%d", ret);
+	return ret;
+}
+
+static int tda18273_set_params(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct tda18273_state *priv = fe->tuner_priv;
+	u32 delsys = c->delivery_system;
+	u32 bw = c->bandwidth_hz;
+	u32 freq = c->frequency;
+	unsigned short lock = 0;
+	int ret;
+
+	BUG_ON(!priv);
+
+	dprintk(FE_DEBUG, 1, "freq=%d, bw=%d", freq, bw);
+
+	switch (delsys) {
+	case SYS_ATSC:
+		tda18273_set_standardmode(fe, TDA18273_ATSC_6MHz);		
+		break;
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		switch (bw) {
+		case 1700000:
+			tda18273_set_standardmode(fe, TDA18273_DVBT_1_7MHz);
+			break;
+		case 6000000:
+			tda18273_set_standardmode(fe, TDA18273_DVBT_6MHz);
+			break;
+		case 7000000:
+			tda18273_set_standardmode(fe, TDA18273_DVBT_7MHz);
+			break;
+		case 8000000:
+			tda18273_set_standardmode(fe, TDA18273_DVBT_8MHz);
+			break;
+		case 10000000:
+			tda18273_set_standardmode(fe, TDA18273_DVBT_10MHz);
+			break;
+		default:
+			ret = -EINVAL;
+			goto err;
+		}
+		break;
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_C:
+		tda18273_set_standardmode(fe, TDA18273_QAM_8MHz);		
+		break;
+	case SYS_DVBC_ANNEX_B:
+		tda18273_set_standardmode(fe, TDA18273_QAM_6MHz);
+		break;
+	}
+
+	ret = tda18273_pwr_state(fe, tmPowerOn);	
+	if (ret)
+		goto err;
+
+	dprintk(FE_DEBUG, 1, "if_freq=%d", priv->pObj->pStandard->IF);
+
+	ret = tda18273_set_rf(fe, freq + priv->pObj->pStandard->IF);
+	if (ret)
+		goto err;
+
+	msleep(100);
+	tda18273_get_lock_status(priv, &lock);
+
+	tda18273_regall_debug(priv);
+
+	dprintk(FE_INFO, 1, "Lock status = %d", lock);
+	if (lock) {
+		priv->freq_hz = freq;
+		priv->if_freq = priv->pObj->pStandard->IF;
+		priv->bandwidth = bw;	  
+	}
+err:
+	dprintk(FE_DEBUG, 1, "ret=%d", ret);
+	return ret;
+}
+
+static int tda18273_get_freq(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+
+	*frequency = priv->freq_hz;
+	return 0;
+}
+
+static int tda18273_get_if_freq(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+
+	*frequency = priv->if_freq;
+	return 0;
+}
+
+static int tda18273_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+
+	*bandwidth = priv->bandwidth;
+	return 0;
+}
+
+static void tda18273_release(struct dvb_frontend *fe)
+{
+	struct tda18273_state *priv = fe->tuner_priv;
+
+	BUG_ON(!priv);
+
+	if(priv->power_state != tmPowerOff) {
+		tda18273_pwr_state(fe, tmPowerStandby);
+	}
+	
+	fe->tuner_priv = NULL;
+	kfree(priv);
+}
+
+static struct dvb_tuner_ops tda18273_ops = {
+	.info = {
+		.name		= "TDA18273 Silicon Tuner",
+		.frequency_min  =  42000000,
+		.frequency_max  = 870000000,
+		.frequency_step	= 50000,
+	},
+	.init			= tda18273_init,
+//	.sleep			= tda18273_sleep,
+	.get_status		= tda18273_get_status,
+	.set_params		= tda18273_set_params,
+	.get_frequency		= tda18273_get_freq,
+	.get_bandwidth		= tda18273_get_bandwidth,
+	.get_if_frequency	= tda18273_get_if_freq,
+	.release		= tda18273_release
+};
+
+struct dvb_frontend *tda18273_attach(struct dvb_frontend *fe,
+				     struct i2c_adapter *i2c,
+				     const u8 i2c_addr)
+{
+	struct tda18273_state *tda18273;
+	int ret;
+
+	BUG_ON(!i2c);	
+
+	tda18273 = kzalloc(sizeof (struct tda18273_state), GFP_KERNEL);
+	if (!tda18273)
+		goto err;
+
+	tda18273->i2c		= i2c;
+	tda18273->fe		= fe;
+	tda18273->i2c_addr	= i2c_addr;
+	tda18273->power_state = tmPowerOff;
+
+	fe->tuner_priv		= tda18273;
+	fe->ops.tuner_ops	= tda18273_ops;
+
+	ret = tda18273_init(fe);
+	 if (ret) {
+		dprintk(FE_ERROR, 1, "Error Initializing!");
+		goto err;
+	}
+
+	dprintk(FE_DEBUG, 1, "Done");
+	return tda18273->fe;
+err:
+	kfree(tda18273);
+	return NULL;
+}
+EXPORT_SYMBOL(tda18273_attach);
+
+MODULE_AUTHOR("Manu Abraham");
+MODULE_DESCRIPTION("TDA18273 Silicon tuner");
+MODULE_LICENSE("GPL");
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/tda18273.h" "b/drivers/media/tuners/tda18273.h"
--- "a/drivers/media/tuners/tda18273.h"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/tuners/tda18273.h"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,38 @@
+/*
+	tda18273.h - header for the NXP TDA18273 silicon tuner
+	Copyright (C) 2014 CrazyCat <crazycat69@narod.ru>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __TDA18273_H
+#define __TDA18273_H
+
+#if IS_ENABLED(CONFIG_MEDIA_TUNER_TDA18273)
+extern struct dvb_frontend *tda18273_attach(struct dvb_frontend *fe,
+					    struct i2c_adapter *i2c,
+					    const u8 i2c_addr);
+
+#else
+static inline struct dvb_frontend *tda18273_attach(struct dvb_frontend *fe,
+						   struct i2c_adapter *i2c,
+						   const u8 i2c_addr)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* __TDA18273_H */
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/tda18273_priv.h" "b/drivers/media/tuners/tda18273_priv.h"
--- "a/drivers/media/tuners/tda18273_priv.h"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/tuners/tda18273_priv.h"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,1427 @@
+/*
+	tda18273-priv.h - private header for the NXP TDA18273 silicon tuner
+	Copyright (C) 2014 CrazyCat <crazycat69@narod.ru>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef __TDA18273_PRIV
+#define __TDA18273_PRIV
+
+#define TDA18273_TUNER_RESET		0
+
+#define TDA_FREQ_LOW_BAND		1
+#define TDA_FREQ_MID_BAND		2
+#define TDA_FREQ_HIGH_BAND		4
+
+#define TDA_AGC_115dBuV			1
+#define TDA_AGC_112dBuV			2
+#define TDA_AGC_109dBuV			3
+#define TDA_AGC_106dBuV			4
+#define TDA_AGC_103dBuV			5
+#define TDA_AGC_EXTERNAL		6
+#define TDA_AGC_DISABLE			7
+
+#define TDA_PLL_CP_50uA			6
+#define TDA_PLL_CP_125uA		7
+#define TDA_PLL_CP_250uA		0x0e
+#define TDA_PLL_CP_650uA		0x0f
+
+#define TDA_PLLref_DIVIDER_64		3
+#define TDA_PLLref_DIVIDER_24		2
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef unsigned char		UInt8;
+typedef unsigned int		UInt32;
+typedef int			Int32;
+
+
+/* Result codes */
+#define TDA_RESULT_SUCCESS		0
+#define TDA_RESULT_RESET_FAILURE	1
+#define TDA_RESULT_I2C_WRITE_FAILURE	2
+#define TDA_RESULT_I2C_READ_FAILURE	3
+#define TDA_RESULT_OUT_OF_RANGE		5
+
+
+/* Product id */
+#define TDA_DEVICE_TYPE		18273
+
+/* Register Bit-Field Definition */
+typedef struct _TDA18273_BitField_t {
+	UInt8 Address;
+	UInt8 PositionInBits;
+	UInt8 WidthInBits;
+	UInt8 Attributes;
+} TDA18273_BitField_t, *pTDA18273_BitField_t;
+
+/* Bus Access */
+typedef enum _tmbslFrontEndBusAccess_t {
+    Bus_RW = 0x00,						/* RW Bus access */
+    Bus_NoRead = 0x01,					/* No Read Bus access */
+    Bus_NoWrite = 0x02,					/* No Write Bus access */
+    Bus_None = Bus_NoRead|Bus_NoWrite,	/* No Bus access. Update RegMap only */
+    Bus_Max
+} tmbslFrontEndBusAccess_t;
+
+typedef enum tmPowerState
+{
+    tmPowerOn = 0,                      /* Device powered on      (D0 state) */
+    tmPowerStandby,                     /* Device power standby   (D1 state) */
+    tmPowerSuspend,                     /* Device power suspended (D2 state) */
+    tmPowerOff,                         /* Device powered off     (D3 state) */
+    tmPowerMax                          /* Device power max */
+}   tmPowerState_t, *ptmPowerState_t;
+
+typedef enum _TDA18273PowerState_t {
+    TDA18273_PowerNormalMode = 0,                                 /* Device normal mode */
+    TDA18273_PowerStandbyWithXtalOn,                              /* Device standby mode with Xtal Output */
+    TDA18273_PowerStandby,                                        /* Device standby mode */
+    TDA18273_PowerMax
+} TDA18273PowerState_t, *pTDA18273PowerState_t;
+
+typedef enum _TDA18273StandardMode_t {
+    TDA18273_StandardMode_Unknown = 0,                  /* Unknown standard */
+    TDA18273_QAM_6MHz,                                  /* Digital TV QAM 6MHz */
+    TDA18273_QAM_8MHz,                                  /* Digital TV QAM 8MHz */
+    TDA18273_ATSC_6MHz,                                 /* Digital TV ATSC 6MHz */
+    TDA18273_ISDBT_6MHz,                                /* Digital TV ISDBT 6MHz */
+    TDA18273_DVBT_1_7MHz,                               /* Digital TV DVB-T/T2 6MHz */
+    TDA18273_DVBT_6MHz,                                 /* Digital TV DVB-T/T2 6MHz */
+    TDA18273_DVBT_7MHz,                                 /* Digital TV DVB-T/T2 7MHz */
+    TDA18273_DVBT_8MHz,                                 /* Digital TV DVB-T/T2 8MHz */
+    TDA18273_DVBT_10MHz,                                /* Digital TV DVB-T/T2 10MHz */     
+    TDA18273_DMBT_8MHz,                                 /* Digital TV DMB-T 8MHz */
+    TDA18273_FM_Radio,                                  /* Analog FM Radio */
+    TDA18273_ANLG_MN,                                   /* Analog TV M/N */
+    TDA18273_ANLG_B,                                    /* Analog TV B */
+    TDA18273_ANLG_GH,                                   /* Analog TV G/H */
+    TDA18273_ANLG_I,                                    /* Analog TV I */
+    TDA18273_ANLG_DK,                                   /* Analog TV D/K */
+    TDA18273_ANLG_L,                                    /* Analog TV L */
+    TDA18273_ANLG_LL,                                   /* Analog TV L' */
+    TDA18273_Scanning,                                  /* Analog Preset Blind Scanning */
+    TDA18273_ScanXpress,                                /* ScanXpress */
+    TDA18273_StandardMode_Max
+} TDA18273StandardMode_t, *pTDA18273StandardMode_t;
+
+/* TDA18273 Driver State Machine */
+typedef enum _TDA18273HwState_t {
+    TDA18273_HwState_Unknown = 0,   /* Hw State Unknown */
+    TDA18273_HwState_InitNotDone,   /* Hw Init Not Done */
+    TDA18273_HwState_InitPending,   /* Hw Init Pending */
+    TDA18273_HwState_InitDone,      /* Hw Init Done */
+    TDA18273_HwState_SetStdDone,    /* Set Standard Done */
+    TDA18273_HwState_SetRFDone,     /* Set RF Done */
+    TDA18273_HwState_SetFineRFDone, /* Set Fine RF Done */
+    TDA18273_HwState_Max
+} TDA18273HwState_t, *pTDA18273HwState_t;
+
+typedef enum _TDA18273HwStateCaller_t {
+    TDA18273_HwStateCaller_Unknown = 0, /* Caller Unknown */
+    TDA18273_HwStateCaller_SetPower,    /* Caller SetPowerState */
+    TDA18273_HwStateCaller_HwInit,      /* Caller HwInit */
+    TDA18273_HwStateCaller_SetStd,      /* Caller SetStandardMode */
+    TDA18273_HwStateCaller_SetRF,       /* Caller SetRF */
+    TDA18273_HwStateCaller_SetFineRF,   /* Caller SetFineRF */
+    TDA18273_HwStateCaller_GetRSSI,     /* Caller GetRSSI */
+    TDA18273_HwStateCaller_SetRawRF,    /* Caller SetRawRF */
+    TDA18273_HwStateCaller_Max
+} TDA18273HwStateCaller_t, *pTDA18273HwStateCaller_t;
+
+/* TDA18273 specific powerstate bits: */
+typedef enum _TDA18273SM_Reg_t {
+    TDA18273_SM_NONE    = 0x00, /* No SM bit to set */
+    TDA18273_SM_XT      = 0x01, /* SM_XT bit to set */
+    TDA18273_SM         = 0x02  /* SM bit to set */
+} TDA18273SM_Reg_t, *pTDA18273SM_Reg_t;
+
+/* TDA18273 specific MSM: */
+typedef enum _TDA18273MSM_t {
+    TDA18273_MSM_Calc_PLL       = 0x01, /* Calc_PLL bit */
+    TDA18273_MSM_RC_Cal         = 0x02, /* RC_Cal bit */
+    TDA18273_MSM_IR_CAL_Wanted  = 0x04, /* IR_CAL_Wanted bit */
+    TDA18273_MSM_IR_Cal_Image   = 0x08, /* IR_Cal_Image bit */
+    TDA18273_MSM_IR_CAL_Loop    = 0x10, /* IR_CAL_Loop bit */
+    TDA18273_MSM_RF_CAL         = 0x20, /* RF_CAL bit */
+    TDA18273_MSM_RF_CAL_AV      = 0x40, /* RF_CAL_AV bit */
+    TDA18273_MSM_RSSI_Meas      = 0x80, /* RSSI_Meas bit */
+    /* Performs all CALs except IR_CAL */
+    TDA18273_MSM_HwInit         = TDA18273_MSM_Calc_PLL\
+                                    |TDA18273_MSM_RC_Cal\
+                                    |TDA18273_MSM_RF_CAL,
+    /* Performs all IR_CAL */
+    TDA18273_MSM_IrCal          = TDA18273_MSM_IR_Cal_Image\
+                                    |TDA18273_MSM_IR_CAL_Loop,
+    TDA18273_MSM_SetRF          = TDA18273_MSM_Calc_PLL\
+                                    |TDA18273_MSM_RF_CAL_AV,
+    TDA18273_MSM_GetPowerLevel  = TDA18273_MSM_RSSI_Meas
+} TDA18273MSM_t, *pTDA18273MSM_t;
+
+/* TDA18273 specific IRQ clear: */
+typedef enum _TDA18273IRQ_t {
+    TDA18273_IRQ_MSM_RCCal      = 0x01, /* MSM_RCCal bit */
+    TDA18273_IRQ_MSM_IRCAL      = 0x02, /* MSM_IRCAL bit */
+    TDA18273_IRQ_MSM_RFCal      = 0x04, /* MSM_RFCal bit */
+    TDA18273_IRQ_MSM_LOCalc     = 0x08, /* MSM_LOCalc bit */
+    TDA18273_IRQ_MSM_RSSI       = 0x10, /* MSM_RSSI bit */
+    TDA18273_IRQ_XtalCal        = 0x20, /* XtalCal bit */
+    TDA18273_IRQ_Global         = 0x80, /* IRQ_status bit */
+    TDA18273_IRQ_HwInit         = TDA18273_IRQ_MSM_RCCal\
+                                    |TDA18273_IRQ_MSM_RFCal\
+                                    |TDA18273_IRQ_MSM_LOCalc\
+                                    |TDA18273_IRQ_MSM_RSSI,
+    TDA18273_IRQ_IrCal          = TDA18273_IRQ_MSM_IRCAL\
+                                    |TDA18273_IRQ_MSM_LOCalc\
+                                    |TDA18273_IRQ_MSM_RSSI,
+    TDA18273_IRQ_SetRF          = TDA18273_IRQ_MSM_RFCal\
+                                    |TDA18273_IRQ_MSM_LOCalc,
+    TDA18273_IRQ_GetPowerLevel  = TDA18273_IRQ_MSM_RSSI
+} TDA18273IRQ_t, *pTDA18273IRQ_t;
+
+/* TDA18273 Standard settings: */
+typedef enum _TDA18273LPF_t {
+    TDA18273_LPF_6MHz = 0,  /* 6MHz LPFc */
+    TDA18273_LPF_7MHz,      /* 7MHz LPFc */
+    TDA18273_LPF_8MHz,      /* 8MHz LPFc */
+    TDA18273_LPF_9MHz,      /* 9MHz LPFc */
+    TDA18273_LPF_1_5MHz,    /* 1.5MHz LPFc */
+    TDA18273_LPF_Max
+} TDA18273LPF_t, *pTDA18273LPF_t;
+
+typedef enum _TDA18273LPFOffset_t {
+    TDA18273_LPFOffset_0pc = 0,     /* LPFc 0% */
+    TDA18273_LPFOffset_min_4pc,     /* LPFc -4% */
+    TDA18273_LPFOffset_min_8pc,     /* LPFc -8% */
+    TDA18273_LPFOffset_min_12pc,    /* LPFc -12% */
+    TDA18273_LPFOffset_Max
+} TDA18273LPFOffset_t, *pTDA18273LPFOffset_t;
+
+typedef enum TDA18273DC_Notch_IF_PPF_t {
+    TDA18273_DC_Notch_IF_PPF_Disabled = 0,  /* IF Notch Disabled */
+    TDA18273_DC_Notch_IF_PPF_Enabled,       /* IF Notch Enabled */
+    TDA18273_DC_Notch_IF_PPF_Max
+} TDA18273DC_Notch_IF_PPF_t, *pTDA18273DC_Notch_IF_PPF_t;
+
+typedef enum _TDA18273IF_HPF_t {
+    TDA18273_IF_HPF_Disabled = 0,   /* IF HPF disabled */
+    TDA18273_IF_HPF_0_4MHz,         /* IF HPF 0.4MHz */
+    TDA18273_IF_HPF_0_85MHz,        /* IF HPF 0.85MHz */
+    TDA18273_IF_HPF_1MHz,           /* IF HPF 1MHz */
+    TDA18273_IF_HPF_1_5MHz,         /* IF HPF 1.5MHz */
+    TDA18273_IF_HPF_Max
+} TDA18273IF_HPF_t, *pTDA18273IF_HPF_t;
+
+typedef enum _TDA18273IF_Notch_t {
+    TDA18273_IF_Notch_Disabled = 0, /* IF Notch Disabled */
+    TDA18273_IF_Notch_Enabled,      /* IF Notch Enabled */
+    TDA18273_IF_Notch_Max
+} TDA18273IF_Notch_t, *pTDA18273IF_Notch_t;
+
+typedef enum _TDA18273IFnotchToRSSI_t {
+    TDA18273_IFnotchToRSSI_Disabled = 0,    /* IFnotchToRSSI Disabled */
+    TDA18273_IFnotchToRSSI_Enabled,         /* IFnotchToRSSI Enabled */
+    TDA18273_IFnotchToRSSI_Max
+} TDA18273IFnotchToRSSI_t, *pTDA18273IFnotchToRSSI_t;
+
+typedef enum _TDA18273AGC1_TOP_I2C_DN_UP_t {
+    TDA18273_AGC1_TOP_I2C_DN_UP_d88_u82dBuV = 0,    /* AGC1 TOP I2C DN/UP down 88 up 82 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d90_u84dBuV,        /* AGC1 TOP I2C DN/UP down 90 up 84 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89wdBuV,       /* AGC1 TOP I2C DN/UP down 95 up 89 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d93_u87dBuV,        /* AGC1 TOP I2C DN/UP down 93 up 87 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,        /* AGC1 TOP I2C DN/UP down 95 up 89 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d99_u84dBuV,        /* AGC1 TOP I2C DN/UP down 99 up 84 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d100_u82dBuV,       /* AGC1 TOP I2C DN/UP down 100 up 82 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d100_u94bisdBuV,    /* AGC1 TOP I2C DN/UP down 100 up 94 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d102_u82dBuV,       /* AGC1 TOP I2C DN/UP down 102 up 82 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d102_u84dBuV,       /* AGC1 TOP I2C DN/UP down 102 up 84 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d100_u94dBuV,       /* AGC1 TOP I2C DN/UP down 100 up 94 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_Max
+} TDA18273AGC1_TOP_I2C_DN_UP_t, *pTDA18273AGC1_TOP_I2C_DN_UP_t;
+
+typedef enum _TDA18273AGC1_Adapt_TOP_DN_UP_t {
+    TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step = 0,   /* AGC1 Adapt TOP DN/UP 0 Step */
+    TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,       /* AGC1 Adapt TOP DN/UP 1 Step */
+    TDA18273_AGC1_Adapt_TOP_DN_UP_2_Step,       /* AGC1 Adapt TOP DN/UP 2 Step */
+    TDA18273_AGC1_Adapt_TOP_DN_UP_3_Step,       /* AGC1 Adapt TOP DN/UP 3 Step */
+    TDA18273_AGC1_Adapt_TOP_DN_UP_Max
+} TDA18273AGC1_Adapt_TOP_DN_UP_t, *pTDA18273AGC1_Adapt_TOP_DN_UP_t;
+
+typedef enum _TDA18273AGC1_Mode_t {
+    TDA18273_AGC1_Mode_No_Mode = 0,         /* AGC1 Mode */
+    TDA18273_AGC1_Mode_TOP_ADAPT,           /* AGC1 Mode: TOP ADAPT */
+    TDA18273_AGC1_Mode_LNA_ADAPT,           /* AGC1 Mode: LNA ADAPT */
+    TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT, /* AGC1 Mode: LNA ADAPT & TOP ADAPT */
+    TDA18273_AGC1_Mode_FREEZE,              /* AGC1 Mode: FREEZE */
+    TDA18273_AGC1_Mode_WIDE,                /* AGC1 Mode: WIDE */
+    TDA18273_AGC1_Mode_LNA_ADAPT_FREEZE,    /* AGC1 Mode: LNA ADAPT & FREEZE */
+    TDA18273_AGC1_Mode_LNA_ADAPT_WIDE,      /* AGC1 Mode: LNA ADAPT & WIDE */
+    TDA18273_AGC1_Mode_Max
+} TDA18273AGC1_Mode_t, *pTDA18273AGC1_Mode_t;
+
+typedef enum _TDA18273Range_LNA_Adapt_t {
+    TDA18273_Range_LNA_Adapt_20dB_8dB = 0,  /* Range LNA Adapt 20dB-8dB */
+    TDA18273_Range_LNA_Adapt_20dB_11dB,     /* Range LNA Adapt 20dB-11dB */
+    TDA18273_Range_LNA_Adapt_Max
+} TDA18273Range_LNA_Adapt_t, *pTDA18273Range_LNA_Adapt_t;
+
+typedef enum _TDA18273LNA_Adapt_RFAGC_Gv_Threshold {
+    TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB = 0,  /* 18.25dB */
+    TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_16_75dB,      /* 16.75dB */
+    TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_15_25dB,      /* 15.25dB */
+    TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_13_75dB,      /* 13.75dB */
+    TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_Max
+} TDA18273LNA_Adapt_RFAGC_Gv_Threshold, *pTDA18273LNA_Adapt_RFAGC_Gv_Threshold;
+
+typedef enum _TDA18273AGC1_Top_Adapt_RFAGC_Gv_Threshold {
+    TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB = 0, /* 16.75dB */
+    TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,     /* 15.25dB */
+    TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_13_75dB,     /* 13.75dB */
+    TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_12_25dB,     /* 12.25dB */
+    TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_Max
+} TDA18273AGC1_Top_Adapt_RFAGC_Gv_Threshold, *pTDA18273AGC1_Top_Adapt_RFAGC_Gv_Threshold;
+
+typedef enum _TDA18273AGC1_DN_Time_Constant_t {
+    TDA18273_AGC1_DN_Time_Constant_32_752ms = 0, /* 32.752 ms */
+	TDA18273_AGC1_DN_Time_Constant_16_376ms,     /* 16.376 ms */
+	TDA18273_AGC1_DN_Time_Constant_8_188ms,      /* 8.188 ms  */
+	TDA18273_AGC1_DN_Time_Constant_4_094ms       /* 4.094 ms  */
+} TDA18273AGC1_DN_Time_Constant_t, *pTDA18273AGC1_DN_Time_Constant_t;
+
+typedef enum _TDA18273AGC2_TOP_DN_UP_t {
+    TDA18273_AGC2_TOP_DN_UP_d88_u81dBuV = 0,    /* AGC2 TOP DN/UP down 88 up 81 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d90_u83dBuV,        /* AGC2 TOP DN/UP down 90 up 83 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d93_u86dBuV,        /* AGC2 TOP DN/UP down 93 up 86 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d95_u88dBuV,        /* AGC2 TOP DN/UP down 95 up 88 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d88_u82dBuV,        /* AGC2 TOP DN/UP down 88 up 82 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,        /* AGC2 TOP DN/UP down 90 up 84 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d93_u87dBuV,        /* AGC2 TOP DN/UP down 93 up 87 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d95_u89dBuV,        /* AGC2 TOP DN/UP down 95 up 89 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_Max
+} TDA18273AGC2_TOP_DN_UP_t, *pTDA18273AGC2_TOP_DN_UP_t;
+
+typedef enum _TDA18273AGC2_DN_Time_Constant_t {
+	TDA18273_AGC2_DN_Time_Constant_16_376ms = 0, /* 16.376 ms */
+	TDA18273_AGC2_DN_Time_Constant_8_188ms,      /* 8.188 ms  */
+	TDA18273_AGC2_DN_Time_Constant_4_094ms,      /* 4.094 ms  */
+	TDA18273_AGC2_DN_Time_Constant_2_047ms,      /* 2.047 ms  */
+} TDA18273AGC2_DN_Time_Constant_t, *pTDA18273AGC2_DN_Time_Constant_t;
+
+typedef enum _TDA18273AGC3_TOP_I2C_t {
+    TDA18273_AGC3_TOP_I2C_94dBuV = 0,   /* AGC3 TOP I2C 94 dBuV */
+    TDA18273_AGC3_TOP_I2C_96dBuV,       /* AGC3 TOP I2C 96 dBuV */
+    TDA18273_AGC3_TOP_I2C_98dBuV,       /* AGC3 TOP I2C 98 dBuV */
+    TDA18273_AGC3_TOP_I2C_100dBuV,      /* AGC3 TOP I2C 100 dBuV */
+    TDA18273_AGC3_TOP_I2C_102dBuV,      /* AGC3 TOP I2C 102 dBuV */
+    TDA18273_AGC3_TOP_I2C_104dBuV,      /* AGC3 TOP I2C 104 dBuV */
+    TDA18273_AGC3_TOP_I2C_106dBuV,      /* AGC3 TOP I2C 106 dBuV */
+    TDA18273_AGC3_TOP_I2C_107dBuV,      /* AGC3 TOP I2C 107 dBuV */
+    TDA18273_AGC3_TOP_I2C_Max
+} TDA18273AGC3_TOP_I2C_t, *pTDA18273AGC3_TOP_I2C_t;
+
+typedef enum _TDA18273AGC4_TOP_DN_UP_t {
+    TDA18273_AGC4_TOP_DN_UP_d105_u99dBuV = 0,   /* AGC4 TOP DN/UP down 105 up 99 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,      /* AGC4 TOP DN/UP down 105 up 100 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d105_u101dBuV,      /* AGC4 TOP DN/UP down 105 up 101 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d107_u101dBuV,      /* AGC4 TOP DN/UP down 107 up 101 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d107_u102dBuV,      /* AGC4 TOP DN/UP down 107 up 102 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d107_u103dBuV,      /* AGC4 TOP DN/UP down 107 up 103 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d108_u102dBuV,      /* AGC4 TOP DN/UP down 108 up 102 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d109_u103dBuV,      /* AGC4 TOP DN/UP down 109 up 103 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d109_u104dBuV,      /* AGC4 TOP DN/UP down 109 up 104 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d109_u105dBuV,      /* AGC4 TOP DN/UP down 109 up 105 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d110_u104dBuV,      /* AGC4 TOP DN/UP down 110 up 104 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,      /* AGC4 TOP DN/UP down 110 up 105 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d110_u106dBuV,      /* AGC4 TOP DN/UP down 110 up 106 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d112_u106dBuV,      /* AGC4 TOP DN/UP down 112 up 106 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d112_u107dBuV,      /* AGC4 TOP DN/UP down 112 up 107 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d112_u108dBuV,      /* AGC4 TOP DN/UP down 112 up 108 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_Max
+} TDA18273AGC4_TOP_DN_UP_t, *pTDA18273AGC4_TOP_DN_UP_t;
+
+typedef enum _TDA18273AGC5_TOP_DN_UP_t {
+    TDA18273_AGC5_TOP_DN_UP_d105_u99dBuV = 0,   /* AGC5 TOP DN/UP down 105 up 99 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,      /* AGC5 TOP DN/UP down 105 up 100 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d105_u101dBuV,      /* AGC5 TOP DN/UP down 105 up 101 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d107_u101dBuV,      /* AGC5 TOP DN/UP down 107 up 101 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d107_u102dBuV,      /* AGC5 TOP DN/UP down 107 up 102 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d107_u103dBuV,      /* AGC5 TOP DN/UP down 107 up 103 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d108_u102dBuV,      /* AGC5 TOP DN/UP down 108 up 102 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d109_u103dBuV,      /* AGC5 TOP DN/UP down 109 up 103 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d109_u104dBuV,      /* AGC5 TOP DN/UP down 109 up 104 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d109_u105dBuV,      /* AGC5 TOP DN/UP down 109 up 105 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d110_u104dBuV,      /* AGC5 TOP DN/UP down 108 up 104 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,      /* AGC5 TOP DN/UP down 108 up 105 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d110_u106dBuV,      /* AGC5 TOP DN/UP down 108 up 106 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d112_u106dBuV,      /* AGC5 TOP DN/UP down 108 up 106 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d112_u107dBuV,      /* AGC5 TOP DN/UP down 108 up 107 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d112_u108dBuV,      /* AGC5 TOP DN/UP down 108 up 108 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_Max
+} TDA18273AGC5_TOP_DN_UP_t, *pTDA18273AGC5_TOP_DN_UP_t;
+
+typedef enum _TDA18273AGC3_Top_Adapt_Algorithm {
+    TDA18273_Top_Adapt_NO_TOP_ADAPT = 0,    /* NO TOP ADAPT */
+    TDA18273_Top_Adapt_TOP_ADAPT35,         /* TOP ADAPT35  */
+    TDA18273_Top_Adapt_TOP_ADAPT34,         /* TOP ADAPT34  */
+    TDA18273_Top_Adapt_Max
+} TDA18273AGC3_Top_Adapt_Algorithm, *pTDA18273AGC3_Top_Adapt_Algorithm;
+
+typedef enum _TDA18273AGC3_Adapt_TOP_t {
+    TDA18273_AGC3_Adapt_TOP_0_Step = 0, /* same level as AGC3 TOP  */
+    TDA18273_AGC3_Adapt_TOP_1_Step,     /* 1 level below AGC3 TOP  */
+    TDA18273_AGC3_Adapt_TOP_2_Step,     /* 2 level below AGC3 TOP  */
+    TDA18273_AGC3_Adapt_TOP_3_Step      /* 3 level below AGC3 TOP  */
+} TDA18273AGC3_Adapt_TOP_t, *pTDA18273AGC3_Adapt_TOP_t;
+
+typedef enum _TDA18273AGC_Overload_TOP_t {
+    TDA18273_AGC_Overload_TOP_plus_9_plus_3_5_min_3_5 = 0,  /* +9/+3.5/-3.5 */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_4_5,      /* +9/+4.5/-4.5 */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,      /* +9/+4.5/-3.5 */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_6_min_4_5,        /* +9/+6/-4.5   */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_6_min_6,          /* +9/+6/-6     */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_6_min_9,          /* +9/+6/-9     */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_7_5_min_9,        /* +9/+7.5/-9   */
+    TDA18273_AGC_Overload_TOP_plus_12_plus_7_5_min_9        /* +12/+7.5/-9   */
+} TDA18273AGC_Overload_TOP_t, *pTDA18273AGC_Overload_TOP_t;
+
+typedef enum _TDA18273TH_AGC_Adapt34_t {
+    TDA18273_TH_AGC_Adapt34_2dB = 0,    /* Adapt TOP 34 Gain Threshold 2dB */
+    TDA18273_TH_AGC_Adapt34_5dB         /* Adapt TOP 34 Gain Threshold 5dB */
+} TDA18273TH_AGC_Adapt34_t, *pTDA18273TH_AGC_Adapt34_t;
+
+typedef enum _TDA18273RF_Atten_3dB_t {
+    TDA18273_RF_Atten_3dB_Disabled = 0, /* RF_Atten_3dB Disabled */
+    TDA18273_RF_Atten_3dB_Enabled,      /* RF_Atten_3dB Enabled */
+    TDA18273_RF_Atten_3dB_Max
+} TDA18273RF_Atten_3dB_t, *pTDA18273RF_Atten_3dB_t;
+
+typedef enum _TDA18273IF_Output_Level_t {
+    TDA18273_IF_Output_Level_2Vpp_0_30dB = 0,           /* 2Vpp       0 - 30dB      */
+    TDA18273_IF_Output_Level_1_25Vpp_min_4_26dB,        /* 1.25Vpp   -4 - 26dB      */
+    TDA18273_IF_Output_Level_1Vpp_min_6_24dB,           /* 1Vpp      -6 - 24dB      */
+    TDA18273_IF_Output_Level_0_8Vpp_min_8_22dB,         /* 0.8Vpp    -8 - 22dB      */
+    TDA18273_IF_Output_Level_0_85Vpp_min_7_5_22_5dB,    /* 0.85Vpp   -7.5 - 22.5dB  */
+    TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,         /* 0.7Vpp    -9 - 21dB      */
+    TDA18273_IF_Output_Level_0_6Vpp_min_10_3_19_7dB,    /* 0.6Vpp    -10.3 - 19.7dB */
+    TDA18273_IF_Output_Level_0_5Vpp_min_12_18dB,        /* 0.5Vpp    -12 - 18dB     */
+    TDA18273_IF_Output_Level_Max
+} TDA18273IF_Output_Level_t, *pTDA18273IF_Output_Level_t;
+
+typedef enum _TDA18273S2D_Gain_t {
+    TDA18273_S2D_Gain_3dB = 0,  /* 3dB */
+    TDA18273_S2D_Gain_6dB,      /* 6dB */
+    TDA18273_S2D_Gain_9dB,      /* 9dB */
+    TDA18273_S2D_Gain_Max
+} TDA18273S2D_Gain_t, *pTDA18273S2D_Gain_t;
+
+typedef enum _TDA18273Negative_Modulation_t {
+    TDA18273_Negative_Modulation_Disabled = 0,
+    TDA18273_Negative_Modulation_Enabled,
+    TDA18273_Negative_Modulation_Max
+} TDA18273Negative_Modulation_t, *pTDA18273Negative_Modulation_t;
+
+typedef enum _TDA18273AGCK_Steps_t {
+    TDA18273_AGCK_Steps_0_2dB = 0,  /* 0.2dB */
+    TDA18273_AGCK_Steps_0_4dB,      /* 0.4dB */
+    TDA18273_AGCK_Steps_0_6dB,      /* 0.6dB */
+    TDA18273_AGCK_Steps_0_8dB,      /* 0.8dB */
+    TDA18273_AGCK_Steps_Max
+} TDA18273AGCK_Steps_t, *pTDA18273AGCK_Steps_t;
+
+typedef enum _TDA18273AGCK_Time_Constant_t {
+    TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE = 0,  /* 1 Step Each VSYNC Rising Edge */
+    TDA18273_AGCK_Time_Constant_0_512ms,                            /* 0.512ms                       */
+    TDA18273_AGCK_Time_Constant_8_192ms,                            /* 8.192ms                       */
+    TDA18273_AGCK_Time_Constant_32_768ms,                           /* 32.768ms                      */
+    TDA18273_AGCK_Time_Constant_Max
+} TDA18273AGCK_Time_Constant_t, *pTDA18273AGCK_Time_Constant_t;
+
+typedef enum _TDA18273AGC5_HPF_t {
+    TDA18273_AGC5_HPF_Disabled = 0, /* AGC5 HPF Disabled */
+    TDA18273_AGC5_HPF_Enabled,      /* AGC5 HPF Enabled  */
+    TDA18273_AGC5_HPF_Max
+} TDA18273AGC5_HPF_t, *pTDA18273AGC5_HPF_t;
+
+typedef enum _TDA18273Pulse_Shaper_Disable_t {
+    TDA18273_Pulse_Shaper_Disable_Disabled = 0,
+    TDA18273_Pulse_Shaper_Disable_Enabled,
+    TDA18273_Pulse_Shaper_Disable_Max
+} TDA18273Pulse_Shaper_Disable_t, *pTDA18273Pulse_Shaper_Disable_t;
+
+typedef enum _TDA18273VHF_III_Mode_t {
+    TDA18273_VHF_III_Mode_Disabled = 0, /* VHF_III_Mode Disabled */
+    TDA18273_VHF_III_Mode_Enabled,      /* VHF_III_Mode Enabled  */
+    TDA18273_VHF_III_Mode_Max
+} TDA18273VHF_III_Mode_t, *pTDA18273VHF_III_Mode_t;
+
+typedef enum _TDA18273LO_CP_Current_t {
+    TDA18273_LO_CP_Current_Disabled = 0,    /* LO CP Current Disabled */
+    TDA18273_LO_CP_Current_Enabled,         /* LO CP Current Enabled  */
+    TDA18273_LO_CP_Current_Max
+} TDA18273LO_CP_Current_t, *pTDA18273LO_CP_Current_t;
+
+typedef enum _TDA18273PD_Underload_t {
+    TDA18273_PD_Underload_Disabled = 0,    /* PD Underload Disabled */
+    TDA18273_PD_Underload_Enabled,         /* PD Underload Enabled  */
+    TDA18273_PD_Underload_Max
+} TDA18273PD_Underload_t, *pTDA18273PD_Underload_t;
+
+typedef struct _TDA18273StdCoefficients
+{
+    /****************************************************************/
+    /* IF Settings                                                  */
+    /****************************************************************/
+    UInt32                                      IF;                                 /* IF Frequency */
+    Int32                                       CF_Offset;
+
+    /****************************************************************/
+    /* IF SELECTIVITY Settings                                      */
+    /****************************************************************/
+    TDA18273LPF_t                               LPF;                                /* LPF Cut off */
+    TDA18273LPFOffset_t                         LPF_Offset;                         /* LPF offset */
+    TDA18273DC_Notch_IF_PPF_t                   DC_Notch_IF_PPF;                    /* DC notch IF PPF */
+    TDA18273IF_HPF_t                            IF_HPF;                             /* Hi Pass */
+    TDA18273IF_Notch_t                          IF_Notch;                           /* IF notch */
+    TDA18273IFnotchToRSSI_t                     IFnotchToRSSI;                      /* IFnotchToRSSI */
+
+    /****************************************************************/
+    /* AGC TOP Settings                                             */
+    /****************************************************************/
+    TDA18273AGC1_TOP_I2C_DN_UP_t                AGC1_TOP_I2C_DN_UP;                 /* AGC1 TOP I2C DN/UP */
+    TDA18273AGC1_Adapt_TOP_DN_UP_t              AGC1_Adapt_TOP_DN_UP;               /* AGC1 Adapt TOP DN/UP */
+	TDA18273AGC1_DN_Time_Constant_t             AGC1_DN_Time_Constant;              /* AGC1 DN Time Constant */
+    TDA18273AGC1_Mode_t                         AGC1_Mode;                          /* AGC1 mode */
+    TDA18273Range_LNA_Adapt_t                   Range_LNA_Adapt;                    /* Range_LNA_Adapt */
+    TDA18273LNA_Adapt_RFAGC_Gv_Threshold        LNA_Adapt_RFAGC_Gv_Threshold;       /* LNA_Adapt_RFAGC_Gv_Threshold */
+    TDA18273AGC1_Top_Adapt_RFAGC_Gv_Threshold   AGC1_Top_Adapt_RFAGC_Gv_Threshold;  /* AGC1_Top_Adapt_RFAGC_Gv_Threshold */
+    TDA18273AGC2_TOP_DN_UP_t                    AGC2_TOP_DN_UP;                     /* AGC2 TOP DN/UP */
+	TDA18273AGC2_DN_Time_Constant_t             AGC2_DN_Time_Constant;              /* AGC2 DN Time Constant */
+    TDA18273AGC3_TOP_I2C_t                      AGC3_TOP_I2C_Low_Band;              /* AGC3 TOP I2C Low Band */
+    TDA18273AGC3_TOP_I2C_t                      AGC3_TOP_I2C_High_Band;             /* AGC3 TOP I2C High Band */
+    TDA18273AGC4_TOP_DN_UP_t                    AGC4_TOP_DN_UP;                     /* AGC4 TOP DN/UP */
+    TDA18273AGC5_TOP_DN_UP_t                    AGC5_TOP_DN_UP;                     /* AGC5 TOP DN/UP */
+    TDA18273AGC3_Top_Adapt_Algorithm            AGC3_Top_Adapt_Algorithm;           /* AGC3_Top_Adapt_Algorithm */
+    TDA18273AGC3_Adapt_TOP_t                    AGC3_Adapt_TOP_Low_Band;            /* AGC3 Adapt TOP Low Band */
+    TDA18273AGC3_Adapt_TOP_t                    AGC3_Adapt_TOP_High_Band;           /* AGC3 Adapt TOP High Band */
+    TDA18273AGC_Overload_TOP_t                  AGC_Overload_TOP;                   /* AGC Overload TOP */
+    TDA18273TH_AGC_Adapt34_t                    TH_AGC_Adapt34;                     /* Adapt TOP 34 Gain Threshold */
+    TDA18273RF_Atten_3dB_t                      RF_Atten_3dB;                       /* RF atten 3dB */
+    TDA18273IF_Output_Level_t                   IF_Output_Level;                    /* IF Output Level */
+    TDA18273S2D_Gain_t                          S2D_Gain;                           /* S2D gain */
+    TDA18273Negative_Modulation_t               Negative_Modulation;                /* Negative modulation */
+
+    /****************************************************************/
+    /* GSK Settings                                                 */
+    /****************************************************************/
+    TDA18273AGCK_Steps_t                        AGCK_Steps;                         /* Step */
+    TDA18273AGCK_Time_Constant_t                AGCK_Time_Constant;                 /* AGCK Time Constant */
+    TDA18273AGC5_HPF_t                          AGC5_HPF;                           /* AGC5 HPF */
+    TDA18273Pulse_Shaper_Disable_t              Pulse_Shaper_Disable;               /* Pulse Shaper Disable */
+
+    /****************************************************************/
+    /* H3H5 Settings                                                */
+    /****************************************************************/
+    TDA18273VHF_III_Mode_t                      VHF_III_Mode;                       /* VHF_III_Mode */
+
+    /****************************************************************/
+    /* PLL Settings                                                 */
+    /****************************************************************/
+    TDA18273LO_CP_Current_t                     LO_CP_Current;                      /* LO_CP_Current */
+
+	/****************************************************************/
+    /* MISC Settings                                                */
+    /****************************************************************/
+	TDA18273PD_Underload_t                      PD_Underload;                       /* PD Underload */
+	UInt32										Freq_Start_LTE;                     /* Frequency start of high band for LTE */
+} TDA18273StdCoefficients, *pTDA18273StdCoefficients;
+
+typedef struct _TDA18273Object_t
+{
+    UInt32                          uRF;
+    UInt32                          uProgRF;
+    UInt32                          uIF;
+    TDA18273StandardMode_t          StandardMode;
+    pTDA18273StdCoefficients        pStandard;
+    TDA18273StdCoefficients         Std_Array[TDA18273_StandardMode_Max-1];
+} TDA18273Object_t, *pTDA18273Object_t, **ppTDA18273Object_t;
+
+/* Standard Preset Definitions: */
+#define TDA18273_INSTANCE_CUSTOM_STD_QAM_6MHZ \
+    {                                                               /* QAM 6MHz */ \
+	3600000,				                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_6MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_min_4pc,                                 /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_1MHz,                                       /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89wdBuV,                   /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,             /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_WIDE,                          /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,             /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                      /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_NO_TOP_ADAPT,                            /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt Low Band */ \
+	TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                     /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_QAM_8MHZ \
+    {                                                               /* QAM 8MHz */ \
+	5000000,				      				/* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_9MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_min_8pc,                                 /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_85MHz,                                    /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89wdBuV,                   /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_WIDE,                          /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_NO_TOP_ADAPT,                            /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ATSC_6MHZ \
+    {                                                               /* ATSC */ \
+	3250000,								/* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_6MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_4MHz,                                     /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d100_u94dBuV,                   /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_104dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_104dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d112_u107dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d112_u107dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_3_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_3_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_6Vpp_min_10_3_19_7dB,           /* IF Output Level */ \
+	TDA18273_S2D_Gain_3dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		662000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ISDBT_6MHZ \
+    {                                                               /* ISDBT */ \
+	3250000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_6MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_4MHz,                                     /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_6Vpp_min_10_3_19_7dB,            /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DVBT_1_7MHZ \
+    {                                                               /* DVB-T/T2 1.7MHz */ \
+	850000,                                                     /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_1_5MHz,                                        /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_4_094ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_2_047ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_94dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Enabled,                              /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DVBT_6MHZ \
+    {                                                               /* DVB-T/T2 6MHz */ \
+	3250000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_6MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_4MHz,                                     /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_4_094ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_2_047ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_94dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Enabled,                              /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DVBT_7MHZ \
+    {                                                               /* DVB-T/T2 7MHz */ \
+	3500000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_7MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_min_8pc,                                 /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_4_094ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_2_047ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_94dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Enabled,                              /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DVBT_8MHZ \
+    {                                                               /* DVB-T/T2 8MHz */ \
+	4000000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_4_094ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_2_047ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_94dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Enabled,                              /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DVBT_10MHZ \
+    {                                                               /* DVB-T/T2 10MHz */ \
+	5000000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_9MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DMBT_8MHZ \
+    {                                                               /* DMB-T */ \
+	4000000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_FM_RADIO \
+    {                                                               /* FM */ \
+	1250000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_1_5MHz,                                        /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_85MHz,                                    /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_8Vpp_min_8_22dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_MN \
+    {                                                               /* NTSC M/N */ \
+	5400000,                                                    /* IF */ \
+	1750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_6MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Enabled,                       /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_B \
+    {                                                               /* PAL B */ \
+	6400000,                                                    /* IF */ \
+	2250000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_7MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Enabled,                       /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_GH \
+    {                                                               /* PAL G/H */ \
+	6750000,                                                    /* IF */ \
+	2750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Enabled,                       /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_I \
+    {                                                               /* PAL I */ \
+	7250000,                                                    /* IF */ \
+	2750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Enabled,                       /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_DK \
+    {                                                               /* SECAM D/K */ \
+	6850000,                                                    /* IF */ \
+	2750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Enabled,                       /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_L \
+    {                                                               /* SECAM L */ \
+	6750000,                                                    /* IF */ \
+	2750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_6_min_9,              /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_LL \
+    {                                                               /* SECAM L' */ \
+	1250000,                                                    /* IF */ \
+	-2750000,                                                   /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_6_min_9,              /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_BLIND_SCANNING \
+    {                                                               /* Blind Scanning copy of PAL-I */ \
+	7250000,                                                    /* IF */ \
+	2750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_SCANXPRESS \
+    {                                                               /* ScanXpress */ \
+	5000000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_9MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_min_8pc,                                 /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_85MHz,                                    /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89wdBuV,                   /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_WIDE,                          /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_NO_TOP_ADAPT,                            /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+/* Standard Presets Aggregation: */
+#define TDA18273_INSTANCE_CUSTOM_STD_DEF \
+    { \
+	TDA18273_INSTANCE_CUSTOM_STD_QAM_6MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_QAM_8MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_ATSC_6MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_ISDBT_6MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DVBT_1_7MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DVBT_6MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DVBT_7MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DVBT_8MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DVBT_10MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DMBT_8MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_FM_RADIO, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_MN, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_B, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_GH, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_I, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_DK, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_L, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_LL, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_BLIND_SCANNING, \
+	TDA18273_INSTANCE_CUSTOM_STD_SCANXPRESS \
+    }
+
+#endif	/* __TDA18273_PRIV */
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/Kconfig" "b/drivers/media/usb/dvb-usb/Kconfig"
--- "a/drivers/media/usb/dvb-usb/Kconfig"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/Kconfig"	2018-01-17 18:28:26.024098000 +0800
@@ -106,6 +106,16 @@
 	  Say Y if you own such a device and want to use it. You should build it as
 	  a module.
 
+config DVB_USB_TBS5520SE
+	tristate "Turbosight TBS5520SE DVB-T/T2/C/C2/S/S2/ISDB-T USB2.0 support"
+	depends on DVB_USB
+	select DVB_PLL if MEDIA_SUBDRV_AUTOSELECT
+	select MEDIA_TUNER_AV201X if MEDIA_SUBDRV_AUTOSELECT
+	select MEDIA_TUNER_SI2157 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_SI2183 if MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Say Y here to support the Turbosight TBS5520SE USB2 DVB-T/T2/C/C2/S/S2/ISDB-T device
+
 config DVB_USB_UMT_010
 	tristate "HanfTek UMT-010 DVB-T USB2.0 support"
 	depends on DVB_USB
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/Makefile" "b/drivers/media/usb/dvb-usb/Makefile"
--- "a/drivers/media/usb/dvb-usb/Makefile"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/Makefile"	2018-01-17 18:29:42.084978000 +0800
@@ -73,6 +73,9 @@
 dvb-usb-friio-objs := friio.o friio-fe.o
 obj-$(CONFIG_DVB_USB_FRIIO) += dvb-usb-friio.o
 
+dvb-usb-tbs5520se-objs := tbs5520se.o
+obj-$(CONFIG_DVB_USB_TBS5520SE) += dvb-usb-tbs5520se.o
+
 dvb-usb-az6027-objs := az6027.o
 obj-$(CONFIG_DVB_USB_AZ6027) += dvb-usb-az6027.o
 
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/cxusb.c" "b/drivers/media/usb/dvb-usb/cxusb.c"
--- "a/drivers/media/usb/dvb-usb/cxusb.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/cxusb.c"	2017-12-07 05:52:26.000000000 +0800
@@ -370,6 +370,26 @@
 	return 0;
 }
 
+static int cxusb_read_status(struct dvb_frontend *fe,
+				  enum fe_status *status)
+{
+	struct dvb_usb_adapter *adap = (struct dvb_usb_adapter *)fe->dvb->priv;
+	struct cxusb_state *state = (struct cxusb_state *)adap->dev->priv;
+	int ret;
+
+	ret = state->fe_read_status(fe, status);
+
+	/* it need resync slave fifo when signal change from unlock to lock.*/
+	if ((*status & FE_HAS_LOCK) && (!state->last_lock)) {
+		mutex_lock(&state->stream_mutex);
+		cxusb_streaming_ctrl(adap, 1);
+		mutex_unlock(&state->stream_mutex);
+	}
+
+	state->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;
+	return ret;
+}
+
 static void cxusb_d680_dmb_drain_message(struct dvb_usb_device *d)
 {
 	int       ep = d->props.generic_bulk_ctrl_endpoint;
@@ -431,209 +451,46 @@
 	}
 }
 
-static int cxusb_rc_query(struct dvb_usb_device *d, u32 *event, int *state)
+static int cxusb_rc_query(struct dvb_usb_device *d)
 {
-	struct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;
 	u8 ircode[4];
-	int i;
 
 	cxusb_ctrl_msg(d, CMD_GET_IR_CODE, NULL, 0, ircode, 4);
 
-	*event = 0;
-	*state = REMOTE_NO_KEY_PRESSED;
-
-	for (i = 0; i < d->props.rc.legacy.rc_map_size; i++) {
-		if (rc5_custom(&keymap[i]) == ircode[2] &&
-		    rc5_data(&keymap[i]) == ircode[3]) {
-			*event = keymap[i].keycode;
-			*state = REMOTE_KEY_PRESSED;
-
-			return 0;
-		}
-	}
-
+	if (ircode[2] || ircode[3])
+		rc_keydown(d->rc_dev, RC_PROTO_NEC,
+			   RC_SCANCODE_NEC(~ircode[2] & 0xff, ircode[3]), 0);
 	return 0;
 }
 
-static int cxusb_bluebird2_rc_query(struct dvb_usb_device *d, u32 *event,
-				    int *state)
+static int cxusb_bluebird2_rc_query(struct dvb_usb_device *d)
 {
-	struct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;
 	u8 ircode[4];
-	int i;
 	struct i2c_msg msg = { .addr = 0x6b, .flags = I2C_M_RD,
 			       .buf = ircode, .len = 4 };
 
-	*event = 0;
-	*state = REMOTE_NO_KEY_PRESSED;
-
 	if (cxusb_i2c_xfer(&d->i2c_adap, &msg, 1) != 1)
 		return 0;
 
-	for (i = 0; i < d->props.rc.legacy.rc_map_size; i++) {
-		if (rc5_custom(&keymap[i]) == ircode[1] &&
-		    rc5_data(&keymap[i]) == ircode[2]) {
-			*event = keymap[i].keycode;
-			*state = REMOTE_KEY_PRESSED;
-
-			return 0;
-		}
-	}
-
+	if (ircode[1] || ircode[2])
+		rc_keydown(d->rc_dev, RC_PROTO_NEC,
+			   RC_SCANCODE_NEC(~ircode[1] & 0xff, ircode[2]), 0);
 	return 0;
 }
 
-static int cxusb_d680_dmb_rc_query(struct dvb_usb_device *d, u32 *event,
-		int *state)
+static int cxusb_d680_dmb_rc_query(struct dvb_usb_device *d)
 {
-	struct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;
 	u8 ircode[2];
-	int i;
-
-	*event = 0;
-	*state = REMOTE_NO_KEY_PRESSED;
 
 	if (cxusb_ctrl_msg(d, 0x10, NULL, 0, ircode, 2) < 0)
 		return 0;
 
-	for (i = 0; i < d->props.rc.legacy.rc_map_size; i++) {
-		if (rc5_custom(&keymap[i]) == ircode[0] &&
-		    rc5_data(&keymap[i]) == ircode[1]) {
-			*event = keymap[i].keycode;
-			*state = REMOTE_KEY_PRESSED;
-
-			return 0;
-		}
-	}
-
+	if (ircode[0] || ircode[1])
+		rc_keydown(d->rc_dev, RC_PROTO_UNKNOWN,
+			   RC_SCANCODE_RC5(ircode[0], ircode[1]), 0);
 	return 0;
 }
 
-static struct rc_map_table rc_map_dvico_mce_table[] = {
-	{ 0xfe02, KEY_TV },
-	{ 0xfe0e, KEY_MP3 },
-	{ 0xfe1a, KEY_DVD },
-	{ 0xfe1e, KEY_FAVORITES },
-	{ 0xfe16, KEY_SETUP },
-	{ 0xfe46, KEY_POWER2 },
-	{ 0xfe0a, KEY_EPG },
-	{ 0xfe49, KEY_BACK },
-	{ 0xfe4d, KEY_MENU },
-	{ 0xfe51, KEY_UP },
-	{ 0xfe5b, KEY_LEFT },
-	{ 0xfe5f, KEY_RIGHT },
-	{ 0xfe53, KEY_DOWN },
-	{ 0xfe5e, KEY_OK },
-	{ 0xfe59, KEY_INFO },
-	{ 0xfe55, KEY_TAB },
-	{ 0xfe0f, KEY_PREVIOUSSONG },/* Replay */
-	{ 0xfe12, KEY_NEXTSONG },	/* Skip */
-	{ 0xfe42, KEY_ENTER	 },	/* Windows/Start */
-	{ 0xfe15, KEY_VOLUMEUP },
-	{ 0xfe05, KEY_VOLUMEDOWN },
-	{ 0xfe11, KEY_CHANNELUP },
-	{ 0xfe09, KEY_CHANNELDOWN },
-	{ 0xfe52, KEY_CAMERA },
-	{ 0xfe5a, KEY_TUNER },	/* Live */
-	{ 0xfe19, KEY_OPEN },
-	{ 0xfe0b, KEY_1 },
-	{ 0xfe17, KEY_2 },
-	{ 0xfe1b, KEY_3 },
-	{ 0xfe07, KEY_4 },
-	{ 0xfe50, KEY_5 },
-	{ 0xfe54, KEY_6 },
-	{ 0xfe48, KEY_7 },
-	{ 0xfe4c, KEY_8 },
-	{ 0xfe58, KEY_9 },
-	{ 0xfe13, KEY_ANGLE },	/* Aspect */
-	{ 0xfe03, KEY_0 },
-	{ 0xfe1f, KEY_ZOOM },
-	{ 0xfe43, KEY_REWIND },
-	{ 0xfe47, KEY_PLAYPAUSE },
-	{ 0xfe4f, KEY_FASTFORWARD },
-	{ 0xfe57, KEY_MUTE },
-	{ 0xfe0d, KEY_STOP },
-	{ 0xfe01, KEY_RECORD },
-	{ 0xfe4e, KEY_POWER },
-};
-
-static struct rc_map_table rc_map_dvico_portable_table[] = {
-	{ 0xfc02, KEY_SETUP },       /* Profile */
-	{ 0xfc43, KEY_POWER2 },
-	{ 0xfc06, KEY_EPG },
-	{ 0xfc5a, KEY_BACK },
-	{ 0xfc05, KEY_MENU },
-	{ 0xfc47, KEY_INFO },
-	{ 0xfc01, KEY_TAB },
-	{ 0xfc42, KEY_PREVIOUSSONG },/* Replay */
-	{ 0xfc49, KEY_VOLUMEUP },
-	{ 0xfc09, KEY_VOLUMEDOWN },
-	{ 0xfc54, KEY_CHANNELUP },
-	{ 0xfc0b, KEY_CHANNELDOWN },
-	{ 0xfc16, KEY_CAMERA },
-	{ 0xfc40, KEY_TUNER },	/* ATV/DTV */
-	{ 0xfc45, KEY_OPEN },
-	{ 0xfc19, KEY_1 },
-	{ 0xfc18, KEY_2 },
-	{ 0xfc1b, KEY_3 },
-	{ 0xfc1a, KEY_4 },
-	{ 0xfc58, KEY_5 },
-	{ 0xfc59, KEY_6 },
-	{ 0xfc15, KEY_7 },
-	{ 0xfc14, KEY_8 },
-	{ 0xfc17, KEY_9 },
-	{ 0xfc44, KEY_ANGLE },	/* Aspect */
-	{ 0xfc55, KEY_0 },
-	{ 0xfc07, KEY_ZOOM },
-	{ 0xfc0a, KEY_REWIND },
-	{ 0xfc08, KEY_PLAYPAUSE },
-	{ 0xfc4b, KEY_FASTFORWARD },
-	{ 0xfc5b, KEY_MUTE },
-	{ 0xfc04, KEY_STOP },
-	{ 0xfc56, KEY_RECORD },
-	{ 0xfc57, KEY_POWER },
-	{ 0xfc41, KEY_UNKNOWN },    /* INPUT */
-	{ 0xfc00, KEY_UNKNOWN },    /* HD */
-};
-
-static struct rc_map_table rc_map_d680_dmb_table[] = {
-	{ 0x0038, KEY_UNKNOWN },	/* TV/AV */
-	{ 0x080c, KEY_ZOOM },
-	{ 0x0800, KEY_0 },
-	{ 0x0001, KEY_1 },
-	{ 0x0802, KEY_2 },
-	{ 0x0003, KEY_3 },
-	{ 0x0804, KEY_4 },
-	{ 0x0005, KEY_5 },
-	{ 0x0806, KEY_6 },
-	{ 0x0007, KEY_7 },
-	{ 0x0808, KEY_8 },
-	{ 0x0009, KEY_9 },
-	{ 0x000a, KEY_MUTE },
-	{ 0x0829, KEY_BACK },
-	{ 0x0012, KEY_CHANNELUP },
-	{ 0x0813, KEY_CHANNELDOWN },
-	{ 0x002b, KEY_VOLUMEUP },
-	{ 0x082c, KEY_VOLUMEDOWN },
-	{ 0x0020, KEY_UP },
-	{ 0x0821, KEY_DOWN },
-	{ 0x0011, KEY_LEFT },
-	{ 0x0810, KEY_RIGHT },
-	{ 0x000d, KEY_OK },
-	{ 0x081f, KEY_RECORD },
-	{ 0x0017, KEY_PLAYPAUSE },
-	{ 0x0816, KEY_PLAYPAUSE },
-	{ 0x000b, KEY_STOP },
-	{ 0x0827, KEY_FASTFORWARD },
-	{ 0x0026, KEY_REWIND },
-	{ 0x081e, KEY_UNKNOWN },    /* Time Shift */
-	{ 0x000e, KEY_UNKNOWN },    /* Snapshot */
-	{ 0x082d, KEY_UNKNOWN },    /* Mouse Cursor */
-	{ 0x000f, KEY_UNKNOWN },    /* Minimize/Maximize */
-	{ 0x0814, KEY_UNKNOWN },    /* Shuffle */
-	{ 0x0025, KEY_POWER },
-};
-
 static int cxusb_dee1601_demod_init(struct dvb_frontend* fe)
 {
 	static u8 clock_config []  = { CLOCK_CTL,  0x38, 0x28 };
@@ -981,7 +838,7 @@
 		return -EIO;
 
 	/* try to determine if there is no IR decoder on the I2C bus */
-	for (i = 0; adap->dev->props.rc.legacy.rc_map_table != NULL && i < 5; i++) {
+	for (i = 0; adap->dev->props.rc.core.rc_codes && i < 5; i++) {
 		msleep(20);
 		if (cxusb_i2c_xfer(&adap->dev->i2c_adap, &msg, 1) != 1)
 			goto no_IR;
@@ -989,7 +846,7 @@
 			continue;
 		if (ircode[2] + ircode[3] != 0xff) {
 no_IR:
-			adap->dev->props.rc.legacy.rc_map_table = NULL;
+			adap->dev->props.rc.core.rc_codes = NULL;
 			info("No IR receiver detected on this device.");
 			break;
 		}
@@ -1329,9 +1186,11 @@
 		usb_rcvbulkpipe(d->udev, d->props.adapter[0].fe[0].stream.endpoint));
 
 	/* attach frontend */
+	memset(&si2168_config, 0, sizeof(si2168_config));
 	si2168_config.i2c_adapter = &adapter;
 	si2168_config.fe = &adap->fe_adap[0].fe;
 	si2168_config.ts_mode = SI2168_TS_PARALLEL;
+	si2168_config.ts_clock_mode = SI2168_TS_CLK_AUTO_ADAPT;
 	si2168_config.ts_clock_inv = 1;
 	memset(&info, 0, sizeof(struct i2c_board_info));
 	strlcpy(info.type, "si2168", I2C_NAME_SIZE);
@@ -1347,8 +1206,6 @@
 		return -ENODEV;
 	}
 
-	st->i2c_client_demod = client_demod;
-
 	/* attach tuner */
 	memset(&si2157_config, 0, sizeof(si2157_config));
 	si2157_config.fe = adap->fe_adap[0].fe;
@@ -1371,8 +1228,93 @@
 		return -ENODEV;
 	}
 
+	st->i2c_client_demod = client_demod;
+	st->i2c_client_tuner = client_tuner;
+
+	/* hook fe: need to resync the slave fifo when signal locks. */
+	mutex_init(&st->stream_mutex);
+	st->last_lock = 0;
+	st->fe_read_status = adap->fe_adap[0].fe->ops.read_status;
+	adap->fe_adap[0].fe->ops.read_status = cxusb_read_status;
+
+	return 0;
+}
+
+static int cxusb_mygica_t230c_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	struct dvb_usb_device *d = adap->dev;
+	struct cxusb_state *st = d->priv;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client_demod;
+	struct i2c_client *client_tuner;
+	struct i2c_board_info info;
+	struct si2168_config si2168_config;
+	struct si2157_config si2157_config;
+
+	/* Select required USB configuration */
+	if (usb_set_interface(d->udev, 0, 0) < 0)
+		err("set interface failed");
+
+	/* Unblock all USB pipes */
+	usb_clear_halt(d->udev,
+		usb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));
+	usb_clear_halt(d->udev,
+		usb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));
+	usb_clear_halt(d->udev,
+		usb_rcvbulkpipe(d->udev, d->props.adapter[0].fe[0].stream.endpoint));
+
+	/* attach frontend */
+	memset(&si2168_config, 0, sizeof(si2168_config));
+	si2168_config.i2c_adapter = &adapter;
+	si2168_config.fe = &adap->fe_adap[0].fe;
+	si2168_config.ts_mode = SI2168_TS_PARALLEL;
+	si2168_config.ts_clock_mode = d->udev->descriptor.idProduct == (USB_PID_MYGICA_T230+2) ?
+						SI2168_TS_CLK_MANUAL : SI2168_TS_CLK_AUTO_ADAPT;
+	si2168_config.ts_clock_inv = 1;
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	strlcpy(info.type, "si2168", I2C_NAME_SIZE);
+	info.addr = 0x64;
+	info.platform_data = &si2168_config;
+	request_module(info.type);
+	client_demod = i2c_new_device(&d->i2c_adap, &info);
+	if (client_demod == NULL || client_demod->dev.driver == NULL)
+		return -ENODEV;
+
+	if (!try_module_get(client_demod->dev.driver->owner)) {
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+
+	/* attach tuner */
+	memset(&si2157_config, 0, sizeof(si2157_config));
+	si2157_config.fe = adap->fe_adap[0].fe;
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	strlcpy(info.type, "si2141", I2C_NAME_SIZE);
+	info.addr = 0x60;
+	info.platform_data = &si2157_config;
+	request_module("si2157");
+	client_tuner = i2c_new_device(adapter, &info);
+	if (client_tuner == NULL || client_tuner->dev.driver == NULL) {
+		module_put(client_demod->dev.driver->owner);
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+	if (!try_module_get(client_tuner->dev.driver->owner)) {
+		i2c_unregister_device(client_tuner);
+		module_put(client_demod->dev.driver->owner);
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+
+	st->i2c_client_demod = client_demod;
 	st->i2c_client_tuner = client_tuner;
 
+	/* hook fe: need to resync the slave fifo when signal locks. */
+	mutex_init(&st->stream_mutex);
+	st->last_lock = 0;
+	st->fe_read_status = adap->fe_adap[0].fe->ops.read_status;
+	adap->fe_adap[0].fe->ops.read_status = cxusb_read_status;
+
 	return 0;
 }
 
@@ -1458,6 +1400,7 @@
 static struct dvb_usb_device_properties cxusb_d680_dmb_properties;
 static struct dvb_usb_device_properties cxusb_mygica_d689_properties;
 static struct dvb_usb_device_properties cxusb_mygica_t230_properties;
+static struct dvb_usb_device_properties cxusb_mygica_t230c_properties;
 
 static int cxusb_probe(struct usb_interface *intf,
 		       const struct usb_device_id *id)
@@ -1490,6 +1433,8 @@
 				     THIS_MODULE, NULL, adapter_nr) ||
 	    0 == dvb_usb_device_init(intf, &cxusb_mygica_t230_properties,
 				     THIS_MODULE, NULL, adapter_nr) ||
+	    0 == dvb_usb_device_init(intf, &cxusb_mygica_t230c_properties,
+				     THIS_MODULE, NULL, adapter_nr) ||
 	    0)
 		return 0;
 
@@ -1500,6 +1445,7 @@
 {
 	struct dvb_usb_device *d = usb_get_intfdata(intf);
 	struct cxusb_state *st = d->priv;
+
 	struct i2c_client *client;
 
 	/* remove I2C client for tuner */
@@ -1515,7 +1461,6 @@
 		module_put(client->dev.driver->owner);
 		i2c_unregister_device(client);
 	}
-
 	dvb_usb_device_exit(intf);
 }
 
@@ -1541,6 +1486,13 @@
 	CONEXANT_D680_DMB,
 	MYGICA_D689,
 	MYGICA_T230,
+	MYGICA_T230C,
+	MYGICA_T230C2,
+	MYGICA_X9330_0,
+	MYGICA_X9330_1,
+	MYGICA_X9330_2,
+	MYGICA_X9330_3,
+	EYETV_T2_LITE,
 	NR__cxusb_table_index
 };
 
@@ -1608,6 +1560,27 @@
 	[MYGICA_T230] = {
 		USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230)
 	},
+	[MYGICA_T230C] = {
+		USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230+1)
+	},
+	[MYGICA_T230C2] = {
+		USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230+2)
+	},
+	[MYGICA_X9330_0] = {
+		USB_DEVICE(USB_VID_GTEK, 0xd230)
+	},
+	[MYGICA_X9330_1] = {
+		USB_DEVICE(USB_VID_GTEK, 0xd231)
+	},
+	[MYGICA_X9330_2] = {
+		USB_DEVICE(USB_VID_GTEK, 0xd232)
+	},
+	[MYGICA_X9330_3] = {
+		USB_DEVICE(USB_VID_GTEK, 0xd233)
+	},
+	[EYETV_T2_LITE] = {
+		USB_DEVICE(USB_VID_CONEXANT, 0xc699)
+	},
 	{}		/* Terminating entry */
 };
 MODULE_DEVICE_TABLE (usb, cxusb_table);
@@ -1695,11 +1668,12 @@
 
 	.i2c_algo         = &cxusb_i2c_algo,
 
-	.rc.legacy = {
-		.rc_interval      = 100,
-		.rc_map_table     = rc_map_dvico_portable_table,
-		.rc_map_size      = ARRAY_SIZE(rc_map_dvico_portable_table),
-		.rc_query         = cxusb_rc_query,
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_DVICO_PORTABLE,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query	= cxusb_rc_query,
+		.allowed_protos = RC_PROTO_BIT_NEC,
 	},
 
 	.generic_bulk_ctrl_endpoint = 0x01,
@@ -1751,11 +1725,12 @@
 
 	.i2c_algo         = &cxusb_i2c_algo,
 
-	.rc.legacy = {
-		.rc_interval      = 150,
-		.rc_map_table     = rc_map_dvico_mce_table,
-		.rc_map_size      = ARRAY_SIZE(rc_map_dvico_mce_table),
-		.rc_query         = cxusb_rc_query,
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_DVICO_MCE,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query	= cxusb_rc_query,
+		.allowed_protos = RC_PROTO_BIT_NEC,
 	},
 
 	.generic_bulk_ctrl_endpoint = 0x01,
@@ -1815,11 +1790,12 @@
 
 	.i2c_algo         = &cxusb_i2c_algo,
 
-	.rc.legacy = {
-		.rc_interval      = 100,
-		.rc_map_table     = rc_map_dvico_portable_table,
-		.rc_map_size      = ARRAY_SIZE(rc_map_dvico_portable_table),
-		.rc_query         = cxusb_rc_query,
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_DVICO_PORTABLE,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query	= cxusb_rc_query,
+		.allowed_protos = RC_PROTO_BIT_NEC,
 	},
 
 	.generic_bulk_ctrl_endpoint = 0x01,
@@ -1870,11 +1846,12 @@
 
 	.i2c_algo         = &cxusb_i2c_algo,
 
-	.rc.legacy = {
-		.rc_interval      = 100,
-		.rc_map_table     = rc_map_dvico_portable_table,
-		.rc_map_size      = ARRAY_SIZE(rc_map_dvico_portable_table),
-		.rc_query         = cxusb_rc_query,
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_DVICO_PORTABLE,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query	= cxusb_rc_query,
+		.allowed_protos = RC_PROTO_BIT_NEC,
 	},
 
 	.generic_bulk_ctrl_endpoint = 0x01,
@@ -1924,11 +1901,12 @@
 
 	.generic_bulk_ctrl_endpoint = 0x01,
 
-	.rc.legacy = {
-		.rc_interval      = 100,
-		.rc_map_table     = rc_map_dvico_mce_table,
-		.rc_map_size      = ARRAY_SIZE(rc_map_dvico_mce_table),
-		.rc_query         = cxusb_bluebird2_rc_query,
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_DVICO_MCE,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query	= cxusb_bluebird2_rc_query,
+		.allowed_protos = RC_PROTO_BIT_NEC,
 	},
 
 	.num_device_descs = 1,
@@ -1977,11 +1955,12 @@
 
 	.generic_bulk_ctrl_endpoint = 0x01,
 
-	.rc.legacy = {
-		.rc_interval      = 100,
-		.rc_map_table     = rc_map_dvico_portable_table,
-		.rc_map_size      = ARRAY_SIZE(rc_map_dvico_portable_table),
-		.rc_query         = cxusb_bluebird2_rc_query,
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_DVICO_PORTABLE,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query       = cxusb_bluebird2_rc_query,
+		.allowed_protos = RC_PROTO_BIT_NEC,
 	},
 
 	.num_device_descs = 1,
@@ -2032,11 +2011,12 @@
 
 	.generic_bulk_ctrl_endpoint = 0x01,
 
-	.rc.legacy = {
-		.rc_interval      = 100,
-		.rc_map_table     = rc_map_dvico_portable_table,
-		.rc_map_size      = ARRAY_SIZE(rc_map_dvico_portable_table),
-		.rc_query         = cxusb_rc_query,
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_DVICO_PORTABLE,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query	= cxusb_rc_query,
+		.allowed_protos = RC_PROTO_BIT_NEC,
 	},
 
 	.num_device_descs = 1,
@@ -2130,11 +2110,12 @@
 
 	.generic_bulk_ctrl_endpoint = 0x01,
 
-	.rc.legacy = {
-		.rc_interval      = 100,
-		.rc_map_table     = rc_map_dvico_mce_table,
-		.rc_map_size      = ARRAY_SIZE(rc_map_dvico_mce_table),
-		.rc_query         = cxusb_rc_query,
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_DVICO_MCE,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query	= cxusb_rc_query,
+		.allowed_protos = RC_PROTO_BIT_NEC,
 	},
 
 	.num_device_descs = 1,
@@ -2183,11 +2164,12 @@
 
 	.generic_bulk_ctrl_endpoint = 0x01,
 
-	.rc.legacy = {
-		.rc_interval      = 100,
-		.rc_map_table     = rc_map_d680_dmb_table,
-		.rc_map_size      = ARRAY_SIZE(rc_map_d680_dmb_table),
-		.rc_query         = cxusb_d680_dmb_rc_query,
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_D680_DMB,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query       = cxusb_d680_dmb_rc_query,
+		.allowed_protos = RC_PROTO_BIT_UNKNOWN,
 	},
 
 	.num_device_descs = 1,
@@ -2237,11 +2219,12 @@
 
 	.generic_bulk_ctrl_endpoint = 0x01,
 
-	.rc.legacy = {
-		.rc_interval      = 100,
-		.rc_map_table     = rc_map_d680_dmb_table,
-		.rc_map_size      = ARRAY_SIZE(rc_map_d680_dmb_table),
-		.rc_query         = cxusb_d680_dmb_rc_query,
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_D680_DMB,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query       = cxusb_d680_dmb_rc_query,
+		.allowed_protos = RC_PROTO_BIT_UNKNOWN,
 	},
 
 	.num_device_descs = 1,
@@ -2290,20 +2273,105 @@
 
 	.generic_bulk_ctrl_endpoint = 0x01,
 
-	.rc.legacy = {
-		.rc_interval      = 100,
-		.rc_map_table     = rc_map_d680_dmb_table,
-		.rc_map_size      = ARRAY_SIZE(rc_map_d680_dmb_table),
-		.rc_query         = cxusb_d680_dmb_rc_query,
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_TOTAL_MEDIA_IN_HAND_02,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query       = cxusb_d680_dmb_rc_query,
+		.allowed_protos = RC_PROTO_BIT_UNKNOWN,
 	},
 
-	.num_device_descs = 1,
+	.num_device_descs = 5,
 	.devices = {
 		{
 			"Mygica T230 DVB-T/T2/C",
 			{ NULL },
 			{ &cxusb_table[MYGICA_T230], NULL },
 		},
+		{
+			"Geniatech T2 X9330-0 USB2.0",
+			{ NULL },
+			{ &cxusb_table[MYGICA_X9330_0], NULL },
+		},
+		{
+			"Geniatech T2 X9330-1 USB2.0",
+			{ NULL },
+			{ &cxusb_table[MYGICA_X9330_1], NULL },
+		},
+		{
+			"Geniatech T2 X9330-2 USB2.0",
+			{ NULL },
+			{ &cxusb_table[MYGICA_X9330_2], NULL },
+		},
+		{
+			"Geniatech T2 X9330-3 USB2.0",
+			{ NULL },
+			{ &cxusb_table[MYGICA_X9330_3], NULL },
+		},
+	}
+};
+
+static struct dvb_usb_device_properties cxusb_mygica_t230c_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+
+	.usb_ctrl         = CYPRESS_FX2,
+
+	.size_of_priv     = sizeof(struct cxusb_state),
+
+	.num_adapters = 1,
+	.adapter = {
+		{
+		.num_frontends = 1,
+		.fe = {{
+			.streaming_ctrl   = cxusb_streaming_ctrl,
+			.frontend_attach  = cxusb_mygica_t230c_frontend_attach,
+
+			/* parameter for the MPEG2-data transfer */
+			.stream = {
+				.type = USB_BULK,
+				.count = 5,
+				.endpoint = 0x02,
+				.u = {
+					.bulk = {
+						.buffersize = 8192,
+					}
+				}
+			},
+		} },
+		},
+	},
+
+	.power_ctrl       = cxusb_d680_dmb_power_ctrl,
+
+	.i2c_algo         = &cxusb_i2c_algo,
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+
+	.rc.core = {
+		.rc_interval	= 100,
+		.rc_codes	= RC_MAP_TOTAL_MEDIA_IN_HAND_02,
+		.module_name	= KBUILD_MODNAME,
+		.rc_query       = cxusb_d680_dmb_rc_query,
+		.allowed_protos = RC_PROTO_BIT_UNKNOWN,
+	},
+
+	.num_device_descs = 3,
+	.devices = {
+		{
+			"Mygica T230C DVB-T/T2/C",
+			{ NULL },
+			{ &cxusb_table[MYGICA_T230C], NULL },
+		},
+		{
+			"Mygica T230C2 DVB-T/T2/C",
+			{ NULL },
+			{ &cxusb_table[MYGICA_T230C2], NULL },
+		},
+		{
+			"EyeTV T2 lite",
+			{ NULL },
+			{ &cxusb_table[EYETV_T2_LITE], NULL },
+		},
 	}
 };
 
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/cxusb.h" "b/drivers/media/usb/dvb-usb/cxusb.h"
--- "a/drivers/media/usb/dvb-usb/cxusb.h"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/cxusb.h"	2017-12-07 05:52:26.000000000 +0800
@@ -37,6 +37,11 @@
 	struct i2c_client *i2c_client_tuner;
 
 	unsigned char data[MAX_XFER_SIZE];
+
+	struct mutex stream_mutex;
+	u8 last_lock;
+	int (*fe_read_status)(struct dvb_frontend *fe,
+		enum fe_status *status);
 };
 
 #endif
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/dib0700.h" "b/drivers/media/usb/dvb-usb/dib0700.h"
--- "a/drivers/media/usb/dvb-usb/dib0700.h"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/dib0700.h"	2017-12-07 05:52:26.000000000 +0800
@@ -64,7 +64,7 @@
 extern struct i2c_algorithm dib0700_i2c_algo;
 extern int dib0700_identify_state(struct usb_device *udev, struct dvb_usb_device_properties *props,
 			struct dvb_usb_device_description **desc, int *cold);
-extern int dib0700_change_protocol(struct rc_dev *dev, u64 *rc_type);
+extern int dib0700_change_protocol(struct rc_dev *dev, u64 *rc_proto);
 extern int dib0700_set_i2c_speed(struct dvb_usb_device *d, u16 scl_kHz);
 
 extern int dib0700_device_count;
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/dib0700_core.c" "b/drivers/media/usb/dvb-usb/dib0700_core.c"
--- "a/drivers/media/usb/dvb-usb/dib0700_core.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/dib0700_core.c"	2017-12-07 05:52:26.000000000 +0800
@@ -16,10 +16,7 @@
 static int nb_packet_buffer_size = 21;
 module_param(nb_packet_buffer_size, int, 0644);
 MODULE_PARM_DESC(nb_packet_buffer_size,
-	"Set the dib0700 driver data buffer size. This parameter "
-	"corresponds to the number of TS packets. The actual size of "
-	"the data buffer corresponds to this parameter "
-	"multiplied by 188 (default: 21)");
+	"Set the dib0700 driver data buffer size. This parameter corresponds to the number of TS packets. The actual size of the data buffer corresponds to this parameter multiplied by 188 (default: 21)");
 
 DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
@@ -218,13 +215,14 @@
 						 USB_CTRL_GET_TIMEOUT);
 			if (result < 0) {
 				deb_info("i2c read error (status = %d)\n", result);
-				break;
+				goto unlock;
 			}
 
 			if (msg[i].len > sizeof(st->buf)) {
 				deb_info("buffer too small to fit %d bytes\n",
 					 msg[i].len);
-				return -EIO;
+				result = -EIO;
+				goto unlock;
 			}
 
 			memcpy(msg[i].buf, st->buf, msg[i].len);
@@ -236,8 +234,8 @@
 			/* Write request */
 			if (mutex_lock_interruptible(&d->usb_mutex) < 0) {
 				err("could not acquire lock");
-				mutex_unlock(&d->i2c_mutex);
-				return -EINTR;
+				result = -EINTR;
+				goto unlock;
 			}
 			st->buf[0] = REQUEST_NEW_I2C_WRITE;
 			st->buf[1] = msg[i].addr << 1;
@@ -250,7 +248,9 @@
 			if (msg[i].len > sizeof(st->buf) - 4) {
 				deb_info("i2c message to big: %d\n",
 					 msg[i].len);
-				return -EIO;
+				mutex_unlock(&d->usb_mutex);
+				result = -EIO;
+				goto unlock;
 			}
 
 			/* The Actual i2c payload */
@@ -272,8 +272,11 @@
 			}
 		}
 	}
+	result = i;
+
+unlock:
 	mutex_unlock(&d->i2c_mutex);
-	return i;
+	return result;
 }
 
 /*
@@ -284,7 +287,7 @@
 {
 	struct dvb_usb_device *d = i2c_get_adapdata(adap);
 	struct dib0700_state *st = d->priv;
-	int i,len;
+	int i, len, result;
 
 	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
 		return -EINTR;
@@ -301,7 +304,8 @@
 		if (msg[i].len > sizeof(st->buf) - 2) {
 			deb_info("i2c xfer to big: %d\n",
 				msg[i].len);
-			return -EIO;
+			result = -EIO;
+			goto unlock;
 		}
 		memcpy(&st->buf[2], msg[i].buf, msg[i].len);
 
@@ -316,13 +320,15 @@
 			if (len <= 0) {
 				deb_info("I2C read failed on address 0x%02x\n",
 						msg[i].addr);
-				break;
+				result = -EIO;
+				goto unlock;
 			}
 
 			if (msg[i + 1].len > sizeof(st->buf)) {
 				deb_info("i2c xfer buffer to small for %d\n",
 					msg[i].len);
-				return -EIO;
+				result = -EIO;
+				goto unlock;
 			}
 			memcpy(msg[i + 1].buf, st->buf, msg[i + 1].len);
 
@@ -331,14 +337,17 @@
 			i++;
 		} else {
 			st->buf[0] = REQUEST_I2C_WRITE;
-			if (dib0700_ctrl_wr(d, st->buf, msg[i].len + 2) < 0)
-				break;
+			result = dib0700_ctrl_wr(d, st->buf, msg[i].len + 2);
+			if (result < 0)
+				goto unlock;
 		}
 	}
+	result = i;
+unlock:
 	mutex_unlock(&d->usb_mutex);
 	mutex_unlock(&d->i2c_mutex);
 
-	return i;
+	return result;
 }
 
 static int dib0700_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,
@@ -629,7 +638,7 @@
 	return ret;
 }
 
-int dib0700_change_protocol(struct rc_dev *rc, u64 *rc_type)
+int dib0700_change_protocol(struct rc_dev *rc, u64 *rc_proto)
 {
 	struct dvb_usb_device *d = rc->priv;
 	struct dib0700_state *st = d->priv;
@@ -645,19 +654,19 @@
 	st->buf[2] = 0;
 
 	/* Set the IR mode */
-	if (*rc_type & RC_BIT_RC5) {
+	if (*rc_proto & RC_PROTO_BIT_RC5) {
 		new_proto = 1;
-		*rc_type = RC_BIT_RC5;
-	} else if (*rc_type & RC_BIT_NEC) {
+		*rc_proto = RC_PROTO_BIT_RC5;
+	} else if (*rc_proto & RC_PROTO_BIT_NEC) {
 		new_proto = 0;
-		*rc_type = RC_BIT_NEC;
-	} else if (*rc_type & RC_BIT_RC6_MCE) {
+		*rc_proto = RC_PROTO_BIT_NEC;
+	} else if (*rc_proto & RC_PROTO_BIT_RC6_MCE) {
 		if (st->fw_version < 0x10200) {
 			ret = -EINVAL;
 			goto out;
 		}
 		new_proto = 2;
-		*rc_type = RC_BIT_RC6_MCE;
+		*rc_proto = RC_PROTO_BIT_RC6_MCE;
 	} else {
 		ret = -EINVAL;
 		goto out;
@@ -671,7 +680,7 @@
 		goto out;
 	}
 
-	d->props.rc.core.protocol = *rc_type;
+	d->props.rc.core.protocol = *rc_proto;
 
 out:
 	mutex_unlock(&d->usb_mutex);
@@ -703,7 +712,7 @@
 {
 	struct dvb_usb_device *d = purb->context;
 	struct dib0700_rc_response *poll_reply;
-	enum rc_type protocol;
+	enum rc_proto protocol;
 	u32 keycode;
 	u8 toggle;
 
@@ -736,7 +745,7 @@
 		 purb->actual_length);
 
 	switch (d->props.rc.core.protocol) {
-	case RC_BIT_NEC:
+	case RC_PROTO_BIT_NEC:
 		toggle = 0;
 
 		/* NEC protocol sends repeat code as 0 0 0 FF */
@@ -755,25 +764,25 @@
 						     poll_reply->nec.not_system << 16 |
 						     poll_reply->nec.data       << 8  |
 						     poll_reply->nec.not_data);
-			protocol = RC_TYPE_NEC32;
+			protocol = RC_PROTO_NEC32;
 		} else if ((poll_reply->nec.system ^ poll_reply->nec.not_system) != 0xff) {
 			deb_data("NEC extended protocol\n");
 			keycode = RC_SCANCODE_NECX(poll_reply->nec.system << 8 |
 						    poll_reply->nec.not_system,
 						    poll_reply->nec.data);
 
-			protocol = RC_TYPE_NECX;
+			protocol = RC_PROTO_NECX;
 		} else {
 			deb_data("NEC normal protocol\n");
 			keycode = RC_SCANCODE_NEC(poll_reply->nec.system,
 						   poll_reply->nec.data);
-			protocol = RC_TYPE_NEC;
+			protocol = RC_PROTO_NEC;
 		}
 
 		break;
 	default:
 		deb_data("RC5 protocol\n");
-		protocol = RC_TYPE_RC5;
+		protocol = RC_PROTO_RC5;
 		toggle = poll_reply->report_id;
 		keycode = RC_SCANCODE_RC5(poll_reply->rc5.system, poll_reply->rc5.data);
 
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/dib0700_devices.c" "b/drivers/media/usb/dvb-usb/dib0700_devices.c"
--- "a/drivers/media/usb/dvb-usb/dib0700_devices.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/dib0700_devices.c"	2017-12-07 05:52:26.000000000 +0800
@@ -26,8 +26,7 @@
 
 static int force_lna_activation;
 module_param(force_lna_activation, int, 0644);
-MODULE_PARM_DESC(force_lna_activation, "force the activation of Low-Noise-Amplifyer(s) (LNA), "
-		"if applicable for the device (default: 0=automatic/off).");
+MODULE_PARM_DESC(force_lna_activation, "force the activation of Low-Noise-Amplifyer(s) (LNA), if applicable for the device (default: 0=automatic/off).");
 
 struct dib0700_adapter_state {
 	int (*set_param_save) (struct dvb_frontend *);
@@ -515,7 +514,7 @@
  */
 static int dib0700_rc_query_old_firmware(struct dvb_usb_device *d)
 {
-	enum rc_type protocol;
+	enum rc_proto protocol;
 	u32 scancode;
 	u8 toggle;
 	int i;
@@ -548,7 +547,7 @@
 	dib0700_rc_setup(d, NULL); /* reset ir sensor data to prevent false events */
 
 	switch (d->props.rc.core.protocol) {
-	case RC_BIT_NEC:
+	case RC_PROTO_BIT_NEC:
 		/* NEC protocol sends repeat code as 0 0 0 FF */
 		if ((st->buf[3 - 2] == 0x00) && (st->buf[3 - 3] == 0x00) &&
 		    (st->buf[3] == 0xff)) {
@@ -556,14 +555,14 @@
 			return 0;
 		}
 
-		protocol = RC_TYPE_NEC;
+		protocol = RC_PROTO_NEC;
 		scancode = RC_SCANCODE_NEC(st->buf[3 - 2], st->buf[3 - 3]);
 		toggle = 0;
 		break;
 
 	default:
 		/* RC-5 protocol changes toggle bit on new keypress */
-		protocol = RC_TYPE_RC5;
+		protocol = RC_PROTO_RC5;
 		scancode = RC_SCANCODE_RC5(st->buf[3 - 2], st->buf[3 - 3]);
 		toggle = st->buf[3 - 1];
 		break;
@@ -1660,6 +1659,7 @@
 	switch (band) {
 	default:
 			deb_info("Warning : Rf frequency  (%iHz) is not in the supported range, using VHF switch ", fe->dtv_property_cache.frequency);
+			/* fall through */
 	case BAND_VHF:
 			state->dib8000_ops.set_gpio(fe, 3, 0, 1);
 			break;
@@ -2415,7 +2415,7 @@
 		deb_info("%s: Upload failed. (file not found?)\n", __func__);
 		return -ENODEV;
 	} else {
-		deb_info("%s: firmware read %Zu bytes.\n", __func__, state->frontend_firmware->size);
+		deb_info("%s: firmware read %zu bytes.\n", __func__, state->frontend_firmware->size);
 	}
 	stk9090m_config.microcode_B_fe_size = state->frontend_firmware->size;
 	stk9090m_config.microcode_B_fe_buffer = state->frontend_firmware->data;
@@ -2481,7 +2481,7 @@
 		deb_info("%s: Upload failed. (file not found?)\n", __func__);
 		return -EIO;
 	} else {
-		deb_info("%s: firmware read %Zu bytes.\n", __func__, state->frontend_firmware->size);
+		deb_info("%s: firmware read %zu bytes.\n", __func__, state->frontend_firmware->size);
 	}
 	nim9090md_config[0].microcode_B_fe_size = state->frontend_firmware->size;
 	nim9090md_config[0].microcode_B_fe_buffer = state->frontend_firmware->data;
@@ -3816,6 +3816,7 @@
 	{ USB_DEVICE(USB_VID_PCTV,      USB_PID_PCTV_2002E_SE) },
 	{ USB_DEVICE(USB_VID_PCTV,      USB_PID_DIBCOM_STK8096PVR) },
 	{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_STK8096PVR) },
+	{ USB_DEVICE(USB_VID_HAMA,	USB_PID_HAMA_DVBT_HYBRID) },
 	{ 0 }		/* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, dib0700_usb_id_table);
@@ -3908,9 +3909,9 @@
 			.rc_interval      = DEFAULT_RC_INTERVAL,
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -3948,9 +3949,9 @@
 			.rc_interval      = DEFAULT_RC_INTERVAL,
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4013,9 +4014,9 @@
 			.rc_interval      = DEFAULT_RC_INTERVAL,
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4058,9 +4059,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4139,9 +4140,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4184,9 +4185,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4241,9 +4242,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4307,9 +4308,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4356,9 +4357,9 @@
 			.rc_codes         = RC_MAP_DIB0700_NEC_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4380,7 +4381,7 @@
 			},
 		},
 
-		.num_device_descs = 9,
+		.num_device_descs = 10,
 		.devices = {
 			{   "Terratec Cinergy HT USB XE",
 				{ &dib0700_usb_id_table[27], NULL },
@@ -4418,6 +4419,10 @@
 				{ &dib0700_usb_id_table[54], NULL },
 				{ NULL },
 			},
+			{   "Hama DVB=T Hybrid USB Stick",
+				{ &dib0700_usb_id_table[85], NULL },
+				{ NULL },
+			},
 		},
 
 		.rc.core = {
@@ -4425,9 +4430,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4461,9 +4466,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4537,9 +4542,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4581,9 +4586,9 @@
 			.rc_codes         = RC_MAP_DIB0700_NEC_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4630,9 +4635,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4667,9 +4672,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4704,9 +4709,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4741,9 +4746,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4778,9 +4783,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4815,9 +4820,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4866,9 +4871,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4901,9 +4906,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4938,9 +4943,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4976,9 +4981,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -5030,9 +5035,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-				RC_BIT_RC6_MCE |
-				RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+				RC_PROTO_BIT_RC6_MCE |
+				RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	},
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/dvb-usb-dvb.c" "b/drivers/media/usb/dvb-usb/dvb-usb-dvb.c"
--- "a/drivers/media/usb/dvb-usb/dvb-usb-dvb.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/dvb-usb-dvb.c"	2018-01-17 18:21:59.329683000 +0800
@@ -314,6 +314,22 @@
 				return 0;
 		}
 
+		if(adap->fe_adap[i].fe2!=NULL){
+			if (dvb_register_frontend(&adap->dvb_adap, adap->fe_adap[i].fe2)) {
+				err("Frontend %d registration failed.", i);
+				dvb_frontend_detach(adap->fe_adap[i].fe2);
+				adap->fe_adap[i].fe2 = NULL;
+				/* In error case, do not try register more FEs,
+				 * still leaving already registered FEs alive. */
+				if (i == 0)
+					return -ENODEV;
+				else
+					return 0;
+			}
+
+
+		}
+			
 		/* only attach the tuner if the demod is there */
 		if (adap->props.fe[i].tuner_attach != NULL)
 			adap->props.fe[i].tuner_attach(adap);
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/dvb-usb.h" "b/drivers/media/usb/dvb-usb/dvb-usb.h"
--- "a/drivers/media/usb/dvb-usb/dvb-usb.h"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/dvb-usb.h"	2017-12-07 05:52:26.000000000 +0800
@@ -202,11 +202,12 @@
 	u64 protocol;
 	u64 allowed_protos;
 	enum rc_driver_type driver_type;
-	int (*change_protocol)(struct rc_dev *dev, u64 *rc_type);
+	int (*change_protocol)(struct rc_dev *dev, u64 *rc_proto);
 	char *module_name;
 	int (*rc_query) (struct dvb_usb_device *d);
 	int rc_interval;
 	bool bulk_mode;				/* uses bulk mode */
+	u32 scancode_mask;
 };
 
 /**
@@ -357,7 +358,8 @@
  */
 struct dvb_usb_fe_adapter {
 	struct dvb_frontend *fe;
-
+	struct dvb_frontend *fe2;
+	struct dvb_frontend _fe2;
 	int (*fe_init)  (struct dvb_frontend *);
 	int (*fe_sleep) (struct dvb_frontend *);
 
@@ -467,8 +469,10 @@
 extern void dvb_usb_device_exit(struct usb_interface *);
 
 /* the generic read/write method for device control */
-extern int dvb_usb_generic_rw(struct dvb_usb_device *, u8 *, u16, u8 *, u16,int);
-extern int dvb_usb_generic_write(struct dvb_usb_device *, u8 *, u16);
+extern int __must_check
+dvb_usb_generic_rw(struct dvb_usb_device *, u8 *, u16, u8 *, u16, int);
+extern int __must_check
+dvb_usb_generic_write(struct dvb_usb_device *, u8 *, u16);
 
 /* commonly used remote control parsing */
 extern int dvb_usb_nec_rc_key_to_event(struct dvb_usb_device *, u8[], u32 *, int *);
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/dw2102.c" "b/drivers/media/usb/dvb-usb/dw2102.c"
--- "a/drivers/media/usb/dvb-usb/dw2102.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/dw2102.c"	2017-12-07 05:52:26.000000000 +0800
@@ -2,7 +2,7 @@
  *	DVBWorld DVB-S 2101, 2102, DVB-S2 2104, DVB-C 3101,
  *	TeVii S421, S480, S482, S600, S630, S632, S650, S660, S662,
  *	Prof 1100, 7500,
- *	Geniatech SU3000, T220,
+ *	Geniatech SU3000, T220/220A,
  *	TechnoTrend S2-4600,
  *	Terratec Cinergy S2 cards
  * Copyright (C) 2008-2012 Igor M. Liplianin (liplianin@me.by)
@@ -35,6 +35,7 @@
 #include "tda18271.h"
 #include "cxd2820r.h"
 #include "m88ds3103.h"
+#include "tda18273.h"
 
 /* Max transfer size done by I2C transfer functions */
 #define MAX_XFER_SIZE  64
@@ -87,8 +88,7 @@
 /* demod probe */
 static int demod_probe = 1;
 module_param_named(demod, demod_probe, int, 0644);
-MODULE_PARM_DESC(demod, "demod to probe (1=cx24116 2=stv0903+stv6110 "
-			"4=stv0903+stb6100(or-able)).");
+MODULE_PARM_DESC(demod, "demod to probe (1=cx24116 2=stv0903+stv6110 4=stv0903+stb6100(or-able)).");
 
 DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
@@ -971,6 +971,24 @@
 	return 0;
 }
 
+static int su3000_read_status(struct dvb_frontend *fe,
+				  enum fe_status *status)
+{
+	struct dvb_usb_adapter *d =
+		(struct dvb_usb_adapter *)(fe->dvb->priv);
+	struct dw2102_state *st = (struct dw2102_state *)d->dev->priv;
+	int ret;
+
+	ret = st->fe_read_status(fe, status);
+
+	/* resync slave fifo when signal change from unlock to lock */
+	if ((*status & FE_HAS_LOCK) && (!st->last_lock))
+		su3000_streaming_ctrl(d, 1);
+
+	st->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;
+	return ret;
+}
+
 static int dw210x_set_voltage(struct dvb_frontend *fe,
 			      enum fe_sec_voltage voltage)
 {
@@ -1028,24 +1046,6 @@
 	i2c_transfer(&udev_adap->dev->i2c_adap, &msg, 1);
 }
 
-static int tt_s2_4600_read_status(struct dvb_frontend *fe,
-				  enum fe_status *status)
-{
-	struct dvb_usb_adapter *d =
-		(struct dvb_usb_adapter *)(fe->dvb->priv);
-	struct dw2102_state *st = (struct dw2102_state *)d->dev->priv;
-	int ret;
-
-	ret = st->fe_read_status(fe, status);
-
-	/* resync slave fifo when signal change from unlock to lock */
-	if ((*status & FE_HAS_LOCK) && (!st->last_lock))
-		su3000_streaming_ctrl(d, 1);
-
-	st->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;
-	return ret;
-}
-
 static struct stv0299_config sharp_z0194a_config = {
 	.demod_address = 0x68,
 	.inittab = sharp_z0194a_inittab,
@@ -1385,12 +1385,17 @@
 {
 	struct dvb_usb_device *d = adap->dev;
 	struct dw2102_state *state = d->priv;
+	struct i2c_adapter *i2c_adapter;
+	struct i2c_client *client;
+	struct i2c_board_info board_info;
+	struct m88ds3103_platform_data m88ds3103_pdata = {};
+	struct ts2020_config ts2020_config = {};
 
 	mutex_lock(&d->data_mutex);
 
 	state->data[0] = 0xe;
 	state->data[1] = 0x80;
-	state->data[2] = 0;
+	state->data[2] = 0x0;
 
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err("command 0x0e transfer failed.");
@@ -1424,20 +1429,85 @@
 
 	mutex_unlock(&d->data_mutex);
 
+	/* First try ds300x version */
 	adap->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,
 					&d->i2c_adap);
 	if (adap->fe_adap[0].fe == NULL)
-		return -EIO;
+		goto attach2;
 
-	if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
+	if (!dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
 				&dw2104_ts2020_config,
 				&d->i2c_adap)) {
-		info("Attached DS3000/TS2020!");
-		return 0;
+		dvb_frontend_detach(adap->fe_adap[0].fe);
+		return -ENODEV;
 	}
+	goto attach3;
 
-	info("Failed to attach DS3000/TS2020!");
-	return -EIO;
+attach2:
+	/* attach demod */
+	m88ds3103_pdata.clk = 27000000;
+	m88ds3103_pdata.i2c_wr_max = 33;
+	m88ds3103_pdata.ts_mode = M88DS3103_TS_CI;
+	m88ds3103_pdata.ts_clk = 16000;
+	m88ds3103_pdata.ts_clk_pol = 0;
+	m88ds3103_pdata.spec_inv = 0;
+	m88ds3103_pdata.agc = 0x99;
+	m88ds3103_pdata.agc_inv = 0;
+	m88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;
+	m88ds3103_pdata.envelope_mode = 0;
+	m88ds3103_pdata.lnb_hv_pol = 1;
+	m88ds3103_pdata.lnb_en_pol = 0;
+	memset(&board_info, 0, sizeof(board_info));
+	strlcpy(board_info.type, "m88ds3103", I2C_NAME_SIZE);
+	board_info.addr = 0x68;
+	board_info.platform_data = &m88ds3103_pdata;
+	request_module("m88ds3103");
+	client = i2c_new_device(&d->i2c_adap, &board_info);
+	if (client == NULL || client->dev.driver == NULL)
+		return -ENODEV;
+	if (!try_module_get(client->dev.driver->owner)) {
+		i2c_unregister_device(client);
+		return -ENODEV;
+	}
+	adap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);
+	i2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);
+
+	state->i2c_client_demod = client;
+
+	/* attach tuner */
+	ts2020_config.fe = adap->fe_adap[0].fe;
+	memset(&board_info, 0, sizeof(board_info));
+	strlcpy(board_info.type, "ts2022", I2C_NAME_SIZE);
+	board_info.addr = 0x60;
+	board_info.platform_data = &ts2020_config;
+	request_module("ts2020");
+	client = i2c_new_device(i2c_adapter, &board_info);
+
+	if (client == NULL || client->dev.driver == NULL) {
+		dvb_frontend_detach(adap->fe_adap[0].fe);
+		return -ENODEV;
+	}
+
+	if (!try_module_get(client->dev.driver->owner)) {
+		i2c_unregister_device(client);
+		dvb_frontend_detach(adap->fe_adap[0].fe);
+		return -ENODEV;
+	}
+
+	/* delegate signal strength measurement to tuner */
+	adap->fe_adap[0].fe->ops.read_signal_strength =
+			adap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;
+
+	state->i2c_client_tuner = client;
+
+attach3:
+	/* hook fe: need to resync the slave fifo when signal locks */
+	state->fe_read_status = adap->fe_adap[0].fe->ops.read_status;
+	adap->fe_adap[0].fe->ops.read_status = su3000_read_status;
+
+	state->last_lock = 0;
+
+	return 0;
 }
 
 static int t220_frontend_attach(struct dvb_usb_adapter *adap)
@@ -1486,86 +1556,52 @@
 
 	adap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,
 					&d->i2c_adap, NULL);
-	if (adap->fe_adap[0].fe != NULL) {
-		if (dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,
-					&d->i2c_adap, &tda18271_config)) {
-			info("Attached TDA18271HD/CXD2820R!");
-			return 0;
-		}
-	}
-
-	info("Failed to attach TDA18271HD/CXD2820R!");
-	return -EIO;
-}
-
-static int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap)
-{
-	struct dvb_usb_device *d = adap->dev;
-	struct dw2102_state *state = d->priv;
-
-	mutex_lock(&d->data_mutex);
-
-	state->data[0] = 0x51;
-
-	if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
-		err("command 0x51 transfer failed.");
-
-	mutex_unlock(&d->data_mutex);
-
-	adap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,
-					&s421_m88rs2000_config,
-					&d->i2c_adap);
-
 	if (adap->fe_adap[0].fe == NULL)
 		return -EIO;
 
-	if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
-				&dw2104_ts2020_config,
-				&d->i2c_adap)) {
-		info("Attached RS2000/TS2020!");
-		return 0;
-	}
+	if (!dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,
+		&d->i2c_adap, &tda18271_config))
+		return -EIO;
 
-	info("Failed to attach RS2000/TS2020!");
-	return -EIO;
+	/* hook fe: need to resync the slave fifo when signal locks */
+	state->fe_read_status = adap->fe_adap[0].fe->ops.read_status;
+	adap->fe_adap[0].fe->ops.read_status = su3000_read_status;
+
+	return 0;
 }
 
-static int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)
+static int t220a_frontend_attach(struct dvb_usb_adapter *adap)
 {
 	struct dvb_usb_device *d = adap->dev;
 	struct dw2102_state *state = d->priv;
-	struct i2c_adapter *i2c_adapter;
-	struct i2c_client *client;
-	struct i2c_board_info board_info;
-	struct m88ds3103_platform_data m88ds3103_pdata = {};
-	struct ts2020_config ts2020_config = {};
 
 	mutex_lock(&d->data_mutex);
 
 	state->data[0] = 0xe;
-	state->data[1] = 0x80;
+	state->data[1] = 0x87;
 	state->data[2] = 0x0;
 
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err("command 0x0e transfer failed.");
 
 	state->data[0] = 0xe;
-	state->data[1] = 0x02;
+	state->data[1] = 0x86;
 	state->data[2] = 1;
 
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err("command 0x0e transfer failed.");
-	msleep(300);
 
 	state->data[0] = 0xe;
-	state->data[1] = 0x83;
+	state->data[1] = 0x80;
 	state->data[2] = 0;
 
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err("command 0x0e transfer failed.");
 
+	msleep(50);
+
 	state->data[0] = 0xe;
-	state->data[1] = 0x83;
+	state->data[1] = 0x80;
 	state->data[2] = 1;
 
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
@@ -1578,69 +1614,52 @@
 
 	mutex_unlock(&d->data_mutex);
 
-	/* attach demod */
-	m88ds3103_pdata.clk = 27000000;
-	m88ds3103_pdata.i2c_wr_max = 33;
-	m88ds3103_pdata.ts_mode = M88DS3103_TS_CI;
-	m88ds3103_pdata.ts_clk = 16000;
-	m88ds3103_pdata.ts_clk_pol = 0;
-	m88ds3103_pdata.spec_inv = 0;
-	m88ds3103_pdata.agc = 0x99;
-	m88ds3103_pdata.agc_inv = 0;
-	m88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;
-	m88ds3103_pdata.envelope_mode = 0;
-	m88ds3103_pdata.lnb_hv_pol = 1;
-	m88ds3103_pdata.lnb_en_pol = 0;
-	memset(&board_info, 0, sizeof(board_info));
-	strlcpy(board_info.type, "m88ds3103", I2C_NAME_SIZE);
-	board_info.addr = 0x68;
-	board_info.platform_data = &m88ds3103_pdata;
-	request_module("m88ds3103");
-	client = i2c_new_device(&d->i2c_adap, &board_info);
-	if (client == NULL || client->dev.driver == NULL)
-		return -ENODEV;
-	if (!try_module_get(client->dev.driver->owner)) {
-		i2c_unregister_device(client);
-		return -ENODEV;
-	}
-	adap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);
-	i2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);
+	adap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,
+					&d->i2c_adap, NULL);
+	if (adap->fe_adap[0].fe == NULL)
+		return -EIO;
 
-	state->i2c_client_demod = client;
+	if (!dvb_attach(tda18273_attach, adap->fe_adap[0].fe,
+				&d->i2c_adap, 0x60))
+		return -EIO;
 
-	/* attach tuner */
-	ts2020_config.fe = adap->fe_adap[0].fe;
-	memset(&board_info, 0, sizeof(board_info));
-	strlcpy(board_info.type, "ts2022", I2C_NAME_SIZE);
-	board_info.addr = 0x60;
-	board_info.platform_data = &ts2020_config;
-	request_module("ts2020");
-	client = i2c_new_device(i2c_adapter, &board_info);
+	/* hook fe: need to resync the slave fifo when signal locks */
+	state->fe_read_status = adap->fe_adap[0].fe->ops.read_status;
+	adap->fe_adap[0].fe->ops.read_status = su3000_read_status;
 
-	if (client == NULL || client->dev.driver == NULL) {
-		dvb_frontend_detach(adap->fe_adap[0].fe);
-		return -ENODEV;
-	}
+	return 0;
+}
 
-	if (!try_module_get(client->dev.driver->owner)) {
-		i2c_unregister_device(client);
-		dvb_frontend_detach(adap->fe_adap[0].fe);
-		return -ENODEV;
-	}
+static int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	struct dvb_usb_device *d = adap->dev;
+	struct dw2102_state *state = d->priv;
 
-	/* delegate signal strength measurement to tuner */
-	adap->fe_adap[0].fe->ops.read_signal_strength =
-			adap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;
+	mutex_lock(&d->data_mutex);
 
-	state->i2c_client_tuner = client;
+	state->data[0] = 0x51;
 
-	/* hook fe: need to resync the slave fifo when signal locks */
-	state->fe_read_status = adap->fe_adap[0].fe->ops.read_status;
-	adap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;
+	if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
+		err("command 0x51 transfer failed.");
 
-	state->last_lock = 0;
+	mutex_unlock(&d->data_mutex);
 
-	return 0;
+	adap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,
+					&s421_m88rs2000_config,
+					&d->i2c_adap);
+
+	if (adap->fe_adap[0].fe == NULL)
+		return -EIO;
+
+	if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
+				&dw2104_ts2020_config,
+				&d->i2c_adap)) {
+		info("Attached RS2000/TS2020!");
+		return 0;
+	}
+
+	info("Failed to attach RS2000/TS2020!");
+	return -EIO;
 }
 
 static int dw2102_tuner_attach(struct dvb_usb_adapter *adap)
@@ -1672,7 +1691,7 @@
 		if (msg.buf[0] != 0xff) {
 			deb_rc("%s: rc code: %x, %x\n",
 					__func__, key[0], key[1]);
-			rc_keydown(d->rc_dev, RC_TYPE_UNKNOWN, key[0], 0);
+			rc_keydown(d->rc_dev, RC_PROTO_UNKNOWN, key[0], 0);
 		}
 	}
 
@@ -1693,7 +1712,8 @@
 		if (msg.buf[0] != 0xff) {
 			deb_rc("%s: rc code: %x, %x\n",
 					__func__, key[0], key[1]);
-			rc_keydown(d->rc_dev, RC_TYPE_UNKNOWN, key[0]^0xff, 0);
+			rc_keydown(d->rc_dev, RC_PROTO_UNKNOWN, key[0] ^ 0xff,
+				   0);
 		}
 	}
 
@@ -1714,7 +1734,7 @@
 		if (msg.buf[0] != 0xff) {
 			deb_rc("%s: rc code: %x, %x\n",
 					__func__, key[0], key[1]);
-			rc_keydown(d->rc_dev, RC_TYPE_RC5,
+			rc_keydown(d->rc_dev, RC_PROTO_RC5,
 				   RC_SCANCODE_RC5(key[1], key[0]), 0);
 		}
 	}
@@ -1742,13 +1762,20 @@
 	TEVII_S632,
 	TERRATEC_CINERGY_S2_R2,
 	TERRATEC_CINERGY_S2_R3,
+	TERRATEC_CINERGY_S2_R4,
 	GOTVIEW_SAT_HD,
 	GENIATECH_T220,
+	GENIATECH_T220A,
 	TECHNOTREND_S2_4600,
 	TEVII_S482_1,
 	TEVII_S482_2,
-	TERRATEC_CINERGY_S2_BOX,
-	TEVII_S662
+	TERRATEC_DUAL_1,
+	TERRATEC_DUAL_2,
+	TEVII_S662,
+	GENIATECH_X9320_0,
+	GENIATECH_X9320_1,
+	GENIATECH_X9320_2,
+	GENIATECH_X9320_3,
 };
 
 static struct usb_device_id dw2102_table[] = {
@@ -1762,23 +1789,30 @@
 	[PROF_1100] = {USB_DEVICE(0x3011, USB_PID_PROF_1100)},
 	[TEVII_S660] = {USB_DEVICE(0x9022, USB_PID_TEVII_S660)},
 	[PROF_7500] = {USB_DEVICE(0x3034, 0x7500)},
-	[GENIATECH_SU3000] = {USB_DEVICE(0x1f4d, 0x3000)},
+	[GENIATECH_SU3000] = {USB_DEVICE(USB_VID_GTEK, 0x3000)},
 	[TERRATEC_CINERGY_S2] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R1)},
 	[TEVII_S480_1] = {USB_DEVICE(0x9022, USB_PID_TEVII_S480_1)},
 	[TEVII_S480_2] = {USB_DEVICE(0x9022, USB_PID_TEVII_S480_2)},
-	[X3M_SPC1400HD] = {USB_DEVICE(0x1f4d, 0x3100)},
+	[X3M_SPC1400HD] = {USB_DEVICE(USB_VID_GTEK, 0x3100)},
 	[TEVII_S421] = {USB_DEVICE(0x9022, USB_PID_TEVII_S421)},
 	[TEVII_S632] = {USB_DEVICE(0x9022, USB_PID_TEVII_S632)},
 	[TERRATEC_CINERGY_S2_R2] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R2)},
 	[TERRATEC_CINERGY_S2_R3] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R3)},
+	[TERRATEC_CINERGY_S2_R4] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R4)},
 	[GOTVIEW_SAT_HD] = {USB_DEVICE(0x1FE1, USB_PID_GOTVIEW_SAT_HD)},
-	[GENIATECH_T220] = {USB_DEVICE(0x1f4d, 0xD220)},
+	[GENIATECH_T220] = {USB_DEVICE(USB_VID_GTEK, 0xD220)},
+	[GENIATECH_T220A] = {USB_DEVICE(0x0572, 0xC686)},
 	[TECHNOTREND_S2_4600] = {USB_DEVICE(USB_VID_TECHNOTREND,
 		USB_PID_TECHNOTREND_CONNECT_S2_4600)},
 	[TEVII_S482_1] = {USB_DEVICE(0x9022, 0xd483)},
 	[TEVII_S482_2] = {USB_DEVICE(0x9022, 0xd484)},
-	[TERRATEC_CINERGY_S2_BOX] = {USB_DEVICE(USB_VID_TERRATEC, 0x0105)},
+	[TERRATEC_DUAL_1] = {USB_DEVICE(0x153B,0x1181)},
+	[TERRATEC_DUAL_2] = {USB_DEVICE(0x153B,0x1182)},
 	[TEVII_S662] = {USB_DEVICE(0x9022, USB_PID_TEVII_S662)},
+	[GENIATECH_X9320_0] = {USB_DEVICE(USB_VID_GTEK, 0x3300)},
+	[GENIATECH_X9320_1] = {USB_DEVICE(USB_VID_GTEK, 0x3301)},
+	[GENIATECH_X9320_2] = {USB_DEVICE(USB_VID_GTEK, 0x3302)},
+	[GENIATECH_X9320_3] = {USB_DEVICE(USB_VID_GTEK, 0x3303)},
 	{ }
 };
 
@@ -1839,11 +1873,12 @@
 		switch (le16_to_cpu(dev->descriptor.idProduct)) {
 		case USB_PID_TEVII_S650:
 			dw2104_properties.rc.core.rc_codes = RC_MAP_TEVII_NEC;
+			/* fall through */
 		case USB_PID_DW2104:
 			reset = 1;
 			dw210x_op_rw(dev, 0xc4, 0x0000, 0, &reset, 1,
 					DW210X_WRITE_MSG);
-			/* break omitted intentionally */
+			/* fall through */
 		case USB_PID_DW3101:
 			reset = 0;
 			dw210x_op_rw(dev, 0xbf, 0x0040, 0, &reset, 0,
@@ -1876,6 +1911,7 @@
 					break;
 				}
 			}
+			/* fall through */
 		case 0x2101:
 			dw210x_op_rw(dev, 0xbc, 0x0030, 0, &reset16[0], 2,
 					DW210X_READ_MSG);
@@ -1909,7 +1945,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_DM1105_NEC,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_NEC,
+		.allowed_protos   = RC_PROTO_BIT_NEC,
 		.rc_query = dw2102_rc_query,
 	},
 
@@ -1964,7 +2000,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_DM1105_NEC,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_NEC,
+		.allowed_protos   = RC_PROTO_BIT_NEC,
 		.rc_query = dw2102_rc_query,
 	},
 
@@ -2015,7 +2051,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_DM1105_NEC,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_NEC,
+		.allowed_protos   = RC_PROTO_BIT_NEC,
 		.rc_query = dw2102_rc_query,
 	},
 
@@ -2064,7 +2100,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_TEVII_NEC,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_NEC,
+		.allowed_protos   = RC_PROTO_BIT_NEC,
 		.rc_query = dw2102_rc_query,
 	},
 
@@ -2100,46 +2136,46 @@
 };
 
 static struct dvb_usb_device_properties *p1100;
-static struct dvb_usb_device_description d1100 = {
+static const struct dvb_usb_device_description d1100 = {
 	"Prof 1100 USB ",
 	{&dw2102_table[PROF_1100], NULL},
 	{NULL},
 };
 
 static struct dvb_usb_device_properties *s660;
-static struct dvb_usb_device_description d660 = {
+static const struct dvb_usb_device_description d660 = {
 	"TeVii S660 USB",
 	{&dw2102_table[TEVII_S660], NULL},
 	{NULL},
 };
 
-static struct dvb_usb_device_description d480_1 = {
+static const struct dvb_usb_device_description d480_1 = {
 	"TeVii S480.1 USB",
 	{&dw2102_table[TEVII_S480_1], NULL},
 	{NULL},
 };
 
-static struct dvb_usb_device_description d480_2 = {
+static const struct dvb_usb_device_description d480_2 = {
 	"TeVii S480.2 USB",
 	{&dw2102_table[TEVII_S480_2], NULL},
 	{NULL},
 };
 
 static struct dvb_usb_device_properties *p7500;
-static struct dvb_usb_device_description d7500 = {
+static const struct dvb_usb_device_description d7500 = {
 	"Prof 7500 USB DVB-S2",
 	{&dw2102_table[PROF_7500], NULL},
 	{NULL},
 };
 
 static struct dvb_usb_device_properties *s421;
-static struct dvb_usb_device_description d421 = {
+static const struct dvb_usb_device_description d421 = {
 	"TeVii S421 PCI",
 	{&dw2102_table[TEVII_S421], NULL},
 	{NULL},
 };
 
-static struct dvb_usb_device_description d632 = {
+static const struct dvb_usb_device_description d632 = {
 	"TeVii S632 USB",
 	{&dw2102_table[TEVII_S632], NULL},
 	{NULL},
@@ -2158,7 +2194,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_SU3000,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_RC5,
+		.allowed_protos   = RC_PROTO_BIT_RC5,
 		.rc_query = su3000_rc_query,
 	},
 
@@ -2185,20 +2221,24 @@
 		}},
 		}
 	},
-	.num_device_descs = 6,
+	.num_device_descs = 11,
 	.devices = {
 		{ "SU3000HD DVB-S USB2.0",
 			{ &dw2102_table[GENIATECH_SU3000], NULL },
 			{ NULL },
 		},
-		{ "Terratec Cinergy S2 USB HD",
-			{ &dw2102_table[TERRATEC_CINERGY_S2], NULL },
-			{ NULL },
-		},
 		{ "X3M TV SPC1400HD PCI",
 			{ &dw2102_table[X3M_SPC1400HD], NULL },
 			{ NULL },
 		},
+		{ "GOTVIEW Satellite HD",
+			{ &dw2102_table[GOTVIEW_SAT_HD], NULL },
+			{ NULL },
+		},
+		{ "Terratec Cinergy S2 USB HD",
+			{ &dw2102_table[TERRATEC_CINERGY_S2], NULL },
+			{ NULL },
+		},
 		{ "Terratec Cinergy S2 USB HD Rev.2",
 			{ &dw2102_table[TERRATEC_CINERGY_S2_R2], NULL },
 			{ NULL },
@@ -2207,8 +2247,24 @@
 			{ &dw2102_table[TERRATEC_CINERGY_S2_R3], NULL },
 			{ NULL },
 		},
-		{ "GOTVIEW Satellite HD",
-			{ &dw2102_table[GOTVIEW_SAT_HD], NULL },
+		{ "Terratec Cinergy S2 USB HD Rev.4",
+			{ &dw2102_table[TERRATEC_CINERGY_S2_R4], NULL },
+			{ NULL },
+		},
+		{ "Geniatech S2 X9320-0 USB2.0",
+			{ &dw2102_table[GENIATECH_X9320_0], NULL },
+			{ NULL },
+		},
+		{ "Geniatech S2 X9320-1 USB2.0",
+			{ &dw2102_table[GENIATECH_X9320_1], NULL },
+			{ NULL },
+		},
+		{ "Geniatech S2 X9320-2 USB2.0",
+			{ &dw2102_table[GENIATECH_X9320_2], NULL },
+			{ NULL },
+		},
+		{ "Geniatech S2 X9320-2 USB2.0",
+			{ &dw2102_table[GENIATECH_X9320_3], NULL },
 			{ NULL },
 		},
 	}
@@ -2227,7 +2283,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_SU3000,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_RC5,
+		.allowed_protos   = RC_PROTO_BIT_RC5,
 		.rc_query = su3000_rc_query,
 	},
 
@@ -2263,6 +2319,55 @@
 	}
 };
 
+static struct dvb_usb_device_properties t220a_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.size_of_priv = sizeof(struct dw2102_state),
+	.power_ctrl = su3000_power_ctrl,
+	.num_adapters = 1,
+	.identify_state	= su3000_identify_state,
+	.i2c_algo = &su3000_i2c_algo,
+
+	.rc.core = {
+		.rc_interval = 150,
+		.rc_codes = RC_MAP_SU3000,
+		.module_name = "dw2102",
+		.allowed_protos   = RC_PROTO_BIT_RC5,
+		.rc_query = su3000_rc_query,
+	},
+
+	.read_mac_address = su3000_read_mac_address,
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+
+	.adapter = {
+		{
+		.num_frontends = 1,
+		.fe = { {
+			.streaming_ctrl   = su3000_streaming_ctrl,
+			.frontend_attach  = t220a_frontend_attach,
+			.stream = {
+				.type = USB_BULK,
+				.count = 8,
+				.endpoint = 0x82,
+				.u = {
+					.bulk = {
+						.buffersize = 4096,
+					}
+				}
+			}
+		} },
+		}
+	},
+	.num_device_descs = 1,
+	.devices = {
+		{ "Geniatech T220A DVB-T/T2 USB2.0",
+			{ &dw2102_table[GENIATECH_T220A], NULL },
+			{ NULL },
+		},
+	}
+};
+
 static struct dvb_usb_device_properties tt_s2_4600_properties = {
 	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
 	.usb_ctrl = DEVICE_SPECIFIC,
@@ -2276,7 +2381,7 @@
 		.rc_interval = 250,
 		.rc_codes = RC_MAP_TT_1500,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_RC5,
+		.allowed_protos   = RC_PROTO_BIT_RC5,
 		.rc_query = su3000_rc_query,
 	},
 
@@ -2289,7 +2394,7 @@
 		.num_frontends = 1,
 		.fe = {{
 			.streaming_ctrl   = su3000_streaming_ctrl,
-			.frontend_attach  = tt_s2_4600_frontend_attach,
+			.frontend_attach  = su3000_frontend_attach,
 			.stream = {
 				.type = USB_BULK,
 				.count = 8,
@@ -2303,12 +2408,57 @@
 		} },
 		}
 	},
-	.num_device_descs = 5,
+	.num_device_descs = 1,
 	.devices = {
 		{ "TechnoTrend TT-connect S2-4600",
 			{ &dw2102_table[TECHNOTREND_S2_4600], NULL },
 			{ NULL },
 		},
+	}
+};
+
+static struct dvb_usb_device_properties tevii_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.size_of_priv = sizeof(struct dw2102_state),
+	.power_ctrl = su3000_power_ctrl,
+	.num_adapters = 1,
+	.identify_state	= su3000_identify_state,
+	.i2c_algo = &su3000_i2c_algo,
+
+	.rc.core = {
+		.rc_interval = 250,
+		.rc_codes = RC_MAP_TEVII_NEC,
+		.module_name = "dw2102",
+		.allowed_protos   = RC_PROTO_BIT_NEC,
+		.rc_query = su3000_rc_query,
+	},
+
+	.read_mac_address = su3000_read_mac_address,
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+
+	.adapter = {
+		{
+		.num_frontends = 1,
+		.fe = {{
+			.streaming_ctrl   = su3000_streaming_ctrl,
+			.frontend_attach  = su3000_frontend_attach,
+			.stream = {
+				.type = USB_BULK,
+				.count = 8,
+				.endpoint = 0x82,
+				.u = {
+					.bulk = {
+						.buffersize = 4096,
+					}
+				}
+			}
+		} },
+		}
+	},
+	.num_device_descs = 3,
+	.devices = {
 		{ "TeVii S482 (tuner 1)",
 			{ &dw2102_table[TEVII_S482_1], NULL },
 			{ NULL },
@@ -2317,10 +2467,6 @@
 			{ &dw2102_table[TEVII_S482_2], NULL },
 			{ NULL },
 		},
-		{ "Terratec Cinergy S2 USB BOX",
-			{ &dw2102_table[TERRATEC_CINERGY_S2_BOX], NULL },
-			{ NULL },
-		},
 		{ "TeVii S662",
 			{ &dw2102_table[TEVII_S662], NULL },
 			{ NULL },
@@ -2328,13 +2474,68 @@
 	}
 };
 
+static struct dvb_usb_device_properties terratec_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.size_of_priv = sizeof(struct dw2102_state),
+	.power_ctrl = su3000_power_ctrl,
+	.num_adapters = 1,
+	.identify_state	= su3000_identify_state,
+	.i2c_algo = &su3000_i2c_algo,
+
+	.rc.core = {
+		.rc_interval = 250,
+		.rc_codes = RC_MAP_TERRATEC_CINERGY_S2_DUAL,
+		.module_name = "dw2102",
+		.allowed_protos   = RC_PROTO_BIT_NEC,
+		.rc_query = su3000_rc_query,
+	},
+
+	.read_mac_address = su3000_read_mac_address,
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+
+	.adapter = {
+		{
+		.num_frontends = 1,
+		.fe = {{
+			.streaming_ctrl   = su3000_streaming_ctrl,
+			.frontend_attach  = su3000_frontend_attach,
+			.stream = {
+				.type = USB_BULK,
+				.count = 8,
+				.endpoint = 0x82,
+				.u = {
+					.bulk = {
+						.buffersize = 4096,
+					}
+				}
+			}
+		} },
+		}
+	},
+	.num_device_descs = 2,
+	.devices = {
+		{ "Terratec Cinergy S2 Dual (tuner 1)",
+			{ &dw2102_table[TERRATEC_DUAL_1], NULL },
+			{ NULL },
+		},
+		{ "Terratec Cinergy S2 Dual (tuner 2)",
+			{ &dw2102_table[TERRATEC_DUAL_2], NULL },
+			{ NULL },
+		},
+	}
+};
+
 static int dw2102_probe(struct usb_interface *intf,
 		const struct usb_device_id *id)
 {
+	int retval = -ENOMEM;
 	p1100 = kmemdup(&s6x0_properties,
 			sizeof(struct dvb_usb_device_properties), GFP_KERNEL);
 	if (!p1100)
-		return -ENOMEM;
+		goto err0;
+
 	/* copy default structure */
 	/* fill only different fields */
 	p1100->firmware = P1100_FIRMWARE;
@@ -2345,10 +2546,9 @@
 
 	s660 = kmemdup(&s6x0_properties,
 		       sizeof(struct dvb_usb_device_properties), GFP_KERNEL);
-	if (!s660) {
-		kfree(p1100);
-		return -ENOMEM;
-	}
+	if (!s660)
+		goto err1;
+
 	s660->firmware = S660_FIRMWARE;
 	s660->num_device_descs = 3;
 	s660->devices[0] = d660;
@@ -2358,11 +2558,9 @@
 
 	p7500 = kmemdup(&s6x0_properties,
 			sizeof(struct dvb_usb_device_properties), GFP_KERNEL);
-	if (!p7500) {
-		kfree(p1100);
-		kfree(s660);
-		return -ENOMEM;
-	}
+	if (!p7500)
+		goto err2;
+
 	p7500->firmware = P7500_FIRMWARE;
 	p7500->devices[0] = d7500;
 	p7500->rc.core.rc_query = prof_rc_query;
@@ -2372,12 +2570,9 @@
 
 	s421 = kmemdup(&su3000_properties,
 		       sizeof(struct dvb_usb_device_properties), GFP_KERNEL);
-	if (!s421) {
-		kfree(p1100);
-		kfree(s660);
-		kfree(p7500);
-		return -ENOMEM;
-	}
+	if (!s421)
+		goto err3;
+
 	s421->num_device_descs = 2;
 	s421->devices[0] = d421;
 	s421->devices[1] = d632;
@@ -2403,11 +2598,26 @@
 			 THIS_MODULE, NULL, adapter_nr) ||
 	    0 == dvb_usb_device_init(intf, &t220_properties,
 			 THIS_MODULE, NULL, adapter_nr) ||
+	    0 == dvb_usb_device_init(intf, &t220a_properties,
+			 THIS_MODULE, NULL, adapter_nr) ||
 	    0 == dvb_usb_device_init(intf, &tt_s2_4600_properties,
+			 THIS_MODULE, NULL, adapter_nr) ||
+	    0 == dvb_usb_device_init(intf, &tevii_properties,
+			 THIS_MODULE, NULL, adapter_nr) ||
+	    0 == dvb_usb_device_init(intf, &terratec_properties,
 			 THIS_MODULE, NULL, adapter_nr))
 		return 0;
 
-	return -ENODEV;
+	retval = -ENODEV;
+	kfree(s421);
+err3:
+	kfree(p7500);
+err2:
+	kfree(s660);
+err1:
+	kfree(p1100);
+err0:
+	return retval;
 }
 
 static void dw2102_disconnect(struct usb_interface *intf)
@@ -2443,12 +2653,7 @@
 module_usb_driver(dw2102_driver);
 
 MODULE_AUTHOR("Igor M. Liplianin (c) liplianin@me.by");
-MODULE_DESCRIPTION("Driver for DVBWorld DVB-S 2101, 2102, DVB-S2 2104,"
-			" DVB-C 3101 USB2.0,"
-			" TeVii S421, S480, S482, S600, S630, S632, S650,"
-			" TeVii S660, S662, Prof 1100, 7500 USB2.0,"
-			" Geniatech SU3000, T220,"
-			" TechnoTrend S2-4600, Terratec Cinergy S2 devices");
+MODULE_DESCRIPTION("Driver for DVBWorld DVB-S 2101, 2102, DVB-S2 2104, DVB-C 3101 USB2.0, TeVii S421, S480, S482, S600, S630, S632, S650, TeVii S660, S662, Prof 1100, 7500 USB2.0, Geniatech SU3000, T220, TechnoTrend S2-4600, Terratec Cinergy S2 devices");
 MODULE_VERSION("0.1");
 MODULE_LICENSE("GPL");
 MODULE_FIRMWARE(DW2101_FIRMWARE);
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/tbs5520se.c" "b/drivers/media/usb/dvb-usb/tbs5520se.c"
--- "a/drivers/media/usb/dvb-usb/tbs5520se.c"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/tbs5520se.c"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,501 @@
+/*
+ * TurboSight TBS 5520se  driver
+ *
+ * Copyright (c) 2017 Davin <smailedavin@hotmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, version 2.
+ *
+ */
+
+#include <linux/version.h>
+#include "tbs5520se.h"
+#include "si2183.h"
+#include "si2157.h"
+#include "av201x.h"
+
+#define TBS5520se_READ_MSG 0
+#define TBS5520se_WRITE_MSG 1
+
+#define TBS5520se_RC_QUERY (0x1a00)
+#define TBS5520se_VOLTAGE_CTRL (0x1800)
+
+struct tbs5520se_state {
+	struct i2c_client *i2c_client_demod;
+	struct i2c_client *i2c_client_tuner; 
+	u32 last_key_pressed;
+};
+
+static struct av201x_config tbs5520se_av201x_cfg = {
+	.i2c_address = 0x62,
+	.id          = ID_AV2018,
+	.xtal_freq   = 27000,
+};
+
+/* debug */
+static int dvb_usb_tbs5520se_debug;
+module_param_named(debug, dvb_usb_tbs5520se_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level (1=info 2=xfer (or-able))." 
+							DVB_USB_DEBUG_STATUS);
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static int tbs5520se_op_rw(struct usb_device *dev, u8 request, u16 value,
+				u16 index, u8 * data, u16 len, int flags)
+{
+	int ret;
+	void *u8buf;
+
+	unsigned int pipe = (flags == TBS5520se_READ_MSG) ?
+			usb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);
+	u8 request_type = (flags == TBS5520se_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;
+	u8buf = kmalloc(len, GFP_KERNEL);
+	if (!u8buf)
+		return -ENOMEM;
+
+	if (flags == TBS5520se_WRITE_MSG)
+		memcpy(u8buf, data, len);
+	ret = usb_control_msg(dev, pipe, request, request_type | USB_TYPE_VENDOR,
+				value, index , u8buf, len, 2000);
+
+	if (flags == TBS5520se_READ_MSG)
+		memcpy(data, u8buf, len);
+	kfree(u8buf);
+	return ret;
+}
+
+/* I2C */
+static int tbs5520se_i2c_transfer(struct i2c_adapter *adap, 
+					struct i2c_msg msg[], int num)
+{
+	struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	int i = 0;
+	u8 buf6[20];
+	u8 inbuf[20];
+
+	if (!d)
+		return -ENODEV;
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	switch (num) {
+	case 2:
+		buf6[0]=msg[1].len;//lenth
+		buf6[1]=msg[0].addr<<1;//demod addr
+		//register
+		buf6[2] = msg[0].buf[0];
+
+		tbs5520se_op_rw(d->udev, 0x90, 0, 0,
+					buf6, 3, TBS5520se_WRITE_MSG);
+		//msleep(5);
+		tbs5520se_op_rw(d->udev, 0x91, 0, 0,
+					inbuf, buf6[0], TBS5520se_READ_MSG);
+		memcpy(msg[1].buf, inbuf, msg[1].len);
+
+		break;
+	case 1:
+		switch (msg[0].addr) {
+		case 0x67:
+		case 0x62:
+		case 0x61:
+			if (msg[0].flags == 0) {
+				buf6[0] = msg[0].len+1;//lenth
+				buf6[1] = msg[0].addr<<1;//addr
+				for(i=0;i<msg[0].len;i++) {
+					buf6[2+i] = msg[0].buf[i];//register
+				}
+				tbs5520se_op_rw(d->udev, 0x80, 0, 0,
+					buf6, msg[0].len+2, TBS5520se_WRITE_MSG);
+			} else {
+				buf6[0] = msg[0].len;//length
+				buf6[1] = (msg[0].addr<<1) | 0x01;//addr
+				tbs5520se_op_rw(d->udev, 0x93, 0, 0,
+						buf6, 2, TBS5520se_WRITE_MSG);
+				//msleep(5);
+				tbs5520se_op_rw(d->udev, 0x91, 0, 0,
+					inbuf, buf6[0], TBS5520se_READ_MSG);
+				memcpy(msg[0].buf, inbuf, msg[0].len);
+			}
+			//msleep(3);
+		break;
+		case (TBS5520se_VOLTAGE_CTRL):
+			buf6[0] = 3;
+			buf6[1] = msg[0].buf[0];
+			tbs5520se_op_rw(d->udev, 0x8a, 0, 0,
+					buf6, 2, TBS5520se_WRITE_MSG);
+			break;
+		case (TBS5520se_RC_QUERY):
+			tbs5520se_op_rw(d->udev, 0xb8, 0, 0,
+					buf6, 4, TBS5520se_READ_MSG);
+			msg[0].buf[0] = buf6[2];
+			msg[0].buf[1] = buf6[3];
+			//msleep(3);
+			//info("TBS5520se_RC_QUERY %x %x %x %x\n",
+			//		buf6[0],buf6[1],buf6[2],buf6[3]);
+			break;
+		}
+
+		break;
+	}
+
+	mutex_unlock(&d->i2c_mutex);
+	return num;
+}
+
+static u32 tbs5520se_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm tbs5520se_i2c_algo = {
+	.master_xfer = tbs5520se_i2c_transfer,
+	.functionality = tbs5520se_i2c_func,
+};
+
+static int tbs5520se_set_voltage(struct dvb_frontend *fe, 
+						enum fe_sec_voltage voltage)
+{
+	static u8 command_13v[1] = {0x00};
+	static u8 command_18v[1] = {0x01};
+	struct i2c_msg msg[] = {
+		{.addr = TBS5520se_VOLTAGE_CTRL, .flags = 0,
+			.buf = command_13v, .len = 1},
+	};
+	
+	struct dvb_usb_adapter *udev_adap =
+		(struct dvb_usb_adapter *)(fe->dvb->priv);
+	if (voltage == SEC_VOLTAGE_18)
+		msg[0].buf = command_18v;
+
+	//info("tbs5520se_set_voltage %d",voltage);
+	i2c_transfer(&udev_adap->dev->i2c_adap, msg, 1);
+	
+	return 0;
+}
+
+static int tbs5520se_read_mac_address(struct dvb_usb_device *d, u8 mac[6])
+{
+	int i,ret;
+	u8 ibuf[3] = {0, 0,0};
+	u8 eeprom[256], eepromline[16];
+
+	for (i = 0; i < 256; i++) {
+		ibuf[0]=1;//lenth
+		ibuf[1]=0xa0;//eeprom addr
+		ibuf[2]=i;//register
+		ret = tbs5520se_op_rw(d->udev, 0x90, 0, 0,
+					ibuf, 3, TBS5520se_WRITE_MSG);
+		ret = tbs5520se_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBS5520se_READ_MSG);
+			if (ret < 0) {
+				err("read eeprom failed.");
+				return -1;
+			} else {
+				eepromline[i%16] = ibuf[0];
+				eeprom[i] = ibuf[0];
+			}
+			
+			if ((i % 16) == 15) {
+				deb_xfer("%02x: ", i - 15);
+				debug_dump(eepromline, 16, deb_xfer);
+			}
+	}
+	memcpy(mac, eeprom + 16, 6);
+	return 0;
+};
+
+static struct dvb_usb_device_properties tbs5520se_properties;
+
+static int tbs5520se_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	struct dvb_usb_device *d = adap->dev;
+	struct tbs5520se_state *st = d->priv;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client_demod;
+	struct i2c_client *client_tuner;
+	struct i2c_board_info info;
+	struct si2183_config si2183_config;
+	struct si2157_config si2157_config;
+	u8 buf[20];
+
+	/* attach frontend */
+	memset(&si2183_config,0,sizeof(si2183_config));
+	si2183_config.i2c_adapter = &adapter;
+	si2183_config.fe = &adap->fe_adap[0].fe;	
+	si2183_config.ts_mode = SI2183_TS_PARALLEL;
+	si2183_config.ts_clock_gapped = true;
+	si2183_config.rf_in = 0;
+	si2183_config.RF_switch = NULL;
+	si2183_config.fef_pin = SI2183_MP_B;
+	si2183_config.fef_inv = 0;
+	si2183_config.agc_pin = SI2183_MP_D;
+	si2183_config.ter_agc_inv = 0;
+	si2183_config.sat_agc_inv = 1;
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	strlcpy(info.type, "si2183", I2C_NAME_SIZE);
+	info.addr = 0x67;
+	info.platform_data = &si2183_config;
+	request_module(info.type);
+	client_demod = i2c_new_device(&d->i2c_adap, &info);
+	if (client_demod == NULL || client_demod->dev.driver == NULL)
+		return -ENODEV;
+
+	if (!try_module_get(client_demod->dev.driver->owner)) {
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+
+	st->i2c_client_demod = client_demod;
+
+	/* dvb core doesn't support 2 tuners for 1 demod so
+	   we split the adapter in 2 frontends */
+
+	adap->fe_adap[0].fe2 = &adap->fe_adap[0]._fe2;
+	memcpy(adap->fe_adap[0].fe2, adap->fe_adap[0].fe, sizeof(struct dvb_frontend));
+
+	/* terrestrial tuner */
+	memset(adap->fe_adap[0].fe->ops.delsys, 0, MAX_DELSYS);
+	adap->fe_adap[0].fe->ops.delsys[0] = SYS_DVBT;
+	adap->fe_adap[0].fe->ops.delsys[1] = SYS_DVBT2;
+	adap->fe_adap[0].fe->ops.delsys[2] = SYS_DVBC_ANNEX_A;
+	adap->fe_adap[0].fe->ops.delsys[3] = SYS_ISDBT;
+	adap->fe_adap[0].fe->ops.delsys[4] = SYS_DVBC_ANNEX_B;
+
+	/* attach ter tuner */
+	memset(&si2157_config, 0, sizeof(si2157_config));
+	si2157_config.fe = adap->fe_adap[0].fe;
+	si2157_config.if_port = 1;
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	strlcpy(info.type, "si2157", I2C_NAME_SIZE);
+	info.addr = 0x61;
+	info.platform_data = &si2157_config;
+	request_module(info.type);
+	client_tuner = i2c_new_device(adapter, &info);
+	if (client_tuner == NULL || client_tuner->dev.driver == NULL) {
+		module_put(client_demod->dev.driver->owner);
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+	if (!try_module_get(client_tuner->dev.driver->owner)) {
+		i2c_unregister_device(client_tuner);
+		module_put(client_demod->dev.driver->owner);
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+
+	st->i2c_client_tuner = client_tuner;
+
+	memset(adap->fe_adap[0].fe2->ops.delsys, 0, MAX_DELSYS);
+	adap->fe_adap[0].fe2->ops.delsys[0] = SYS_DVBS;
+	adap->fe_adap[0].fe2->ops.delsys[1] = SYS_DVBS2;
+	adap->fe_adap[0].fe2->ops.delsys[2] = SYS_DSS;
+	adap->fe_adap[0].fe2->id = 1;
+
+	if (!dvb_attach(av201x_attach, adap->fe_adap[0].fe2, &tbs5520se_av201x_cfg,
+			adapter))
+			return -ENODEV;
+	buf[0] = 1;
+	buf[1] = 0;
+	tbs5520se_op_rw(d->udev, 0x8a, 0, 0,
+			buf, 2, TBS5520se_WRITE_MSG);
+	adap->fe_adap[0].fe2->ops.set_voltage = tbs5520se_set_voltage;
+
+	buf[0] = 0;
+	buf[1] = 0;
+	tbs5520se_op_rw(d->udev, 0xb7, 0, 0,
+			buf, 2, TBS5520se_WRITE_MSG);
+	buf[0] = 8;
+	buf[1] = 1;
+	tbs5520se_op_rw(d->udev, 0x8a, 0, 0,
+			buf, 2, TBS5520se_WRITE_MSG);
+
+	return 0;
+}
+
+static struct usb_device_id tbs5520se_table[] = {
+	{USB_DEVICE(0x734c, 0x5521)},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(usb, tbs5520se_table);
+
+static int tbs5520se_load_firmware(struct usb_device *dev,
+			const struct firmware *frmwr)
+{
+	u8 *b, *p;
+	int ret = 0, i;
+	u8 reset;
+	const struct firmware *fw;
+	switch (dev->descriptor.idProduct) {
+	case 0x5521:
+		ret = request_firmware(&fw, tbs5520se_properties.firmware, &dev->dev);
+		if (ret != 0) {
+			err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details "
+			"on firmware-problems.", tbs5520se_properties.firmware);
+			return ret;
+		}
+		break;
+	default:
+		fw = frmwr;
+		break;
+	}
+	info("start downloading TBS5520se firmware");
+	p = kmalloc(fw->size, GFP_KERNEL);
+	reset = 1;
+	/*stop the CPU*/
+	tbs5520se_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, TBS5520se_WRITE_MSG);
+	tbs5520se_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, TBS5520se_WRITE_MSG);
+
+	if (p != NULL) {
+		memcpy(p, fw->data, fw->size);
+		for (i = 0; i < fw->size; i += 0x40) {
+			b = (u8 *) p + i;
+			if (tbs5520se_op_rw(dev, 0xa0, i, 0, b , 0x40,
+					TBS5520se_WRITE_MSG) != 0x40) {
+				err("error while transferring firmware");
+				ret = -EINVAL;
+				break;
+			}
+		}
+		/* restart the CPU */
+		reset = 0;
+		if (ret || tbs5520se_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,
+					TBS5520se_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+		if (ret || tbs5520se_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,
+					TBS5520se_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+
+		msleep(100);
+		kfree(p);
+	}
+	return ret;
+}
+
+static struct dvb_usb_device_properties tbs5520se_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.firmware = "dvb-usb-tbsqbox-id5521.fw",
+	.size_of_priv = sizeof(struct tbs5520se_state),
+	.no_reconnect = 1,
+
+	.i2c_algo = &tbs5520se_i2c_algo,
+
+	.generic_bulk_ctrl_endpoint = 0x81,
+	/* parameter for the MPEG2-data transfer */
+	.num_adapters = 1,
+	.download_firmware = tbs5520se_load_firmware,
+	.read_mac_address = tbs5520se_read_mac_address,
+	.adapter = {{
+		.num_frontends = 1,
+		.fe = {{
+			.frontend_attach = tbs5520se_frontend_attach,
+			.streaming_ctrl = NULL,
+			.tuner_attach = NULL,
+			.stream = {
+				.type = USB_BULK,
+				.count = 8,
+				.endpoint = 0x82,
+				.u = {
+					.bulk = {
+						.buffersize = 4096,
+					}
+				}
+			},
+		},
+/*			{
+				.frontend_attach = tbs5520se_satfrontend_attach,
+				.streaming_ctrl = NULL,
+				.tuner_attach = NULL,
+				.stream = {
+					.type = USB_BULK,
+					.count = 8,
+					.endpoint = 0x82,
+					.u = {
+						.bulk = {
+							.buffersize = 4096,
+						}
+					}
+				},
+			},*/
+
+		},
+		
+	}},
+
+	.num_device_descs = 1,
+	.devices = {
+		{"TBS 5520se USB2.0",
+			{&tbs5520se_table[0], NULL},
+			{NULL},
+		}
+	}
+};
+
+static int tbs5520se_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	if (0 == dvb_usb_device_init(intf, &tbs5520se_properties,
+			THIS_MODULE, NULL, adapter_nr)) {
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static void tbs5520se_disconnect(struct usb_interface *intf)
+{
+	struct dvb_usb_device *d = usb_get_intfdata(intf);
+	struct tbs5520se_state *st = d->priv;
+	struct i2c_client *client;
+
+	/* remove I2C client for tuner */
+	client = st->i2c_client_tuner;
+	if (client) {
+		module_put(client->dev.driver->owner);
+		i2c_unregister_device(client);
+	}
+
+	/* remove I2C client for demodulator */
+	client = st->i2c_client_demod;
+	if (client) {
+		module_put(client->dev.driver->owner);
+		i2c_unregister_device(client);
+	}
+
+	dvb_usb_device_exit(intf);
+}
+
+static struct usb_driver tbs5520se_driver = {
+	.name = "tbs5520se",
+	.probe = tbs5520se_probe,
+	.disconnect = tbs5520se_disconnect,
+	.id_table = tbs5520se_table,
+};
+
+static int __init tbs5520se_module_init(void)
+{
+	int ret =  usb_register(&tbs5520se_driver);
+	if (ret)
+		err("usb_register failed. Error number %d", ret);
+
+	return ret;
+}
+
+static void __exit tbs5520se_module_exit(void)
+{
+	usb_deregister(&tbs5520se_driver);
+}
+
+module_init(tbs5520se_module_init);
+module_exit(tbs5520se_module_exit);
+
+MODULE_AUTHOR("Davin <smiledavin@hotmail.com>");
+MODULE_DESCRIPTION("TurboSight TBS 5520se driver");
+MODULE_VERSION("1.0");
+MODULE_LICENSE("GPL");
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/tbs5520se.h" "b/drivers/media/usb/dvb-usb/tbs5520se.h"
--- "a/drivers/media/usb/dvb-usb/tbs5520se.h"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/tbs5520se.h"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,8 @@
+#ifndef _TBS5520SE_H_
+#define _TBS5520SE_H_
+
+#define DVB_USB_LOG_PREFIX "tbs5520se"
+#include "dvb-usb.h"
+
+#define deb_xfer(args...) dprintk(dvb_usb_tbs5520se_debug, 0x02, args)
+#endif
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb-v2/dvb_usb.h" "b/drivers/media/usb/dvb-usb-v2/dvb_usb.h"
--- "a/drivers/media/usb/dvb-usb-v2/dvb_usb.h"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb-v2/dvb_usb.h"	2017-12-07 05:52:26.000000000 +0800
@@ -138,7 +138,7 @@
 struct dvb_usb_rc {
 	const char *map_name;
 	u64 allowed_protos;
-	int (*change_protocol)(struct rc_dev *dev, u64 *rc_type);
+	int (*change_protocol)(struct rc_dev *dev, u64 *rc_proto);
 	int (*query) (struct dvb_usb_device *d);
 	unsigned int interval;
 	enum rc_driver_type driver_type;
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c" "b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c"
--- "a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c"	2017-12-07 05:52:26.000000000 +0800
@@ -147,22 +147,20 @@
 	if (!d->rc.map_name)
 		return 0;
 
-	dev = rc_allocate_device();
+	dev = rc_allocate_device(d->rc.driver_type);
 	if (!dev) {
 		ret = -ENOMEM;
 		goto err;
 	}
 
 	dev->dev.parent = &d->udev->dev;
-	dev->input_name = d->name;
+	dev->device_name = d->name;
 	usb_make_path(d->udev, d->rc_phys, sizeof(d->rc_phys));
 	strlcat(d->rc_phys, "/ir0", sizeof(d->rc_phys));
 	dev->input_phys = d->rc_phys;
 	usb_to_input_id(d->udev, &dev->input_id);
-	/* TODO: likely RC-core should took const char * */
-	dev->driver_name = (char *) d->props->driver_name;
+	dev->driver_name = d->props->driver_name;
 	dev->map_name = d->rc.map_name;
-	dev->driver_type = d->rc.driver_type;
 	dev->allowed_protocols = d->rc.allowed_protos;
 	dev->change_protocol = d->rc.change_protocol;
 	dev->priv = d;
@@ -630,8 +628,7 @@
 	}
 
 	ret = dvb_usbv2_device_power_ctrl(d, 0);
-	if (ret < 0)
-		goto err;
+
 err:
 	if (!adap->suspend_resume_active) {
 		adap->active_fe = -1;
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c" "b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c"
--- "a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c"	2017-12-07 05:52:26.000000000 +0800
@@ -1598,7 +1598,7 @@
 	struct rtl28xxu_dev *dev = d->priv;
 	u8 buf[5];
 	u32 rc_code;
-	struct rtl28xxu_reg_val rc_nec_tab[] = {
+	static const struct rtl28xxu_reg_val rc_nec_tab[] = {
 		{ 0x3033, 0x80 },
 		{ 0x3020, 0x43 },
 		{ 0x3021, 0x16 },
@@ -1631,24 +1631,24 @@
 		goto err;
 
 	if (buf[4] & 0x01) {
-		enum rc_type proto;
+		enum rc_proto proto;
 
 		if (buf[2] == (u8) ~buf[3]) {
 			if (buf[0] == (u8) ~buf[1]) {
 				/* NEC standard (16 bit) */
 				rc_code = RC_SCANCODE_NEC(buf[0], buf[2]);
-				proto = RC_TYPE_NEC;
+				proto = RC_PROTO_NEC;
 			} else {
 				/* NEC extended (24 bit) */
 				rc_code = RC_SCANCODE_NECX(buf[0] << 8 | buf[1],
 							   buf[2]);
-				proto = RC_TYPE_NECX;
+				proto = RC_PROTO_NECX;
 			}
 		} else {
 			/* NEC full (32 bit) */
 			rc_code = RC_SCANCODE_NEC32(buf[0] << 24 | buf[1] << 16 |
 						    buf[2] << 8  | buf[3]);
-			proto = RC_TYPE_NEC32;
+			proto = RC_PROTO_NEC32;
 		}
 
 		rc_keydown(d->rc_dev, proto, rc_code, 0);
@@ -1673,7 +1673,8 @@
 		struct dvb_usb_rc *rc)
 {
 	rc->map_name = RC_MAP_EMPTY;
-	rc->allowed_protos = RC_BIT_NEC | RC_BIT_NECX | RC_BIT_NEC32;
+	rc->allowed_protos = RC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX |
+							RC_PROTO_BIT_NEC32;
 	rc->query = rtl2831u_rc_query;
 	rc->interval = 400;
 
@@ -1778,7 +1779,7 @@
 	/* load empty to enable rc */
 	if (!rc->map_name)
 		rc->map_name = RC_MAP_EMPTY;
-	rc->allowed_protos = RC_BIT_ALL;
+	rc->allowed_protos = RC_PROTO_BIT_ALL_IR_DECODER;
 	rc->driver_type = RC_DRIVER_IR_RAW;
 	rc->query = rtl2832u_rc_query;
 	rc->interval = 200;
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/uvc/uvc_driver.c" "b/drivers/media/usb/uvc/uvc_driver.c"
--- "a/drivers/media/usb/uvc/uvc_driver.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/uvc/uvc_driver.c"	2018-01-15 21:21:56.858578000 +0800
@@ -2670,6 +2670,18 @@
 	  .bInterfaceSubClass	= 1,
 	  .bInterfaceProtocol	= 0,
 	  .driver_info		= UVC_QUIRK_FORCE_Y8 },
+	/* iPassion iP2970 */
+	{ .match_flags          = USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	 .idVendor		= 0x1B3B,
+	 .idProduct		= 0x2970,
+	 .bInterfaceClass	= USB_CLASS_VIDEO,
+	 .bInterfaceSubClass	= 1,
+	 .bInterfaceProtocol	= 0,
+	 .driver_info		= UVC_QUIRK_PROBE_MINMAX
+				| UVC_QUIRK_STREAM_NO_FID
+				| UVC_QUIRK_MOTION
+				| UVC_QUIRK_SINGLE_ISO },
 	/* Generic USB Video Class */
 	{ USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, UVC_PC_PROTOCOL_UNDEFINED) },
 	{ USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, UVC_PC_PROTOCOL_15) },
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/uvc/uvc_status.c" "b/drivers/media/usb/uvc/uvc_status.c"
--- "a/drivers/media/usb/uvc/uvc_status.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/uvc/uvc_status.c"	2018-01-15 21:21:56.858578000 +0800
@@ -139,6 +139,7 @@
 		switch (dev->status[0] & 0x0f) {
 		case UVC_STATUS_TYPE_CONTROL:
 			uvc_event_control(dev, dev->status, len);
+			dev->motion = 1;
 			break;
 
 		case UVC_STATUS_TYPE_STREAMING:
@@ -182,6 +183,7 @@
 	}
 
 	pipe = usb_rcvintpipe(dev->udev, ep->desc.bEndpointAddress);
+	dev->motion = 0;
 
 	/* For high-speed interrupt endpoints, the bInterval value is used as
 	 * an exponent of two. Some developers forgot about it.
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/uvc/uvc_video.c" "b/drivers/media/usb/uvc/uvc_video.c"
--- "a/drivers/media/usb/uvc/uvc_video.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/uvc/uvc_video.c"	2018-01-15 21:21:56.862582000 +0800
@@ -21,6 +21,11 @@
 #include <linux/wait.h>
 #include <linux/atomic.h>
 #include <asm/unaligned.h>
+#include <linux/skbuff.h>
+#include <linux/kobject.h>
+#include <linux/netlink.h>
+#include <linux/kobject.h>
+#include <linux/workqueue.h>
 
 #include <media/v4l2-common.h>
 
@@ -1087,9 +1092,149 @@
 	}
 }
 
+struct bh_priv {
+	unsigned long	seen;
+};
+
+struct bh_event {
+	const char		*name;
+	struct sk_buff		*skb;
+	struct work_struct	work;
+};
+
+#define BH_ERR(fmt, args...) printk(KERN_ERR "%s: " fmt, "webcam", ##args )
+#define BH_DBG(fmt, args...) do {} while (0)
+#define BH_SKB_SIZE     2048
+
+extern u64 uevent_next_seqnum(void);
+static int seen = 0;
+
+static int bh_event_add_var(struct bh_event *event, int argv,
+		const char *format, ...)
+{
+	static char buf[128];
+	char *s;
+	va_list args;
+	int len;
+
+	if (argv)
+		return 0;
+
+	va_start(args, format);
+	len = vsnprintf(buf, sizeof(buf), format, args);
+	va_end(args);
+
+	if (len >= sizeof(buf)) {
+		BH_ERR("buffer size too small\n");
+		WARN_ON(1);
+		return -ENOMEM;
+	}
+
+	s = skb_put(event->skb, len + 1);
+	strcpy(s, buf);
+
+	BH_DBG("added variable '%s'\n", s);
+
+	return 0;
+}
+
+static int motion_hotplug_fill_event(struct bh_event *event)
+{
+	int s = jiffies;
+	int ret;
+
+	if (!seen)
+		seen = jiffies;
+
+	ret = bh_event_add_var(event, 0, "HOME=%s", "/");
+	if (ret)
+		return ret;
+
+	ret = bh_event_add_var(event, 0, "PATH=%s",
+		"/sbin:/bin:/usr/sbin:/usr/bin");
+	if (ret)
+		return ret;
+
+	ret = bh_event_add_var(event, 0, "SUBSYSTEM=usb");
+	if (ret)
+		return ret;
+
+	ret = bh_event_add_var(event, 0, "ACTION=motion");
+	if (ret)
+		return ret;
+
+	ret = bh_event_add_var(event, 0, "SEEN=%d", s - seen);
+	if (ret)
+		return ret;
+	seen = s;
+
+	ret = bh_event_add_var(event, 0, "SEQNUM=%llu", uevent_next_seqnum());
+
+	return ret;
+}
+
+static void motion_hotplug_work(struct work_struct *work)
+{
+	struct bh_event *event = container_of(work, struct bh_event, work);
+	int ret = 0;
+
+	event->skb = alloc_skb(BH_SKB_SIZE, GFP_KERNEL);
+	if (!event->skb)
+		goto out_free_event;
+
+	ret = bh_event_add_var(event, 0, "%s@", "add");
+	if (ret)
+		goto out_free_skb;
+
+	ret = motion_hotplug_fill_event(event);
+	if (ret)
+		goto out_free_skb;
+
+	NETLINK_CB(event->skb).dst_group = 1;
+	broadcast_uevent(event->skb, 0, 1, GFP_KERNEL);
+
+out_free_skb:
+	if (ret) {
+		BH_ERR("work error %d\n", ret);
+		kfree_skb(event->skb);
+	}
+out_free_event:
+	kfree(event);
+}
+
+static int motion_hotplug_create_event(void)
+{
+	struct bh_event *event;
+
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!event)
+		return -ENOMEM;
+
+	event->name = "motion";
+
+	INIT_WORK(&event->work, (void *)(void *)motion_hotplug_work);
+	schedule_work(&event->work);
+
+	return 0;
+}
+
+#define MOTION_FLAG_OFFSET	4
 static void uvc_video_decode_end(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, const __u8 *data, int len)
 {
+	if ((stream->dev->quirks & UVC_QUIRK_MOTION) &&
+			(data[len - 2] == 0xff) && (data[len - 1] == 0xd9)) {
+		u8 *mem;
+		buf->state = UVC_BUF_STATE_READY;
+		mem = (u8 *) (buf->mem + MOTION_FLAG_OFFSET);
+		if ( stream->dev->motion ) {
+			stream->dev->motion = 0;
+			motion_hotplug_create_event();
+		} else {
+			*mem &= 0x7f;
+		}
+	}
+
 	/* Mark the buffer as done if the EOF marker is set. */
 	if (data[1] & UVC_STREAM_EOF && buf->bytesused != 0) {
 		uvc_trace(UVC_TRACE_FRAME, "Frame complete (EOF found).\n");
@@ -1503,6 +1648,8 @@
 	if (npackets == 0)
 		return -ENOMEM;
 
+	if (stream->dev->quirks & UVC_QUIRK_SINGLE_ISO)
+		npackets = 1;
 	size = npackets * psize;
 
 	for (i = 0; i < UVC_URBS; ++i) {
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/uvc/uvcvideo.h" "b/drivers/media/usb/uvc/uvcvideo.h"
--- "a/drivers/media/usb/uvc/uvcvideo.h"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/uvc/uvcvideo.h"	2018-01-15 21:21:56.930642000 +0800
@@ -164,7 +164,9 @@
 #define UVC_QUIRK_RESTRICT_FRAME_RATE	0x00000200
 #define UVC_QUIRK_RESTORE_CTRLS_ON_INIT	0x00000400
 #define UVC_QUIRK_FORCE_Y8		0x00000800
-
+#define UVC_QUIRK_MOTION		0x00001000
+#define UVC_QUIRK_SINGLE_ISO		0x00002000
+ 
 /* Format flags */
 #define UVC_FMT_FLAG_COMPRESSED		0x00000001
 #define UVC_FMT_FLAG_STREAM		0x00000002
@@ -562,6 +564,7 @@
 	__u8 *status;
 	struct input_dev *input;
 	char input_phys[64];
+	int motion;
 };
 
 enum uvc_handle_state {

diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/Kconfig" "b/drivers/media/dvb-frontends/Kconfig"
--- "a/drivers/media/dvb-frontends/Kconfig"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/dvb-frontends/Kconfig"	2018-01-17 18:32:32.568183000 +0800
@@ -841,6 +841,13 @@
 	help
 	  A DVB-S tuner module. Say Y when you want to support this frontend.
 
+config DVB_SI2183
+	tristate "Silicon Labs Si2183"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Say Y when you want to support this frontend.
+
 config DVB_M88RS2000
 	tristate "M88RS2000 DVB-S demodulator and tuner"
 	depends on DVB_CORE && I2C
diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/Makefile" "b/drivers/media/dvb-frontends/Makefile"
--- "a/drivers/media/dvb-frontends/Makefile"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/dvb-frontends/Makefile"	2018-01-17 18:33:32.823399000 +0800
@@ -124,5 +124,6 @@
 obj-$(CONFIG_DVB_GP8PSK_FE) += gp8psk-fe.o
 obj-$(CONFIG_DVB_TC90522) += tc90522.o
 obj-$(CONFIG_DVB_HORUS3A) += horus3a.o
+obj-$(CONFIG_DVB_SI2183) += si2183.o
 obj-$(CONFIG_DVB_ASCOT2E) += ascot2e.o
 obj-$(CONFIG_DVB_HELENE) += helene.o


--- "a/drivers/media/dvb-frontends/si2168_priv.h"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/dvb-frontends/si2168_priv.h"	2018-01-23 19:12:33.968928000 +0800
@@ -21,10 +21,12 @@
 #include "dvb_frontend.h"
 #include <linux/firmware.h>
 #include <linux/i2c-mux.h>
+#include <linux/kernel.h>
 
 #define SI2168_A20_FIRMWARE "dvb-demod-si2168-a20-01.fw"
 #define SI2168_A30_FIRMWARE "dvb-demod-si2168-a30-01.fw"
 #define SI2168_B40_FIRMWARE "dvb-demod-si2168-b40-01.fw"
+#define SI2168_D60_FIRMWARE "dvb-demod-si2168-d60-01.fw"
 #define SI2168_B40_FIRMWARE_FALLBACK "dvb-demod-si2168-02.fw"
 
 /* state struct */
@@ -34,17 +36,24 @@
 	struct dvb_frontend fe;
 	enum fe_delivery_system delivery_system;
 	enum fe_status fe_status;
+	u8 stat_resp;
 	#define SI2168_CHIP_ID_A20 ('A' << 24 | 68 << 16 | '2' << 8 | '0' << 0)
 	#define SI2168_CHIP_ID_A30 ('A' << 24 | 68 << 16 | '3' << 8 | '0' << 0)
 	#define SI2168_CHIP_ID_B40 ('B' << 24 | 68 << 16 | '4' << 8 | '0' << 0)
+	#define SI2168_CHIP_ID_D60 ('D' << 24 | 68 << 16 | '6' << 8 | '0' << 0)
 	unsigned int chip_id;
 	unsigned int version;
 	const char *firmware_name;
 	bool active;
 	bool warm;
 	u8 ts_mode;
+	u8 ts_clock_mode;
 	bool ts_clock_inv;
 	bool ts_clock_gapped;
+	int fef_pin;
+	bool fef_inv;
+	int agc_pin;
+	bool agc_inv;
 };
 
 /* firmware command struct */
diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/si2183.c" "b/drivers/media/dvb-frontends/si2183.c"
--- "a/drivers/media/dvb-frontends/si2183.c"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/dvb-frontends/si2183.c"	2018-01-17 20:00:36.585139000 +0800
@@ -0,0 +1,1599 @@
+/*
+ * Silicon Labs Si2183(2) DVB-T/T2/C/C2/S/S2 demodulator driver
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ */
+
+#include "si2183.h"
+#include "dvb_frontend.h"
+#include <linux/firmware.h>
+#include <linux/i2c-mux.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+#if IS_ENABLED(CONFIG_I2C_MUX)
+#define SI2183_USE_I2C_MUX
+#endif
+#endif
+
+#define SI2183_B60_FIRMWARE "dvb-demod-si2183-b60-01.fw"
+
+#define SI2183_PROP_MODE	0x100a
+#define SI2183_PROP_DVBC_CONST	0x1101
+#define SI2183_PROP_DVBC_SR	0x1102
+#define SI2183_PROP_DVBT_HIER	0x1201
+#define SI2183_PROP_DVBT2_MODE	0x1304
+#define SI2183_PROP_DVBS2_SR	0x1401
+#define SI2183_PROP_DVBS_SR	0x1501
+#define SI2183_PROP_MCNS_CONST	0x1601
+#define SI2183_PROP_MCNS_SR	0x1602
+
+#define SI2183_ARGLEN      30
+struct si2183_cmd {
+	u8 args[SI2183_ARGLEN];
+	unsigned wlen;
+	unsigned rlen;
+};
+
+static const struct dvb_frontend_ops si2183_ops;
+
+LIST_HEAD(silist);
+
+struct si_base {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	struct i2c_mux_core *muxc;
+#endif
+	struct list_head     silist;
+
+	u8                   adr;
+	struct i2c_adapter  *i2c;
+	u32                  count;
+
+	struct i2c_adapter  *tuner_adapter;
+
+#ifndef SI2183_USE_I2C_MUX
+	struct i2c_client *i2c_gate_client;
+#endif
+};
+
+/* state struct */
+struct si2183_dev {
+	struct dvb_frontend fe;
+	enum fe_delivery_system delivery_system;
+	enum fe_status fe_status;
+	u8 stat_resp;
+	bool active;
+	bool fw_loaded;
+	u8 ts_mode;
+	bool ts_clock_inv;
+	bool ts_clock_gapped;
+
+	int fef_pin;
+	bool fef_inv;
+	int agc_pin;
+	bool ter_agc_inv;
+	bool sat_agc_inv;
+
+	struct si_base *base;
+
+	void (*RF_switch)(struct i2c_adapter * i2c,u8 rf_in,u8 flag);
+	u8 rf_in;
+	u8 active_fe;
+};
+
+/* Own I2C adapter locking is needed because of I2C gate logic. */
+static int si2183_i2c_master_send_unlocked(const struct i2c_client *client,
+					   const char *buf, int count)
+{
+	int ret;
+	struct i2c_msg msg = {
+		.addr = client->addr,
+		.flags = 0,
+		.len = count,
+		.buf = (char *)buf,
+	};
+
+	ret = __i2c_transfer(client->adapter, &msg, 1);
+	return (ret == 1) ? count : ret;
+}
+
+static int si2183_i2c_master_recv_unlocked(const struct i2c_client *client,
+					   char *buf, int count)
+{
+	int ret;
+	struct i2c_msg msg = {
+		.addr = client->addr,
+		.flags = I2C_M_RD,
+		.len = count,
+		.buf = buf,
+	};
+
+	ret = __i2c_transfer(client->adapter, &msg, 1);
+	return (ret == 1) ? count : ret;
+}
+
+/* execute firmware command */
+static int si2183_cmd_execute_unlocked(struct i2c_client *client,
+				       struct si2183_cmd *cmd)
+{
+	int ret;
+	unsigned long timeout;
+
+	if (cmd->wlen) {
+		/* write cmd and args for firmware */
+		ret = si2183_i2c_master_send_unlocked(client, cmd->args,
+						      cmd->wlen);
+		if (ret < 0) {
+			goto err;
+		} else if (ret != cmd->wlen) {
+			ret = -EREMOTEIO;
+			goto err;
+		}
+	}
+
+	if (cmd->rlen) {
+		/* wait cmd execution terminate */
+		#define TIMEOUT 500
+		timeout = jiffies + msecs_to_jiffies(TIMEOUT);
+		while (!time_after(jiffies, timeout)) {
+			ret = si2183_i2c_master_recv_unlocked(client, cmd->args,
+							      cmd->rlen);
+			if (ret < 0) {
+				goto err;
+			} else if (ret != cmd->rlen) {
+				ret = -EREMOTEIO;
+				goto err;
+			}
+
+			/* firmware ready? */
+			if ((cmd->args[0] >> 7) & 0x01)
+				break;
+		}
+
+		dev_dbg(&client->dev, "cmd execution took %d ms\n",
+				jiffies_to_msecs(jiffies) -
+				(jiffies_to_msecs(timeout) - TIMEOUT));
+
+		/* CTS ? */
+		if (!((cmd->args[0] >> 7) & 0x01)) {
+			ret = -ETIMEDOUT;
+			goto err;
+		}
+	}
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_cmd_execute(struct i2c_client *client, struct si2183_cmd *cmd)
+{
+	int ret;
+
+	i2c_lock_adapter(client->adapter);
+	ret = si2183_cmd_execute_unlocked(client, cmd);
+	i2c_unlock_adapter(client->adapter);
+
+	return ret;
+}
+
+static int si2183_set_prop(struct i2c_client *client, u16 prop, u16 *val)
+{
+	struct si2183_cmd cmd;
+	int ret;
+
+	cmd.args[0] = 0x14;
+	cmd.args[1] = 0x00;
+	cmd.args[2] = (u8) prop;
+	cmd.args[3] = (u8) (prop >> 8);
+	cmd.args[4] = (u8) (*val);
+	cmd.args[5] = (u8) (*val >> 8);
+	cmd.wlen = 6;
+	cmd.rlen = 4;
+	ret = si2183_cmd_execute(client, &cmd);
+	*val = (cmd.args[2] | (cmd.args[3] << 8));
+	return ret;
+}
+
+static int si2183_get_prop(struct i2c_client *client, u16 prop, u16 *val)
+{
+	struct si2183_cmd cmd;
+	int ret;
+
+	cmd.args[0] = 0x15;
+	cmd.args[1] = 0x00;
+	cmd.args[2] = (u8) prop;
+	cmd.args[3] = (u8) (prop >> 8);
+	cmd.wlen = 4;
+	cmd.rlen = 4;
+	ret = si2183_cmd_execute(client, &cmd);
+	*val = (cmd.args[2] | (cmd.args[3] << 8));
+	return ret;
+}
+
+static int si2183_read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	struct si2183_cmd cmd;
+	u16 agc, snr_mul;
+
+	*status = 0;
+
+	if (!dev->active) {
+		ret = -EAGAIN;
+		goto err;
+	}
+
+	if ((dev->delivery_system != c->delivery_system) || (dev->delivery_system == 0))
+		return 0;
+
+	switch (c->delivery_system) {
+	case SYS_DVBT:
+		memcpy(cmd.args, "\xa0\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 13;
+		snr_mul = 2;
+		break;
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_C:
+		memcpy(cmd.args, "\x90\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 9;
+		snr_mul = 2;
+		break;
+	case SYS_DVBC_ANNEX_B:
+		memcpy(cmd.args, "\x98\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 10;
+		snr_mul = 2;
+		break;
+	case SYS_DVBT2:
+		memcpy(cmd.args, "\x50\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 14;
+		snr_mul = 2;
+		break;
+	case SYS_DVBS:
+		memcpy(cmd.args, "\x60\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 10;
+		snr_mul = 5;
+		break;
+	case SYS_DVBS2:
+		memcpy(cmd.args, "\x70\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 13;
+		snr_mul = 5;
+		break;
+	case SYS_ISDBT:
+		memcpy(cmd.args, "\xa4\x01", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 14;
+		snr_mul = 2;
+		break;
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "read_status fe%d cmd_exec failed=%d\n", fe->id, ret);
+		goto err;
+	}
+
+	dev->stat_resp = cmd.args[2];
+	switch ((dev->stat_resp >> 1) & 0x03) {
+	case 0x01:
+		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;
+		c->cnr.len = 1;
+		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		break;
+	case 0x03:
+		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |
+				FE_HAS_SYNC | FE_HAS_LOCK;
+		c->cnr.len = 2;
+		c->cnr.stat[0].scale = FE_SCALE_DECIBEL;			
+		c->cnr.stat[0].svalue = (s64)cmd.args[3] * 250;
+		c->cnr.stat[1].scale = FE_SCALE_RELATIVE;
+		c->cnr.stat[1].uvalue = (s64)cmd.args[3] * 164 * snr_mul;
+		break;
+	default:
+		c->cnr.len = 1;
+		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		break;
+	}
+	
+	dev->fe_status = *status;
+
+	dev_dbg(&client->dev, "status=%02x args=%*ph\n",
+			*status, cmd.rlen, cmd.args);
+
+	if (fe->ops.tuner_ops.get_rf_strength)
+	{
+		memcpy(cmd.args, "\x8a\x00\x00\x00\x00\x00", 6);
+		cmd.wlen = 6;
+		cmd.rlen = 3;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret) {
+			dev_err(&client->dev, "read_status fe%d cmd_exec failed=%d\n", fe->id, ret);
+			goto err;
+		}
+		dev_dbg(&client->dev, "status=%02x args=%*ph\n",
+			*status, cmd.rlen, cmd.args);
+
+		agc = cmd.args[1];
+		fe->ops.tuner_ops.get_rf_strength(fe, &agc);
+	}
+
+	return 0;
+err:
+	dev_err(&client->dev, "read_status failed=%d\n", ret);
+	return ret;
+}
+
+
+static int si2183_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int i;
+
+	*snr = 0;
+	for (i=0; i < c->cnr.len; i++)
+		if (c->cnr.stat[i].scale == FE_SCALE_RELATIVE)
+		  *snr = (u16)c->cnr.stat[i].uvalue;
+	return 0;
+}
+
+static int si2183_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int i;
+
+	*strength = 0;
+	for (i=0; i < c->strength.len; i++)
+	{
+		if (c->strength.stat[i].scale == FE_SCALE_RELATIVE)
+			*strength = (u16)c->strength.stat[i].uvalue;
+		else if (c->strength.stat[i].scale == FE_SCALE_DECIBEL)
+			*strength = ((100000 + (s32)c->strength.stat[i].svalue)/1000) * 656;
+	}
+	return 0;
+}
+
+static int si2183_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	struct si2183_cmd cmd;
+	int ret;
+	
+	if (dev->fe_status & FE_HAS_LOCK) {
+		memcpy(cmd.args, "\x82\x00", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 3;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret) {
+			dev_err(&client->dev, "read_ber fe%d cmd_exec failed=%d\n", fe->id, ret);
+			goto err;
+		}
+		*ber = (u32)cmd.args[2] * cmd.args[1] & 0xf;
+	} else *ber = 1;
+
+	return 0;
+err:
+	dev_err(&client->dev, "read_ber failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	struct si2183_cmd cmd;
+	int ret;
+	
+	if (dev->stat_resp & 0x10) {
+		memcpy(cmd.args, "\x84\x00", 2);
+		cmd.wlen = 2;
+		cmd.rlen = 3;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret) {
+		dev_err(&client->dev, "read_ucblocks fe%d cmd_exec failed=%d\n", fe->id, ret);
+			goto err;
+		}
+
+		*ucblocks = (u16)cmd.args[2] << 8 | cmd.args[1];
+	} else 	*ucblocks = 0;
+
+	return 0;
+err:
+	dev_err(&client->dev, "read_ucblocks failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_set_dvbc(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_cmd cmd;
+	int ret;
+	u16 prop;
+
+	/* dvb-c mode */
+	prop = 0x38;
+	ret = si2183_set_prop(client, SI2183_PROP_MODE, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-c mode\n");
+		return ret;
+	}
+
+	switch (c->modulation) {
+	default:
+	case QAM_AUTO:
+		prop = 0;
+		break;
+	case QAM_16:
+		prop = 7;
+		break;
+	case QAM_32:
+		prop = 8;
+		break;
+	case QAM_64:
+		prop = 9;
+		break;
+	case QAM_128:
+		prop = 10;
+		break;
+	case QAM_256:
+		prop = 11;
+		break;
+	}
+	ret = si2183_set_prop(client, SI2183_PROP_DVBC_CONST, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-c constelation\n");
+		return ret;
+	}
+
+	/* symbol rate */
+	prop = c->symbol_rate / 1000;
+	ret = si2183_set_prop(client, SI2183_PROP_DVBC_SR, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-c symbol rate\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int si2183_set_mcns(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_cmd cmd;
+	int ret;
+	u16 prop;
+
+	/* mcns mode */
+	prop = 0x16;
+	ret = si2183_set_prop(client, SI2183_PROP_MODE, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set mcns mode\n");
+		return ret;
+	}
+
+	switch (c->modulation) {
+	default:
+	case QAM_AUTO:
+		prop = 0;
+		break;
+	case QAM_16:
+		prop = 7;
+		break;
+	case QAM_32:
+		prop = 8;
+		break;
+	case QAM_64:
+		prop = 9;
+		break;
+	case QAM_128:
+		prop = 10;
+		break;
+	case QAM_256:
+		prop = 11;
+		break;
+	}
+	ret = si2183_set_prop(client, SI2183_PROP_MCNS_CONST, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set mcns constelation\n");
+		return ret;
+	}
+
+	/* symbol rate */
+	prop = c->symbol_rate / 1000;
+	ret = si2183_set_prop(client, SI2183_PROP_MCNS_SR, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set mcns symbol rate\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int gold_code_index (int gold_sequence_index)
+{
+	unsigned int i, k , x_init;
+	u8 GOLD_PRBS[19] = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+	for (k=0; k<gold_sequence_index; k++) {
+		GOLD_PRBS[18] = (GOLD_PRBS[0] + GOLD_PRBS[7])%2;
+		/* Shifting 18 first values */
+		for (i=0; i<18; i++) 
+			GOLD_PRBS[i] = GOLD_PRBS[i+1];
+	}
+	x_init = 0;
+	for (i=0; i<18; i++) { x_init = x_init + GOLD_PRBS[i]*(1<<i); }
+
+	return x_init;
+}
+
+static int si2183_set_dvbs(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_cmd cmd;
+	int ret;
+	u16 prop;
+	u32 pls_mode, pls_code;
+	
+	/* set mode */
+	prop = 0x8;
+	switch (c->delivery_system) {
+	default:
+	case SYS_DVBS:
+		prop |= 0x80;
+		break;
+	case SYS_DVBS2:
+		prop |= 0x90;
+		break;
+	case SYS_DSS:
+		prop |= 0xa0;
+		break;
+	}
+	if (c->inversion)
+		prop |= 0x100;
+	ret = si2183_set_prop(client, SI2183_PROP_MODE, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-s/s2 mode\n");
+		return ret;
+	}
+
+	/* symbol rate */
+	prop = c->symbol_rate / 1000;
+	switch (c->delivery_system) {
+	default:
+	case SYS_DSS:
+	case SYS_DVBS:
+		ret = si2183_set_prop(client, SI2183_PROP_DVBS_SR, &prop);
+		break;
+	case SYS_DVBS2:
+		ret = si2183_set_prop(client, SI2183_PROP_DVBS2_SR, &prop);
+		/* stream_id selection */
+		cmd.args[0] = 0x71;
+		cmd.args[1] = (u8) c->stream_id;
+		cmd.args[2] = c->stream_id == NO_STREAM_ID_FILTER ? 0 : 1;
+		cmd.wlen = 3;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			dev_warn(&client->dev, "dvb-s2: err selecting stream_id\n");
+
+		/* pls selection */
+		pls_mode = c->stream_id == NO_STREAM_ID_FILTER ? 0 : (c->stream_id >> 26) & 3;
+		pls_code = c->stream_id == NO_STREAM_ID_FILTER ? 0 : (c->stream_id >> 8) & 0x3FFFF;
+		if (pls_mode)
+			pls_code = gold_code_index(pls_code);
+		cmd.args[0] = 0x73;
+		cmd.args[1] = pls_code > 0;
+		cmd.args[2] = cmd.args[3] = 0;
+		cmd.args[4] = (u8) pls_code;
+		cmd.args[5] = (u8) (pls_code >> 8);
+		cmd.args[6] = (u8) (pls_code >> 16);
+		cmd.args[7] = (u8) (pls_code >> 24);
+		cmd.wlen = 8;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			dev_warn(&client->dev, "dvb-s2: err set pls\n");
+
+		break;
+	}
+
+	return 0;
+}
+
+
+static int si2183_set_dvbt(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_cmd cmd;
+	int ret;
+	u16 prop;
+
+	if (c->bandwidth_hz == 0) {
+		return -EINVAL;
+	} else if (c->bandwidth_hz <= 2000000)
+		prop = 0x02;
+	else if (c->bandwidth_hz <= 5000000)
+		prop = 0x05;
+	else if (c->bandwidth_hz <= 6000000)
+		prop = 0x06;
+	else if (c->bandwidth_hz <= 7000000)
+		prop = 0x07;
+	else if (c->bandwidth_hz <= 8000000)
+		prop = 0x08;
+	else if (c->bandwidth_hz <= 9000000)
+		prop = 0x09;
+	else if (c->bandwidth_hz <= 10000000)
+		prop = 0x0a;
+	else
+		prop = 0x0f;
+
+	switch (c->delivery_system) {
+	default:
+	case SYS_DVBT:
+		prop |= 0x20;
+		break;
+	case SYS_DVBT2:
+		prop |= 0x70;
+		break;
+	}
+	ret = si2183_set_prop(client, SI2183_PROP_MODE, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-t mode\n");
+		return ret;
+	}
+
+	/* hierarchy - HP = 0 / LP = 1 */
+	prop = c->hierarchy == HIERARCHY_1 ? 1 : 0;
+	ret = si2183_set_prop(client, SI2183_PROP_DVBT_HIER, &prop);
+	if (ret)
+		dev_warn(&client->dev, "dvb-t: err set hierarchy\n");
+
+	if (c->delivery_system == SYS_DVBT2) {
+		/* stream_id selection */
+		cmd.args[0] = 0x52;
+		cmd.args[1] = (u8) c->stream_id;
+		cmd.args[2] = c->stream_id == NO_STREAM_ID_FILTER ? 0 : 1;
+		cmd.wlen = 3;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			dev_warn(&client->dev, "dvb-t2: err selecting stream_id\n");
+
+		/* dvb-t2 mode - any=0 / base=1 / lite=2 */
+		prop = 0;
+		ret = si2183_set_prop(client, SI2183_PROP_DVBT2_MODE, &prop);
+		if (ret)
+			dev_warn(&client->dev, "dvb-t2: err set mode\n");
+	}
+
+	return 0;
+}
+
+static int si2183_set_isdbt(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct i2c_client *client = fe->demodulator_priv;
+	int ret;
+	u16 prop;
+
+	if (c->bandwidth_hz == 0) {
+		return -EINVAL;
+	} else if (c->bandwidth_hz <= 2000000)
+		prop = 0x02;
+	else if (c->bandwidth_hz <= 5000000)
+		prop = 0x05;
+	else if (c->bandwidth_hz <= 6000000)
+		prop = 0x06;
+	else if (c->bandwidth_hz <= 7000000)
+		prop = 0x07;
+	else if (c->bandwidth_hz <= 8000000)
+		prop = 0x08;
+	else if (c->bandwidth_hz <= 9000000)
+		prop = 0x09;
+	else if (c->bandwidth_hz <= 10000000)
+		prop = 0x0a;
+	else
+		prop = 0x0f;
+
+	/* ISDB-T mode */
+	prop |= 0x40;
+	ret = si2183_set_prop(client, SI2183_PROP_MODE, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dvb-t mode\n");
+		return ret;
+	}
+	return 0;
+}
+
+static int si2183_set_frontend(struct dvb_frontend *fe)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	struct si2183_cmd cmd;
+
+	dev_dbg(&client->dev,
+			"delivery_system=%u modulation=%u frequency=%u bandwidth_hz=%u symbol_rate=%u inversion=%u stream_id=%u\n",
+			c->delivery_system, c->modulation, c->frequency,
+			c->bandwidth_hz, c->symbol_rate, c->inversion,
+			c->stream_id);
+
+	if (!dev->active) {
+		ret = -EAGAIN;
+		goto err;
+	}
+
+	/* Force DVB-C Annex B if SR < 6000 Ks */
+	if (c->delivery_system == SYS_DVBC_ANNEX_A && c->symbol_rate < 6000000) {
+		c->delivery_system = SYS_DVBC_ANNEX_B;
+		c->bandwidth_hz = 6000000;
+	}
+
+	if(dev->RF_switch)
+	{	
+		switch (c->delivery_system) {
+		case SYS_DVBT:
+		case SYS_DVBT2:
+		case SYS_DVBC_ANNEX_A:
+		case SYS_DVBC_ANNEX_B:
+		case SYS_ISDBT:
+			dev->RF_switch(dev->base->i2c,dev->rf_in,1);
+			break;
+			
+		case SYS_DVBS:
+		case SYS_DVBS2:
+		case SYS_DSS:
+		default:
+			dev->RF_switch(dev->base->i2c,dev->rf_in,0);
+			break;
+		
+		}
+	}
+
+	if (fe->ops.tuner_ops.set_params) {
+#ifndef SI2183_USE_I2C_MUX
+		if (fe->ops.i2c_gate_ctrl)
+			fe->ops.i2c_gate_ctrl(fe, 1);
+#endif
+		ret = fe->ops.tuner_ops.set_params(fe);
+#ifndef SI2183_USE_I2C_MUX
+		if (fe->ops.i2c_gate_ctrl)
+			fe->ops.i2c_gate_ctrl(fe, 0);
+#endif
+		if (ret) {
+			dev_err(&client->dev, "err setting tuner params\n");
+			goto err;
+		}
+	}
+
+	switch (c->delivery_system) {
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		ret = si2183_set_dvbt(fe);
+		break;
+	case SYS_DVBC_ANNEX_A:
+	  ret = si2183_set_dvbc(fe);
+		break;
+	case SYS_DVBC_ANNEX_B:
+		ret = si2183_set_mcns(fe);
+		break;
+	case SYS_ISDBT:
+		ret = si2183_set_isdbt(fe);
+		break;
+	case SYS_DVBS:
+	case SYS_DVBS2:
+	case SYS_DSS:
+		ret = si2183_set_dvbs(fe);
+		break;
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* dsp restart */
+	memcpy(cmd.args, "\x85", 1);
+	cmd.wlen = 1;
+	cmd.rlen = 1;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err restarting dsp\n");
+		return ret;
+	}
+
+	dev->delivery_system = c->delivery_system;
+	return 0;
+err:
+	dev_err(&client->dev, "set_params failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_init(struct dvb_frontend *fe)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	int ret = 0, len, remaining;
+	const struct firmware *fw;
+	const char *fw_name;
+	struct si2183_cmd cmd;
+	unsigned int chip_id;
+	u16 prop;
+
+	dev_dbg(&client->dev, "\n");
+
+	if (dev->active_fe) {
+		dev->active_fe |= (1 << fe->id);
+		return 0;
+	}
+
+	/* initialize */
+	memcpy(cmd.args, "\xc0\x12\x00\x0c\x00\x0d\x16\x00\x00\x00\x00\x00\x00", 13);
+	cmd.wlen = 13;
+	cmd.rlen = 0;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	if (dev->fw_loaded) {
+		/* resume */
+		memcpy(cmd.args, "\xc0\x06\x08\x0f\x00\x20\x21\x01", 8);
+		cmd.wlen = 8;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+
+		memcpy(cmd.args, "\x85", 1);
+		cmd.wlen = 1;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+
+		goto warm;
+	}
+
+	/* power up */
+	memcpy(cmd.args, "\xc0\x06\x01\x0f\x00\x20\x20\x01", 8);
+	cmd.wlen = 8;
+	cmd.rlen = 1;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	/* query chip revision */
+	memcpy(cmd.args, "\x02", 1);
+	cmd.wlen = 1;
+	cmd.rlen = 13;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	chip_id = cmd.args[1] << 24 | cmd.args[2] << 16 | cmd.args[3] << 8 |
+			cmd.args[4] << 0;
+
+	#define SI2183_B60 ('B' << 24 | 83 << 16 | '6' << 8 | '0' << 0)
+
+	switch (chip_id) {
+	case SI2183_B60:
+		fw_name = SI2183_B60_FIRMWARE;
+		break;
+	default:
+		dev_err(&client->dev, "unknown chip version Si21%d-%c%c%c\n",
+				cmd.args[2], cmd.args[1],
+				cmd.args[3], cmd.args[4]);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	dev_info(&client->dev, "found a 'Silicon Labs Si21%d-%c%c%c'\n",
+			cmd.args[2], cmd.args[1], cmd.args[3], cmd.args[4]);
+
+	ret = request_firmware(&fw, fw_name, &client->dev);
+	if (ret) {
+		dev_err(&client->dev,
+				"firmware file '%s' not found\n",
+				fw_name);
+		goto err;
+	}
+
+	dev_info(&client->dev, "downloading firmware from file '%s'\n",
+			fw_name);
+
+	for (remaining = fw->size; remaining > 0; remaining -= 17) {
+		len = fw->data[fw->size - remaining];
+		if (len > SI2183_ARGLEN) {
+			ret = -EINVAL;
+			break;
+		}
+		memcpy(cmd.args, &fw->data[(fw->size - remaining) + 1], len);
+		cmd.wlen = len;
+		cmd.rlen = 1;
+		ret = si2183_cmd_execute(client, &cmd);
+		if (ret)
+			break;
+	}
+	release_firmware(fw);
+
+	if (ret) {
+		dev_err(&client->dev, "firmware download failed %d\n", ret);
+		goto err;
+	}
+
+	memcpy(cmd.args, "\x01\x01", 2);
+	cmd.wlen = 2;
+	cmd.rlen = 1;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	/* query firmware version */
+	memcpy(cmd.args, "\x11", 1);
+	cmd.wlen = 1;
+	cmd.rlen = 10;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	dev_info(&client->dev, "firmware version: %c.%c.%d\n",
+			cmd.args[6], cmd.args[7], cmd.args[8]);
+
+	/* TER FEF */
+	memcpy(cmd.args, "\x51\x00", 2);
+	cmd.wlen = 2;
+	cmd.rlen = 12;
+	cmd.args[1] = (dev->fef_inv & 1) << 3 | (dev->fef_pin & 7);
+	dev_dbg(&client->dev, "args=%*ph\n", cmd.wlen, cmd.args);
+	
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err set fef pip\n");
+	}
+
+	/* MP DEFAULTS */
+	memcpy(cmd.args, "\x88\x00\x00\x00\x00", 5);
+	cmd.wlen = 5;
+	cmd.rlen = 2;
+	switch (dev->fef_pin)
+	{
+	case SI2183_MP_A:
+		cmd.args[1] = dev->fef_inv ? 3 : 2;
+		break;
+	case SI2183_MP_B:
+		cmd.args[2] = dev->fef_inv ? 3 : 2;
+		break;
+	case SI2183_MP_C:
+		cmd.args[3] = dev->fef_inv ? 3 : 2;
+		break;
+	case SI2183_MP_D:
+		cmd.args[4] = dev->fef_inv ? 3 : 2;
+		break;
+	}
+	switch (dev->agc_pin)
+	{
+	case SI2183_MP_A:
+		cmd.args[1] = 1;
+		break;
+	case SI2183_MP_B:
+		cmd.args[2] = 1;
+		break;
+	case SI2183_MP_C:
+		cmd.args[3] = 1;
+		break;
+	case SI2183_MP_D:
+		cmd.args[4] = 1;
+		break;
+	}
+	dev_dbg(&client->dev, "args=%*ph\n", cmd.wlen, cmd.args);
+	
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err set mp defaults\n");
+	}
+
+	/* TER AGC */
+	memcpy(cmd.args, "\x89\x01\x06\x12\x00\x00", 6);
+	cmd.wlen = 6;
+	cmd.rlen = 3;
+	cmd.args[1] |= (dev->ter_agc_inv & 1) << 7 | (dev->agc_pin & 7) << 4;
+	dev_dbg(&client->dev, "args=%*ph\n", cmd.wlen, cmd.args);
+	
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err set ter agc\n");
+	}
+
+	/* SAT AGC */
+	memcpy(cmd.args, "\x8a\x10\x12\x00\x00\x00", 6);
+	cmd.wlen = 6;
+	cmd.rlen = 3;
+	cmd.args[1] |= (dev->sat_agc_inv & 1) << 3 | (dev->agc_pin & 7);
+	dev_dbg(&client->dev, "args=%*ph\n", cmd.wlen, cmd.args);
+
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret) {
+		dev_err(&client->dev, "err set sat agc\n");
+	}
+
+	/* set ts mode */
+	prop = 0x10 | dev->ts_mode | (dev->ts_clock_gapped ? 0x40 : 0);
+	ret = si2183_set_prop(client, 0x1001, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set ts mode\n");
+	}
+
+	/* FER resol */
+	prop = 0x12;
+	ret = si2183_set_prop(client, 0x100c, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set FER resol\n");
+		return ret;
+	}
+
+	/* DD IEN */
+	prop = 0x00;
+	ret = si2183_set_prop(client, 0x1006, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set dd ien\n");
+		return ret;
+	}
+
+	/* int sense */
+	prop = 0x2000;
+	ret = si2183_set_prop(client, 0x1007, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set int sense\n");
+		return ret;
+	}
+
+	/* Control of SQI computation */
+	prop = 0x1e;
+	ret = si2183_set_prop(client, 0x100f, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set sqi comp\n");
+		return ret;
+	}
+
+	/* Transport Stream setting for parallel mode */
+	prop = 0x0104 | (dev->ts_clock_inv ? 0x0000 : 0x1000);
+	ret = si2183_set_prop(client, 0x1009, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set par_ts\n");
+		return ret;
+	}
+
+	/* Transport Stream setting for serial mode */
+	prop = 0x230C | (dev->ts_clock_inv ? 0x0000 : 0x1000);
+	ret = si2183_set_prop(client, 0x1008, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set ser_ts\n");
+		return ret;
+	}
+
+	/* Transport Stream setting for parallel mode - secondary*/
+	prop = 0x08e3;
+	ret = si2183_set_prop(client, 0x1015, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set int par_ts_sec\n");
+		return ret;
+	}
+
+	/* Transport Stream setting for serial mode - secondary*/
+	prop = 0x01c7;
+	ret = si2183_set_prop(client, 0x1016, &prop);
+	if (ret) {
+		dev_err(&client->dev, "err set int ser_ts_sec\n");
+		return ret;
+	}
+
+	dev->fw_loaded = true;
+warm:
+	dev->active = true;
+	dev->active_fe |= (1 << fe->id);
+	return 0;
+
+err:
+	dev_dbg(&client->dev, "init failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_sleep(struct dvb_frontend *fe)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	int ret;
+	struct si2183_cmd cmd;
+
+	dev_dbg(&client->dev, "\n");
+
+	dev->active_fe &= ~(1 << fe->id);
+	if (dev->active_fe)
+		return 0;
+
+	dev->active = false;
+
+	memcpy(cmd.args, "\x13", 1);
+	cmd.wlen = 1;
+	cmd.rlen = 0;
+	ret = si2183_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_get_tune_settings(struct dvb_frontend *fe,
+	struct dvb_frontend_tune_settings *s)
+{
+	s->min_delay_ms = 900;
+
+	return 0;
+}
+
+#ifdef SI2183_USE_I2C_MUX
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+static int si2183_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	struct i2c_client *client = i2c_mux_priv(muxc);
+#else
+static int si2183_select(struct i2c_adapter *adap, void *mux_priv, u32 chan)
+{
+	struct i2c_client *client = mux_priv;
+#endif
+	int ret;
+	struct si2183_cmd cmd;
+
+	/* open I2C gate */
+	memcpy(cmd.args, "\xc0\x0d\x01", 3);
+	cmd.wlen = 3;
+	cmd.rlen = 0;
+	ret = si2183_cmd_execute_unlocked(client, &cmd);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+static int si2183_deselect(struct i2c_mux_core *muxc, u32 chan)
+{
+	struct i2c_client *client = i2c_mux_priv(muxc);
+#else
+static int si2183_deselect(struct i2c_adapter *adap, void *mux_priv, u32 chan)
+{
+	struct i2c_client *client = mux_priv;
+#endif
+	int ret;
+	struct si2183_cmd cmd;
+
+	/* close I2C gate */
+	memcpy(cmd.args, "\xc0\x0d\x00", 3);
+	cmd.wlen = 3;
+	cmd.rlen = 0;
+	ret = si2183_cmd_execute_unlocked(client, &cmd);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+#else
+static int si2183_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+	struct si2183_cmd cmd;
+
+	memcpy(cmd.args, "\xc0\x0d\x00", 3);
+	if (enable)
+		cmd.args[2] = 1;
+	cmd.wlen = 3;
+	cmd.rlen = 0;
+	return si2183_cmd_execute(dev->base->i2c_gate_client, &cmd);
+}
+#endif
+
+static int si2183_tune(struct dvb_frontend *fe, bool re_tune,
+	unsigned int mode_flags, unsigned int *delay, enum fe_status *status)
+{
+	*delay = HZ / 5;
+	if (re_tune) {
+		int ret = si2183_set_frontend(fe);
+		if (ret)
+			return ret;
+	}
+	return si2183_read_status(fe, status);
+}
+
+static int si2183_get_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+
+static int si2183_set_property(struct dvb_frontend *fe,
+		struct dtv_property *p)
+{
+	int ret = 0;
+
+	switch (p->cmd) {
+	case DTV_DELIVERY_SYSTEM:
+		switch (p->u.data) {
+		case SYS_DVBS:
+		case SYS_DVBS2:
+		case SYS_DSS:
+			fe->ops.info.frequency_min = 950000;
+			fe->ops.info.frequency_max = 2150000;
+			fe->ops.info.frequency_stepsize = 0;
+			break;
+		case SYS_DVBC_ANNEX_A:
+		case SYS_DVBC_ANNEX_B:
+			fe->ops.info.frequency_min = 47000000;
+			fe->ops.info.frequency_max = 862000000;
+			fe->ops.info.frequency_stepsize = 62500;
+			break;
+		case SYS_ISDBT:
+			fe->ops.info.frequency_min = 42000000;
+			fe->ops.info.frequency_max = 1002000000;
+			fe->ops.info.frequency_stepsize = 0;
+			break;
+		case SYS_DVBT:
+		case SYS_DVBT2:
+		default:
+			fe->ops.info.frequency_min = 174000000;
+			fe->ops.info.frequency_max = 862000000;
+			fe->ops.info.frequency_stepsize = 250000;
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int si2183_send_diseqc_cmd(struct dvb_frontend *fe,
+	u8 cont_tone, u8 tone_burst, u8 burst_sel,
+	u8 end_seq, u8 msg_len, u8 *msg)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct si2183_cmd cmd;
+	u8 enable = 1;
+
+	cmd.args[0] = 0x8c;
+	cmd.args[1] = enable | (cont_tone << 1)
+		    | (tone_burst << 2) | (burst_sel << 3)
+		    | (end_seq << 4) | (msg_len << 5);
+
+	if (msg_len > 0)
+		memcpy(&cmd.args[2], msg, msg_len);
+
+	cmd.wlen = 8;
+	cmd.rlen = 1;
+	return si2183_cmd_execute(client, &cmd);
+}
+
+static int si2183_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	int ret;
+	u8 cont_tone;
+
+	switch (tone) {
+	case SEC_TONE_ON:
+		cont_tone = 1;
+		break;
+	case SEC_TONE_OFF:
+		cont_tone = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = si2183_send_diseqc_cmd(fe, cont_tone, 0, 0, 1, 0, NULL);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_err(&client->dev, "set_tone failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_diseqc_send_burst(struct dvb_frontend *fe,
+	enum fe_sec_mini_cmd burst)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	int ret;
+	u8 burst_sel;
+
+	switch (burst) {
+	case SEC_MINI_A:
+		burst_sel = 0;
+		break;
+	case SEC_MINI_B:
+		burst_sel = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = si2183_send_diseqc_cmd(fe, 0, 1, burst_sel, 1, 0, NULL);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_err(&client->dev, "set_tone failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_send_diseqc_msg(struct dvb_frontend *fe,
+	struct dvb_diseqc_master_cmd *d)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	int ret;
+	u8 remaining = d->msg_len;
+	u8 *p = d->msg;
+	u8 len = 0;
+
+	while (remaining > 0) {
+		p += len;
+		len = (remaining > 6) ? 6 : remaining;
+		remaining -= len;
+		ret = si2183_send_diseqc_cmd(fe, 0, 0, 0,
+			(remaining == 0) ? 1 : 0, len, p);
+		if (ret)
+			goto err;
+		msleep(50);
+	}
+
+	return 0;
+err:
+	dev_err(&client->dev, "set_tone failed=%d\n", ret);
+	return ret;
+}
+
+static const struct dvb_frontend_ops si2183_ops = {
+	.delsys = {SYS_DVBT, SYS_DVBT2, SYS_ISDBT,	  
+			SYS_DVBC_ANNEX_A, SYS_DVBC_ANNEX_B, 
+			SYS_DVBS, SYS_DVBS2, SYS_DSS},
+	.info = {
+		.name = "Silicon Labs Si2183",
+		.symbol_rate_min = 1000000,
+		.symbol_rate_max = 45000000,
+		.caps =	FE_CAN_FEC_1_2 |
+			FE_CAN_FEC_2_3 |
+			FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 |
+			FE_CAN_FEC_7_8 |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK |
+			FE_CAN_QAM_16 |
+			FE_CAN_QAM_32 |
+			FE_CAN_QAM_64 |
+			FE_CAN_QAM_128 |
+			FE_CAN_QAM_256 |
+			FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_MUTE_TS |
+			FE_CAN_2G_MODULATION |
+			FE_CAN_MULTISTREAM
+	},
+
+	.get_tune_settings = si2183_get_tune_settings,
+
+	.init = si2183_init,
+	.sleep = si2183_sleep,
+
+	.set_frontend = si2183_set_frontend,
+	.tune = si2183_tune,
+	.get_frontend_algo = si2183_get_algo,
+
+	.read_status = si2183_read_status,
+	.read_signal_strength	= si2183_read_signal_strength,
+	.read_snr		= si2183_read_snr,
+	.read_ber		= si2183_read_ber,
+	.read_ucblocks		= si2183_read_ucblocks,
+
+	/*.set_property			= si2183_set_property,*/
+	.set_tone			= si2183_set_tone,
+	.diseqc_send_master_cmd 	= si2183_send_diseqc_msg,
+	.diseqc_send_burst		= si2183_diseqc_send_burst,
+#ifndef SI2183_USE_I2C_MUX
+	.i2c_gate_ctrl			= si2183_i2c_gate_ctrl,
+#endif
+};
+
+
+static struct si_base *match_base(struct i2c_adapter *i2c, u8 adr)
+{
+	struct si_base *p;
+
+	list_for_each_entry(p, &silist, silist)
+		if (p->i2c == i2c)// && p->adr == adr) lja: TO FIX
+			return p;
+	return NULL;
+}
+
+
+
+static int si2183_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct si2183_config *config = client->dev.platform_data;
+	struct si2183_dev *dev;
+	struct si_base *base;
+	int ret;
+
+	dev_dbg(&client->dev, "\n");
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		ret = -ENOMEM;
+		dev_err(&client->dev, "kzalloc() failed\n");
+		goto err;
+	}
+
+	base = match_base(client->adapter, client->addr);
+	if (base) {
+		base->count++;
+		dev->base = base;
+	} else {
+		base = kzalloc(sizeof(struct si_base), GFP_KERNEL);
+		if (!base)
+			goto err_kfree;
+		base->i2c = client->adapter;
+		base->adr = client->addr;
+		base->count = 1;
+		dev->base = base;
+		list_add(&base->silist, &silist);
+
+#ifdef SI2183_USE_I2C_MUX
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		/* create mux i2c adapter for tuner */
+		base->muxc = i2c_mux_alloc(client->adapter, &client->adapter->dev,
+					  1, 0, I2C_MUX_LOCKED,
+					  si2183_select, si2183_deselect);
+		if (!base->muxc) {
+			ret = -ENOMEM;
+			goto err_base_kfree;
+		}
+		base->muxc->priv = client;
+		ret = i2c_mux_add_adapter(base->muxc, 0, 0, 0);
+		if (ret)
+			goto err_base_kfree;
+		base->tuner_adapter = base->muxc->adapter[0];
+#else
+		/* create mux i2c adapter for tuners */
+		base->tuner_adapter = i2c_add_mux_adapter(client->adapter, &client->adapter->dev,
+				client, 0, 0, 0, si2183_select, si2183_deselect);
+		if (base->tuner_adapter == NULL) {
+			ret = -ENODEV;
+			goto err_base_kfree;
+		}
+#endif
+#else
+		base->tuner_adapter = client->adapter;
+		base->i2c_gate_client = client;
+#endif
+	}
+
+	/* create dvb_frontend */
+	memcpy(&dev->fe.ops, &si2183_ops, sizeof(struct dvb_frontend_ops));
+	dev->fe.demodulator_priv = client;
+	*config->i2c_adapter = base->tuner_adapter;
+	*config->fe = &dev->fe;
+	dev->ts_mode = config->ts_mode;
+	dev->ts_clock_inv = config->ts_clock_inv;
+	dev->ts_clock_gapped = config->ts_clock_gapped;
+	dev->fef_pin = config->fef_pin;
+	dev->fef_inv = config->fef_inv;
+	dev->agc_pin = config->agc_pin;
+	dev->ter_agc_inv = config->ter_agc_inv;
+	dev->sat_agc_inv = config->sat_agc_inv;
+	dev->RF_switch = config->RF_switch;
+	dev->rf_in  = config->rf_in;
+	dev->fw_loaded = false;
+	dev->stat_resp = 0;
+
+	dev->active_fe = 0;
+
+	i2c_set_clientdata(client, dev);
+
+#ifndef SI2183_USE_I2C_MUX
+	/* leave gate open for tuner to init */
+	si2183_i2c_gate_ctrl(&dev->fe, 1);
+#endif
+	dev_info(&client->dev, "Silicon Labs Si2183 successfully attached\n");
+	return 0;
+err_base_kfree:
+	kfree(base);
+err_kfree:
+	kfree(dev);
+err:
+	dev_dbg(&client->dev, "probe failed=%d\n", ret);
+	return ret;
+}
+
+static int si2183_remove(struct i2c_client *client)
+{
+	struct si2183_dev *dev = i2c_get_clientdata(client);
+
+	dev_dbg(&client->dev, "\n");
+
+	dev->base->count--;
+	if (dev->base->count == 0) {
+
+#ifdef SI2183_USE_I2C_MUX
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		i2c_mux_del_adapters(dev->base->muxc);
+#else
+		i2c_del_mux_adapter(dev->base->tuner_adapter);
+#endif
+#endif
+		list_del(&dev->base->silist);
+		kfree(dev->base);
+	}
+
+	dev->fe.ops.release = NULL;
+	dev->fe.demodulator_priv = NULL;
+
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id si2183_id_table[] = {
+	{"si2183", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, si2183_id_table);
+
+static struct i2c_driver si2183_driver = {
+	.driver = {
+		.name	= "si2183",
+	},
+	.probe		= si2183_probe,
+	.remove		= si2183_remove,
+	.id_table	= si2183_id_table,
+};
+
+module_i2c_driver(si2183_driver);
+
+MODULE_AUTHOR("Luis Alves <ljalvs@gmail.com>");
+MODULE_DESCRIPTION("Silicon Labs Si2183 DVB-T/T2/C/C2/S/S2 demodulator driver");
+MODULE_LICENSE("GPL");
diff -U 3 -H -d -r -N -- "a/drivers/media/dvb-frontends/si2183.h" "b/drivers/media/dvb-frontends/si2183.h"
--- "a/drivers/media/dvb-frontends/si2183.h"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/dvb-frontends/si2183.h"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,65 @@
+/*
+ * Silicon Labs Si2183(2) DVB-T/T2/C/C2/S/S2 demodulator driver
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ */
+
+#ifndef SI2183_H
+#define SI2183_H
+
+#include <linux/dvb/frontend.h>
+/*
+ * I2C address
+ * 0x64
+ */
+struct si2183_config {
+	/*
+	 * frontend
+	 * returned by driver
+	 */
+	struct dvb_frontend **fe;
+
+	/*
+	 * tuner I2C adapter
+	 * returned by driver
+	 */
+	struct i2c_adapter **i2c_adapter;
+
+	/* TS mode */
+#define SI2183_TS_PARALLEL	0x06
+#define SI2183_TS_SERIAL	0x03
+	u8 ts_mode;
+
+	/* TS clock inverted */
+	bool ts_clock_inv;
+
+	/* TS clock gapped */
+	bool ts_clock_gapped;
+
+	/* Tuner control pins */
+#define SI2183_MP_NOT_USED	1
+#define SI2183_MP_A		2
+#define SI2183_MP_B		3
+#define SI2183_MP_C		4
+#define SI2183_MP_D		5
+	int fef_pin;
+	bool fef_inv;
+	int agc_pin;
+	bool ter_agc_inv;
+	bool sat_agc_inv;
+
+	/*rf switch*/
+	void (*RF_switch)(struct i2c_adapter * i2c,u8 rf_in,u8 flag);
+	/*rf no.*/
+	u8 rf_in;
+};
+
+#endif
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/Kconfig" "b/drivers/media/tuners/Kconfig"
--- "a/drivers/media/tuners/Kconfig"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/tuners/Kconfig"	2018-01-17 18:35:26.648178000 +0800
@@ -256,6 +256,13 @@
 	help
 	  ITE Tech IT913x silicon tuner driver.
 
+config MEDIA_TUNER_AV201X
+	tristate "Airoha Technology AV201x silicon tuner"
+	depends on MEDIA_SUPPORT && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Airoha Technology AV201x silicon tuner driver.
+
 config MEDIA_TUNER_R820T
 	tristate "Rafael Micro R820T silicon tuner"
 	depends on MEDIA_SUPPORT && I2C
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/Makefile" "b/drivers/media/tuners/Makefile"
--- "a/drivers/media/tuners/Makefile"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/tuners/Makefile"	2018-01-17 18:36:19.701333000 +0800
@@ -40,6 +40,7 @@
 obj-$(CONFIG_MEDIA_TUNER_R820T) += r820t.o
 obj-$(CONFIG_MEDIA_TUNER_MXL301RF) += mxl301rf.o
 obj-$(CONFIG_MEDIA_TUNER_QM1D1C0042) += qm1d1c0042.o
+obj-$(CONFIG_MEDIA_TUNER_AV201X) += av201x.o
 obj-$(CONFIG_MEDIA_TUNER_M88RS6000T) += m88rs6000t.o
 
 ccflags-y += -I$(srctree)/drivers/media/dvb-core
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/av201x.c" "b/drivers/media/tuners/av201x.c"
--- "a/drivers/media/tuners/av201x.c"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/tuners/av201x.c"	2018-01-10 20:21:52.803346000 +0800
@@ -0,0 +1,272 @@
+/*
+ * AV201x Airoha Technology silicon tuner driver
+ *
+ * Copyright (C) 2014 Luis Alves <ljalvs@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "av201x.h"
+#include "av201x_priv.h"
+
+/* write multiple (continuous) registers */
+static int av201x_wrm(struct av201x_priv *priv, u8 *buf, int len)
+{
+	int ret;
+	struct i2c_msg msg = {
+		.addr = priv->cfg->i2c_address,
+		.flags = 0, .buf = buf, .len = len };
+
+	dev_dbg(&priv->i2c->dev, "%s() i2c wrm @0x%02x (len=%d) ",
+		__func__, buf[0], len);
+
+	ret = i2c_transfer(priv->i2c, &msg, 1);
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c wrm err(%i) @0x%02x (len=%d)\n",
+			KBUILD_MODNAME, ret, buf[0], len);
+		return ret;
+	}
+	return 0;
+}
+
+/* write one register */
+static int av201x_wr(struct av201x_priv *priv, u8 addr, u8 data)
+{
+	u8 buf[] = { addr, data };
+	return av201x_wrm(priv, buf, 2);
+}
+
+/* read multiple (continuous) registers starting at addr */
+static int av201x_rdm(struct av201x_priv *priv, u8 addr, u8 *buf, int len)
+{
+	int ret;
+	struct i2c_msg msg[] = {
+		{ .addr = priv->cfg->i2c_address, .flags = 0,
+			.buf = &addr, .len = 1 },
+		{ .addr = priv->cfg->i2c_address, .flags = I2C_M_RD,
+			.buf = buf, .len = len }
+	};
+
+	dev_dbg(&priv->i2c->dev, "%s() i2c rdm @0x%02x (len=%d)\n",
+		__func__, addr, len);
+
+	ret = i2c_transfer(priv->i2c, msg, 2);
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c rdm err(%i) @0x%02x (len=%d)\n",
+			KBUILD_MODNAME, ret, addr, len);
+		return ret;
+	}
+	return 0;
+}
+
+/* read one register */
+static int av201x_rd(struct av201x_priv *priv, u8 addr, u8 *data)
+{
+	return av201x_rdm(priv, addr, data, 1);
+}
+
+/* read register, apply masks, write back */
+static int av201x_regmask(struct av201x_priv *priv,
+	u8 reg, u8 setmask, u8 clrmask)
+{
+	int ret;
+	u8 b = 0;
+	if (clrmask != 0xff) {
+		ret = av201x_rd(priv, reg, &b);
+		if (ret)
+			return ret;
+		b &= ~clrmask;
+	}
+	return av201x_wr(priv, reg, b | setmask);
+}
+
+static int av201x_wrtable(struct av201x_priv *priv,
+	struct av201x_regtable *regtable, int len)
+{
+	int ret, i;
+
+	for (i = 0; i < len; i++) {
+		ret = av201x_regmask(priv, regtable[i].addr,
+			regtable[i].setmask, regtable[i].clrmask);
+		if (ret)
+			return ret;
+		if (regtable[i].sleep)
+			msleep(regtable[i].sleep);
+	}
+	return 0;
+}
+
+static int av201x_release(struct dvb_frontend *fe)
+{
+	struct av201x_priv *priv = fe->tuner_priv;
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static int av201x_init(struct dvb_frontend *fe)
+{
+	struct av201x_priv *priv = fe->tuner_priv;
+	int ret;
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+
+	ret = av201x_wrtable(priv, av201x_inittuner0,
+		ARRAY_SIZE(av201x_inittuner0));
+
+	switch (priv->cfg->id) {
+	case ID_AV2011:
+		ret |= av201x_wrtable(priv, av201x_inittuner1a,
+			ARRAY_SIZE(av201x_inittuner1a));
+		break;
+	case ID_AV2012:
+	default:
+		ret |= av201x_wrtable(priv, av201x_inittuner1b,
+			ARRAY_SIZE(av201x_inittuner1b));
+		break;
+	}
+
+	ret |= av201x_wrtable(priv, av201x_inittuner2,
+		ARRAY_SIZE(av201x_inittuner2));
+
+	ret |= av201x_wr(priv, REG_TUNER_CTRL, 0x96);
+
+	msleep(120);
+
+	if (ret)
+		dev_dbg(&priv->i2c->dev, "%s() failed\n", __func__);
+	return ret;
+}
+
+static int av201x_sleep(struct dvb_frontend *fe)
+{
+	struct av201x_priv *priv = fe->tuner_priv;
+	int ret;
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+
+	ret = av201x_regmask(priv, REG_TUNER_CTRL, AV201X_SLEEP, 0);
+	if (ret)
+		dev_dbg(&priv->i2c->dev, "%s() failed\n", __func__);
+	return ret;
+}
+
+static int av201x_set_params(struct dvb_frontend *fe)
+{
+	struct av201x_priv *priv = fe->tuner_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u32 n, bw, bf;
+	u8 buf[5];
+	int ret;
+
+	dev_dbg(&priv->i2c->dev, "%s() delivery_system=%d frequency=%d " \
+			"symbol_rate=%d\n", __func__,
+			c->delivery_system, c->frequency, c->symbol_rate);
+
+	/*
+	   ** PLL setup **
+	   RF = (pll_N * ref_freq) / pll_M
+	   pll_M = fixed 0x10000
+	   PLL output is divided by 2
+	   REG_FN = pll_M<24:0>
+	*/
+	buf[0] = REG_FN;
+	n = DIV_ROUND_CLOSEST(c->frequency, priv->cfg->xtal_freq);
+	buf[1] = (n > 0xff) ? 0xff : (u8) n;
+	n = DIV_ROUND_CLOSEST((c->frequency / 1000) << 17, priv->cfg->xtal_freq / 1000);
+	buf[2] = (u8) (n >> 9);
+	buf[3] = (u8) (n >> 1);
+	buf[4] = (u8) (((n << 7) & 0x80) | 0x50);
+	ret = av201x_wrm(priv, buf, 5);
+	if (ret)
+		goto exit;
+
+	msleep(20);
+
+	/* set bandwidth */
+	bw = (c->symbol_rate / 1000) * 135/200;
+	if (c->symbol_rate < 6500000)
+		bw += 6000;
+	bw += 2000;
+	bw *= 108/100;
+
+	/* check limits (4MHz < bw < 40MHz) */
+	if (bw > 40000)
+		bw = 40000;
+	else if (bw < 4000)
+		bw = 4000;
+
+	/* bandwidth step = 211kHz */
+	bf = DIV_ROUND_CLOSEST(bw * 127, 21100);
+	ret = av201x_wr(priv, REG_BWFILTER, (u8) bf);
+
+	/* enable fine tune agc */
+	ret |= av201x_wr(priv, REG_FT_CTRL, AV201X_FT_EN | AV201X_FT_BLK);
+
+	ret |= av201x_wr(priv, REG_TUNER_CTRL, 0x96);
+	msleep(20);
+exit:
+	if (ret)
+		dev_dbg(&priv->i2c->dev, "%s() failed\n", __func__);
+	return ret;
+}
+
+static const struct dvb_tuner_ops av201x_tuner_ops = {
+	.info = {
+		.name           = "Airoha Technology AV201x",
+
+		.frequency_min  = 850000,
+		.frequency_max  = 2300000,
+		.frequency_step = 206,
+	},
+
+	.release = av201x_release,
+
+	.init = av201x_init,
+	.sleep = av201x_sleep,
+	.set_params = av201x_set_params,
+};
+
+struct dvb_frontend *av201x_attach(struct dvb_frontend *fe,
+		struct av201x_config *cfg, struct i2c_adapter *i2c)
+{
+	struct av201x_priv *priv = NULL;
+
+	priv = kzalloc(sizeof(struct av201x_priv), GFP_KERNEL);
+	if (priv == NULL) {
+		dev_dbg(&i2c->dev, "%s() attach failed\n", __func__);
+		return NULL;
+	}
+
+	priv->cfg = cfg;
+	priv->i2c = i2c;
+
+	dev_info(&priv->i2c->dev,
+		"%s: Airoha Technology AV201x successfully attached\n",
+		KBUILD_MODNAME);
+
+	memcpy(&fe->ops.tuner_ops, &av201x_tuner_ops,
+			sizeof(struct dvb_tuner_ops));
+
+	fe->tuner_priv = priv;
+	return fe;
+}
+EXPORT_SYMBOL(av201x_attach);
+
+MODULE_DESCRIPTION("Airoha Technology AV201x silicon tuner driver");
+MODULE_AUTHOR("Luis Alves <ljalvs@gmail.com>");
+MODULE_LICENSE("GPL");
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/av201x.h" "b/drivers/media/tuners/av201x.h"
--- "a/drivers/media/tuners/av201x.h"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/tuners/av201x.h"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,55 @@
+/*
+ * AV201x Airoha Technology silicon tuner driver
+ *
+ * Copyright (C) 2014 Luis Alves <ljalvs@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef AV201X_H
+#define AV201X_H
+
+#include <linux/kconfig.h>
+#include "dvb_frontend.h"
+
+typedef enum av201x_id {
+	ID_AV2011,
+	ID_AV2012,
+	ID_AV2018,
+} av201x_id_t;
+
+struct av201x_config {
+	/* tuner i2c address */
+	u8 i2c_address;
+	/* tuner type */
+	av201x_id_t id;
+
+	/* crystal freq in kHz */
+	u32 xtal_freq;
+};
+
+#if IS_ENABLED(CONFIG_MEDIA_TUNER_AV201X)
+extern struct dvb_frontend *av201x_attach(struct dvb_frontend *fe,
+		struct av201x_config *cfg, struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *av201x_attach(struct dvb_frontend *fe,
+		struct av201x_config *cfg, struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* AV201X_H */
diff -U 3 -H -d -r -N -- "a/drivers/media/tuners/av201x_priv.h" "b/drivers/media/tuners/av201x_priv.h"
--- "a/drivers/media/tuners/av201x_priv.h"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/tuners/av201x_priv.h"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,110 @@
+/*
+ * AV201x Airoha Technology silicon tuner driver
+ *
+ * Copyright (C) 2014 Luis Alves <ljalvs@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef AV201X_PRIV_H
+#define AV201X_PRIV_H
+
+struct av201x_priv {
+	struct av201x_config *cfg;
+	struct i2c_adapter *i2c;
+};
+
+enum av201x_regs_addr {
+	REG_FN		= 0x00,
+	REG_BWFILTER	= 0x05,
+	REG_TUNER_STAT	= 0x0b,
+	REG_TUNER_CTRL	= 0x0c,
+	REG_FT_CTRL	= 0x25,
+};
+
+/* REG_TUNER_STAT */
+#define AV201X_PLLLOCK		(1<<0)
+
+/* REG_TUNER_CTRL */
+#define AV201X_SLEEP		(1<<5)
+#define AV201X_RFLP		(1<<6)
+
+/* REG_FT_CTRL */
+#define AV201X_FT_EN		(1<<1)
+#define AV201X_FT_BLK		(1<<2)
+
+struct av201x_regtable {
+	u8 addr;
+	u8 setmask;
+	u8 clrmask;
+	int sleep;
+};
+
+static struct av201x_regtable av201x_inittuner0[] = {
+	{0x00, 0x38, 0xff, 0},
+	{0x01, 0x00, 0xff, 0},
+	{0x02, 0x00, 0xff, 0},
+	{0x03, 0x50, 0xff, 0},
+	{0x04, 0x1f, 0xff, 0},
+	{0x05, 0xa3, 0xff, 0},
+	{0x06, 0xfd, 0xff, 0},
+	{0x07, 0x58, 0xff, 0},
+	{0x08, 0x36, 0xff, 0},
+	{0x09, 0xc2, 0xff, 0},
+	{0x0a, 0x88, 0xff, 0},
+	{0x0b, 0xb4, 0xff, 20},
+	{0x0d, 0x40, 0xff, 0},
+};
+
+static struct av201x_regtable av201x_inittuner1a[] = {
+	{0x0e, 0x94, 0xff, 0},
+	{0x0f, 0x9a, 0xff, 0},
+};
+
+static struct av201x_regtable av201x_inittuner1b[] = {
+	{0x0e, 0x5b, 0xff, 0},
+	{0x0f, 0x6a, 0xff, 0},
+};
+
+static struct av201x_regtable av201x_inittuner2[] = {
+	{0x10, 0x66, 0xff, 0},
+	{0x11, 0x40, 0xff, 0},
+	{0x12, 0x80, 0xff, 0},
+	{0x13, 0x2b, 0xff, 0},
+	{0x14, 0x6a, 0xff, 0},
+	{0x15, 0x50, 0xff, 0},
+	{0x16, 0x91, 0xff, 0},
+	{0x17, 0x27, 0xff, 0},
+	{0x18, 0x8f, 0xff, 0},
+	{0x19, 0xcc, 0xff, 0},
+	{0x1a, 0x21, 0xff, 0},
+	{0x1b, 0x10, 0xff, 0},
+	{0x1c, 0x80, 0xff, 0},
+	{0x1d, 0x02, 0xff, 0},
+	{0x1e, 0xf5, 0xff, 0},
+	{0x1f, 0x7f, 0xff, 0},
+	{0x20, 0x4a, 0xff, 0},
+	{0x21, 0x9b, 0xff, 0},
+	{0x22, 0xe0, 0xff, 0},
+	{0x23, 0xe0, 0xff, 0},
+	{0x24, 0x36, 0xff, 0},
+	{0x25, 0x00, 0xff, 0},
+	{0x26, 0xab, 0xff, 0},
+	{0x27, 0x97, 0xff, 0},
+	{0x28, 0xc5, 0xff, 0},
+	{0x29, 0xa8, 0xff, 20},
+};
+
+#endif /* AV201X_PRIV_H */
--- "a/drivers/media/tuners/tda18273_priv.h"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/tuners/tda18273_priv.h"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,1427 @@
+/*
+	tda18273-priv.h - private header for the NXP TDA18273 silicon tuner
+	Copyright (C) 2014 CrazyCat <crazycat69@narod.ru>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef __TDA18273_PRIV
+#define __TDA18273_PRIV
+
+#define TDA18273_TUNER_RESET		0
+
+#define TDA_FREQ_LOW_BAND		1
+#define TDA_FREQ_MID_BAND		2
+#define TDA_FREQ_HIGH_BAND		4
+
+#define TDA_AGC_115dBuV			1
+#define TDA_AGC_112dBuV			2
+#define TDA_AGC_109dBuV			3
+#define TDA_AGC_106dBuV			4
+#define TDA_AGC_103dBuV			5
+#define TDA_AGC_EXTERNAL		6
+#define TDA_AGC_DISABLE			7
+
+#define TDA_PLL_CP_50uA			6
+#define TDA_PLL_CP_125uA		7
+#define TDA_PLL_CP_250uA		0x0e
+#define TDA_PLL_CP_650uA		0x0f
+
+#define TDA_PLLref_DIVIDER_64		3
+#define TDA_PLLref_DIVIDER_24		2
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef unsigned char		UInt8;
+typedef unsigned int		UInt32;
+typedef int			Int32;
+
+
+/* Result codes */
+#define TDA_RESULT_SUCCESS		0
+#define TDA_RESULT_RESET_FAILURE	1
+#define TDA_RESULT_I2C_WRITE_FAILURE	2
+#define TDA_RESULT_I2C_READ_FAILURE	3
+#define TDA_RESULT_OUT_OF_RANGE		5
+
+
+/* Product id */
+#define TDA_DEVICE_TYPE		18273
+
+/* Register Bit-Field Definition */
+typedef struct _TDA18273_BitField_t {
+	UInt8 Address;
+	UInt8 PositionInBits;
+	UInt8 WidthInBits;
+	UInt8 Attributes;
+} TDA18273_BitField_t, *pTDA18273_BitField_t;
+
+/* Bus Access */
+typedef enum _tmbslFrontEndBusAccess_t {
+    Bus_RW = 0x00,						/* RW Bus access */
+    Bus_NoRead = 0x01,					/* No Read Bus access */
+    Bus_NoWrite = 0x02,					/* No Write Bus access */
+    Bus_None = Bus_NoRead|Bus_NoWrite,	/* No Bus access. Update RegMap only */
+    Bus_Max
+} tmbslFrontEndBusAccess_t;
+
+typedef enum tmPowerState
+{
+    tmPowerOn = 0,                      /* Device powered on      (D0 state) */
+    tmPowerStandby,                     /* Device power standby   (D1 state) */
+    tmPowerSuspend,                     /* Device power suspended (D2 state) */
+    tmPowerOff,                         /* Device powered off     (D3 state) */
+    tmPowerMax                          /* Device power max */
+}   tmPowerState_t, *ptmPowerState_t;
+
+typedef enum _TDA18273PowerState_t {
+    TDA18273_PowerNormalMode = 0,                                 /* Device normal mode */
+    TDA18273_PowerStandbyWithXtalOn,                              /* Device standby mode with Xtal Output */
+    TDA18273_PowerStandby,                                        /* Device standby mode */
+    TDA18273_PowerMax
+} TDA18273PowerState_t, *pTDA18273PowerState_t;
+
+typedef enum _TDA18273StandardMode_t {
+    TDA18273_StandardMode_Unknown = 0,                  /* Unknown standard */
+    TDA18273_QAM_6MHz,                                  /* Digital TV QAM 6MHz */
+    TDA18273_QAM_8MHz,                                  /* Digital TV QAM 8MHz */
+    TDA18273_ATSC_6MHz,                                 /* Digital TV ATSC 6MHz */
+    TDA18273_ISDBT_6MHz,                                /* Digital TV ISDBT 6MHz */
+    TDA18273_DVBT_1_7MHz,                               /* Digital TV DVB-T/T2 6MHz */
+    TDA18273_DVBT_6MHz,                                 /* Digital TV DVB-T/T2 6MHz */
+    TDA18273_DVBT_7MHz,                                 /* Digital TV DVB-T/T2 7MHz */
+    TDA18273_DVBT_8MHz,                                 /* Digital TV DVB-T/T2 8MHz */
+    TDA18273_DVBT_10MHz,                                /* Digital TV DVB-T/T2 10MHz */     
+    TDA18273_DMBT_8MHz,                                 /* Digital TV DMB-T 8MHz */
+    TDA18273_FM_Radio,                                  /* Analog FM Radio */
+    TDA18273_ANLG_MN,                                   /* Analog TV M/N */
+    TDA18273_ANLG_B,                                    /* Analog TV B */
+    TDA18273_ANLG_GH,                                   /* Analog TV G/H */
+    TDA18273_ANLG_I,                                    /* Analog TV I */
+    TDA18273_ANLG_DK,                                   /* Analog TV D/K */
+    TDA18273_ANLG_L,                                    /* Analog TV L */
+    TDA18273_ANLG_LL,                                   /* Analog TV L' */
+    TDA18273_Scanning,                                  /* Analog Preset Blind Scanning */
+    TDA18273_ScanXpress,                                /* ScanXpress */
+    TDA18273_StandardMode_Max
+} TDA18273StandardMode_t, *pTDA18273StandardMode_t;
+
+/* TDA18273 Driver State Machine */
+typedef enum _TDA18273HwState_t {
+    TDA18273_HwState_Unknown = 0,   /* Hw State Unknown */
+    TDA18273_HwState_InitNotDone,   /* Hw Init Not Done */
+    TDA18273_HwState_InitPending,   /* Hw Init Pending */
+    TDA18273_HwState_InitDone,      /* Hw Init Done */
+    TDA18273_HwState_SetStdDone,    /* Set Standard Done */
+    TDA18273_HwState_SetRFDone,     /* Set RF Done */
+    TDA18273_HwState_SetFineRFDone, /* Set Fine RF Done */
+    TDA18273_HwState_Max
+} TDA18273HwState_t, *pTDA18273HwState_t;
+
+typedef enum _TDA18273HwStateCaller_t {
+    TDA18273_HwStateCaller_Unknown = 0, /* Caller Unknown */
+    TDA18273_HwStateCaller_SetPower,    /* Caller SetPowerState */
+    TDA18273_HwStateCaller_HwInit,      /* Caller HwInit */
+    TDA18273_HwStateCaller_SetStd,      /* Caller SetStandardMode */
+    TDA18273_HwStateCaller_SetRF,       /* Caller SetRF */
+    TDA18273_HwStateCaller_SetFineRF,   /* Caller SetFineRF */
+    TDA18273_HwStateCaller_GetRSSI,     /* Caller GetRSSI */
+    TDA18273_HwStateCaller_SetRawRF,    /* Caller SetRawRF */
+    TDA18273_HwStateCaller_Max
+} TDA18273HwStateCaller_t, *pTDA18273HwStateCaller_t;
+
+/* TDA18273 specific powerstate bits: */
+typedef enum _TDA18273SM_Reg_t {
+    TDA18273_SM_NONE    = 0x00, /* No SM bit to set */
+    TDA18273_SM_XT      = 0x01, /* SM_XT bit to set */
+    TDA18273_SM         = 0x02  /* SM bit to set */
+} TDA18273SM_Reg_t, *pTDA18273SM_Reg_t;
+
+/* TDA18273 specific MSM: */
+typedef enum _TDA18273MSM_t {
+    TDA18273_MSM_Calc_PLL       = 0x01, /* Calc_PLL bit */
+    TDA18273_MSM_RC_Cal         = 0x02, /* RC_Cal bit */
+    TDA18273_MSM_IR_CAL_Wanted  = 0x04, /* IR_CAL_Wanted bit */
+    TDA18273_MSM_IR_Cal_Image   = 0x08, /* IR_Cal_Image bit */
+    TDA18273_MSM_IR_CAL_Loop    = 0x10, /* IR_CAL_Loop bit */
+    TDA18273_MSM_RF_CAL         = 0x20, /* RF_CAL bit */
+    TDA18273_MSM_RF_CAL_AV      = 0x40, /* RF_CAL_AV bit */
+    TDA18273_MSM_RSSI_Meas      = 0x80, /* RSSI_Meas bit */
+    /* Performs all CALs except IR_CAL */
+    TDA18273_MSM_HwInit         = TDA18273_MSM_Calc_PLL\
+                                    |TDA18273_MSM_RC_Cal\
+                                    |TDA18273_MSM_RF_CAL,
+    /* Performs all IR_CAL */
+    TDA18273_MSM_IrCal          = TDA18273_MSM_IR_Cal_Image\
+                                    |TDA18273_MSM_IR_CAL_Loop,
+    TDA18273_MSM_SetRF          = TDA18273_MSM_Calc_PLL\
+                                    |TDA18273_MSM_RF_CAL_AV,
+    TDA18273_MSM_GetPowerLevel  = TDA18273_MSM_RSSI_Meas
+} TDA18273MSM_t, *pTDA18273MSM_t;
+
+/* TDA18273 specific IRQ clear: */
+typedef enum _TDA18273IRQ_t {
+    TDA18273_IRQ_MSM_RCCal      = 0x01, /* MSM_RCCal bit */
+    TDA18273_IRQ_MSM_IRCAL      = 0x02, /* MSM_IRCAL bit */
+    TDA18273_IRQ_MSM_RFCal      = 0x04, /* MSM_RFCal bit */
+    TDA18273_IRQ_MSM_LOCalc     = 0x08, /* MSM_LOCalc bit */
+    TDA18273_IRQ_MSM_RSSI       = 0x10, /* MSM_RSSI bit */
+    TDA18273_IRQ_XtalCal        = 0x20, /* XtalCal bit */
+    TDA18273_IRQ_Global         = 0x80, /* IRQ_status bit */
+    TDA18273_IRQ_HwInit         = TDA18273_IRQ_MSM_RCCal\
+                                    |TDA18273_IRQ_MSM_RFCal\
+                                    |TDA18273_IRQ_MSM_LOCalc\
+                                    |TDA18273_IRQ_MSM_RSSI,
+    TDA18273_IRQ_IrCal          = TDA18273_IRQ_MSM_IRCAL\
+                                    |TDA18273_IRQ_MSM_LOCalc\
+                                    |TDA18273_IRQ_MSM_RSSI,
+    TDA18273_IRQ_SetRF          = TDA18273_IRQ_MSM_RFCal\
+                                    |TDA18273_IRQ_MSM_LOCalc,
+    TDA18273_IRQ_GetPowerLevel  = TDA18273_IRQ_MSM_RSSI
+} TDA18273IRQ_t, *pTDA18273IRQ_t;
+
+/* TDA18273 Standard settings: */
+typedef enum _TDA18273LPF_t {
+    TDA18273_LPF_6MHz = 0,  /* 6MHz LPFc */
+    TDA18273_LPF_7MHz,      /* 7MHz LPFc */
+    TDA18273_LPF_8MHz,      /* 8MHz LPFc */
+    TDA18273_LPF_9MHz,      /* 9MHz LPFc */
+    TDA18273_LPF_1_5MHz,    /* 1.5MHz LPFc */
+    TDA18273_LPF_Max
+} TDA18273LPF_t, *pTDA18273LPF_t;
+
+typedef enum _TDA18273LPFOffset_t {
+    TDA18273_LPFOffset_0pc = 0,     /* LPFc 0% */
+    TDA18273_LPFOffset_min_4pc,     /* LPFc -4% */
+    TDA18273_LPFOffset_min_8pc,     /* LPFc -8% */
+    TDA18273_LPFOffset_min_12pc,    /* LPFc -12% */
+    TDA18273_LPFOffset_Max
+} TDA18273LPFOffset_t, *pTDA18273LPFOffset_t;
+
+typedef enum TDA18273DC_Notch_IF_PPF_t {
+    TDA18273_DC_Notch_IF_PPF_Disabled = 0,  /* IF Notch Disabled */
+    TDA18273_DC_Notch_IF_PPF_Enabled,       /* IF Notch Enabled */
+    TDA18273_DC_Notch_IF_PPF_Max
+} TDA18273DC_Notch_IF_PPF_t, *pTDA18273DC_Notch_IF_PPF_t;
+
+typedef enum _TDA18273IF_HPF_t {
+    TDA18273_IF_HPF_Disabled = 0,   /* IF HPF disabled */
+    TDA18273_IF_HPF_0_4MHz,         /* IF HPF 0.4MHz */
+    TDA18273_IF_HPF_0_85MHz,        /* IF HPF 0.85MHz */
+    TDA18273_IF_HPF_1MHz,           /* IF HPF 1MHz */
+    TDA18273_IF_HPF_1_5MHz,         /* IF HPF 1.5MHz */
+    TDA18273_IF_HPF_Max
+} TDA18273IF_HPF_t, *pTDA18273IF_HPF_t;
+
+typedef enum _TDA18273IF_Notch_t {
+    TDA18273_IF_Notch_Disabled = 0, /* IF Notch Disabled */
+    TDA18273_IF_Notch_Enabled,      /* IF Notch Enabled */
+    TDA18273_IF_Notch_Max
+} TDA18273IF_Notch_t, *pTDA18273IF_Notch_t;
+
+typedef enum _TDA18273IFnotchToRSSI_t {
+    TDA18273_IFnotchToRSSI_Disabled = 0,    /* IFnotchToRSSI Disabled */
+    TDA18273_IFnotchToRSSI_Enabled,         /* IFnotchToRSSI Enabled */
+    TDA18273_IFnotchToRSSI_Max
+} TDA18273IFnotchToRSSI_t, *pTDA18273IFnotchToRSSI_t;
+
+typedef enum _TDA18273AGC1_TOP_I2C_DN_UP_t {
+    TDA18273_AGC1_TOP_I2C_DN_UP_d88_u82dBuV = 0,    /* AGC1 TOP I2C DN/UP down 88 up 82 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d90_u84dBuV,        /* AGC1 TOP I2C DN/UP down 90 up 84 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89wdBuV,       /* AGC1 TOP I2C DN/UP down 95 up 89 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d93_u87dBuV,        /* AGC1 TOP I2C DN/UP down 93 up 87 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,        /* AGC1 TOP I2C DN/UP down 95 up 89 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d99_u84dBuV,        /* AGC1 TOP I2C DN/UP down 99 up 84 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d100_u82dBuV,       /* AGC1 TOP I2C DN/UP down 100 up 82 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d100_u94bisdBuV,    /* AGC1 TOP I2C DN/UP down 100 up 94 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d102_u82dBuV,       /* AGC1 TOP I2C DN/UP down 102 up 82 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d102_u84dBuV,       /* AGC1 TOP I2C DN/UP down 102 up 84 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_d100_u94dBuV,       /* AGC1 TOP I2C DN/UP down 100 up 94 dBuV */
+    TDA18273_AGC1_TOP_I2C_DN_UP_Max
+} TDA18273AGC1_TOP_I2C_DN_UP_t, *pTDA18273AGC1_TOP_I2C_DN_UP_t;
+
+typedef enum _TDA18273AGC1_Adapt_TOP_DN_UP_t {
+    TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step = 0,   /* AGC1 Adapt TOP DN/UP 0 Step */
+    TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,       /* AGC1 Adapt TOP DN/UP 1 Step */
+    TDA18273_AGC1_Adapt_TOP_DN_UP_2_Step,       /* AGC1 Adapt TOP DN/UP 2 Step */
+    TDA18273_AGC1_Adapt_TOP_DN_UP_3_Step,       /* AGC1 Adapt TOP DN/UP 3 Step */
+    TDA18273_AGC1_Adapt_TOP_DN_UP_Max
+} TDA18273AGC1_Adapt_TOP_DN_UP_t, *pTDA18273AGC1_Adapt_TOP_DN_UP_t;
+
+typedef enum _TDA18273AGC1_Mode_t {
+    TDA18273_AGC1_Mode_No_Mode = 0,         /* AGC1 Mode */
+    TDA18273_AGC1_Mode_TOP_ADAPT,           /* AGC1 Mode: TOP ADAPT */
+    TDA18273_AGC1_Mode_LNA_ADAPT,           /* AGC1 Mode: LNA ADAPT */
+    TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT, /* AGC1 Mode: LNA ADAPT & TOP ADAPT */
+    TDA18273_AGC1_Mode_FREEZE,              /* AGC1 Mode: FREEZE */
+    TDA18273_AGC1_Mode_WIDE,                /* AGC1 Mode: WIDE */
+    TDA18273_AGC1_Mode_LNA_ADAPT_FREEZE,    /* AGC1 Mode: LNA ADAPT & FREEZE */
+    TDA18273_AGC1_Mode_LNA_ADAPT_WIDE,      /* AGC1 Mode: LNA ADAPT & WIDE */
+    TDA18273_AGC1_Mode_Max
+} TDA18273AGC1_Mode_t, *pTDA18273AGC1_Mode_t;
+
+typedef enum _TDA18273Range_LNA_Adapt_t {
+    TDA18273_Range_LNA_Adapt_20dB_8dB = 0,  /* Range LNA Adapt 20dB-8dB */
+    TDA18273_Range_LNA_Adapt_20dB_11dB,     /* Range LNA Adapt 20dB-11dB */
+    TDA18273_Range_LNA_Adapt_Max
+} TDA18273Range_LNA_Adapt_t, *pTDA18273Range_LNA_Adapt_t;
+
+typedef enum _TDA18273LNA_Adapt_RFAGC_Gv_Threshold {
+    TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB = 0,  /* 18.25dB */
+    TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_16_75dB,      /* 16.75dB */
+    TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_15_25dB,      /* 15.25dB */
+    TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_13_75dB,      /* 13.75dB */
+    TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_Max
+} TDA18273LNA_Adapt_RFAGC_Gv_Threshold, *pTDA18273LNA_Adapt_RFAGC_Gv_Threshold;
+
+typedef enum _TDA18273AGC1_Top_Adapt_RFAGC_Gv_Threshold {
+    TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB = 0, /* 16.75dB */
+    TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,     /* 15.25dB */
+    TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_13_75dB,     /* 13.75dB */
+    TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_12_25dB,     /* 12.25dB */
+    TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_Max
+} TDA18273AGC1_Top_Adapt_RFAGC_Gv_Threshold, *pTDA18273AGC1_Top_Adapt_RFAGC_Gv_Threshold;
+
+typedef enum _TDA18273AGC1_DN_Time_Constant_t {
+    TDA18273_AGC1_DN_Time_Constant_32_752ms = 0, /* 32.752 ms */
+	TDA18273_AGC1_DN_Time_Constant_16_376ms,     /* 16.376 ms */
+	TDA18273_AGC1_DN_Time_Constant_8_188ms,      /* 8.188 ms  */
+	TDA18273_AGC1_DN_Time_Constant_4_094ms       /* 4.094 ms  */
+} TDA18273AGC1_DN_Time_Constant_t, *pTDA18273AGC1_DN_Time_Constant_t;
+
+typedef enum _TDA18273AGC2_TOP_DN_UP_t {
+    TDA18273_AGC2_TOP_DN_UP_d88_u81dBuV = 0,    /* AGC2 TOP DN/UP down 88 up 81 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d90_u83dBuV,        /* AGC2 TOP DN/UP down 90 up 83 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d93_u86dBuV,        /* AGC2 TOP DN/UP down 93 up 86 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d95_u88dBuV,        /* AGC2 TOP DN/UP down 95 up 88 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d88_u82dBuV,        /* AGC2 TOP DN/UP down 88 up 82 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,        /* AGC2 TOP DN/UP down 90 up 84 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d93_u87dBuV,        /* AGC2 TOP DN/UP down 93 up 87 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_d95_u89dBuV,        /* AGC2 TOP DN/UP down 95 up 89 dBuV */
+    TDA18273_AGC2_TOP_DN_UP_Max
+} TDA18273AGC2_TOP_DN_UP_t, *pTDA18273AGC2_TOP_DN_UP_t;
+
+typedef enum _TDA18273AGC2_DN_Time_Constant_t {
+	TDA18273_AGC2_DN_Time_Constant_16_376ms = 0, /* 16.376 ms */
+	TDA18273_AGC2_DN_Time_Constant_8_188ms,      /* 8.188 ms  */
+	TDA18273_AGC2_DN_Time_Constant_4_094ms,      /* 4.094 ms  */
+	TDA18273_AGC2_DN_Time_Constant_2_047ms,      /* 2.047 ms  */
+} TDA18273AGC2_DN_Time_Constant_t, *pTDA18273AGC2_DN_Time_Constant_t;
+
+typedef enum _TDA18273AGC3_TOP_I2C_t {
+    TDA18273_AGC3_TOP_I2C_94dBuV = 0,   /* AGC3 TOP I2C 94 dBuV */
+    TDA18273_AGC3_TOP_I2C_96dBuV,       /* AGC3 TOP I2C 96 dBuV */
+    TDA18273_AGC3_TOP_I2C_98dBuV,       /* AGC3 TOP I2C 98 dBuV */
+    TDA18273_AGC3_TOP_I2C_100dBuV,      /* AGC3 TOP I2C 100 dBuV */
+    TDA18273_AGC3_TOP_I2C_102dBuV,      /* AGC3 TOP I2C 102 dBuV */
+    TDA18273_AGC3_TOP_I2C_104dBuV,      /* AGC3 TOP I2C 104 dBuV */
+    TDA18273_AGC3_TOP_I2C_106dBuV,      /* AGC3 TOP I2C 106 dBuV */
+    TDA18273_AGC3_TOP_I2C_107dBuV,      /* AGC3 TOP I2C 107 dBuV */
+    TDA18273_AGC3_TOP_I2C_Max
+} TDA18273AGC3_TOP_I2C_t, *pTDA18273AGC3_TOP_I2C_t;
+
+typedef enum _TDA18273AGC4_TOP_DN_UP_t {
+    TDA18273_AGC4_TOP_DN_UP_d105_u99dBuV = 0,   /* AGC4 TOP DN/UP down 105 up 99 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,      /* AGC4 TOP DN/UP down 105 up 100 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d105_u101dBuV,      /* AGC4 TOP DN/UP down 105 up 101 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d107_u101dBuV,      /* AGC4 TOP DN/UP down 107 up 101 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d107_u102dBuV,      /* AGC4 TOP DN/UP down 107 up 102 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d107_u103dBuV,      /* AGC4 TOP DN/UP down 107 up 103 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d108_u102dBuV,      /* AGC4 TOP DN/UP down 108 up 102 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d109_u103dBuV,      /* AGC4 TOP DN/UP down 109 up 103 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d109_u104dBuV,      /* AGC4 TOP DN/UP down 109 up 104 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d109_u105dBuV,      /* AGC4 TOP DN/UP down 109 up 105 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d110_u104dBuV,      /* AGC4 TOP DN/UP down 110 up 104 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,      /* AGC4 TOP DN/UP down 110 up 105 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d110_u106dBuV,      /* AGC4 TOP DN/UP down 110 up 106 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d112_u106dBuV,      /* AGC4 TOP DN/UP down 112 up 106 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d112_u107dBuV,      /* AGC4 TOP DN/UP down 112 up 107 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_d112_u108dBuV,      /* AGC4 TOP DN/UP down 112 up 108 dBuV */
+    TDA18273_AGC4_TOP_DN_UP_Max
+} TDA18273AGC4_TOP_DN_UP_t, *pTDA18273AGC4_TOP_DN_UP_t;
+
+typedef enum _TDA18273AGC5_TOP_DN_UP_t {
+    TDA18273_AGC5_TOP_DN_UP_d105_u99dBuV = 0,   /* AGC5 TOP DN/UP down 105 up 99 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,      /* AGC5 TOP DN/UP down 105 up 100 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d105_u101dBuV,      /* AGC5 TOP DN/UP down 105 up 101 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d107_u101dBuV,      /* AGC5 TOP DN/UP down 107 up 101 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d107_u102dBuV,      /* AGC5 TOP DN/UP down 107 up 102 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d107_u103dBuV,      /* AGC5 TOP DN/UP down 107 up 103 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d108_u102dBuV,      /* AGC5 TOP DN/UP down 108 up 102 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d109_u103dBuV,      /* AGC5 TOP DN/UP down 109 up 103 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d109_u104dBuV,      /* AGC5 TOP DN/UP down 109 up 104 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d109_u105dBuV,      /* AGC5 TOP DN/UP down 109 up 105 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d110_u104dBuV,      /* AGC5 TOP DN/UP down 108 up 104 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,      /* AGC5 TOP DN/UP down 108 up 105 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d110_u106dBuV,      /* AGC5 TOP DN/UP down 108 up 106 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d112_u106dBuV,      /* AGC5 TOP DN/UP down 108 up 106 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d112_u107dBuV,      /* AGC5 TOP DN/UP down 108 up 107 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_d112_u108dBuV,      /* AGC5 TOP DN/UP down 108 up 108 dBuV */
+    TDA18273_AGC5_TOP_DN_UP_Max
+} TDA18273AGC5_TOP_DN_UP_t, *pTDA18273AGC5_TOP_DN_UP_t;
+
+typedef enum _TDA18273AGC3_Top_Adapt_Algorithm {
+    TDA18273_Top_Adapt_NO_TOP_ADAPT = 0,    /* NO TOP ADAPT */
+    TDA18273_Top_Adapt_TOP_ADAPT35,         /* TOP ADAPT35  */
+    TDA18273_Top_Adapt_TOP_ADAPT34,         /* TOP ADAPT34  */
+    TDA18273_Top_Adapt_Max
+} TDA18273AGC3_Top_Adapt_Algorithm, *pTDA18273AGC3_Top_Adapt_Algorithm;
+
+typedef enum _TDA18273AGC3_Adapt_TOP_t {
+    TDA18273_AGC3_Adapt_TOP_0_Step = 0, /* same level as AGC3 TOP  */
+    TDA18273_AGC3_Adapt_TOP_1_Step,     /* 1 level below AGC3 TOP  */
+    TDA18273_AGC3_Adapt_TOP_2_Step,     /* 2 level below AGC3 TOP  */
+    TDA18273_AGC3_Adapt_TOP_3_Step      /* 3 level below AGC3 TOP  */
+} TDA18273AGC3_Adapt_TOP_t, *pTDA18273AGC3_Adapt_TOP_t;
+
+typedef enum _TDA18273AGC_Overload_TOP_t {
+    TDA18273_AGC_Overload_TOP_plus_9_plus_3_5_min_3_5 = 0,  /* +9/+3.5/-3.5 */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_4_5,      /* +9/+4.5/-4.5 */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,      /* +9/+4.5/-3.5 */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_6_min_4_5,        /* +9/+6/-4.5   */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_6_min_6,          /* +9/+6/-6     */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_6_min_9,          /* +9/+6/-9     */
+    TDA18273_AGC_Overload_TOP_plus_9_plus_7_5_min_9,        /* +9/+7.5/-9   */
+    TDA18273_AGC_Overload_TOP_plus_12_plus_7_5_min_9        /* +12/+7.5/-9   */
+} TDA18273AGC_Overload_TOP_t, *pTDA18273AGC_Overload_TOP_t;
+
+typedef enum _TDA18273TH_AGC_Adapt34_t {
+    TDA18273_TH_AGC_Adapt34_2dB = 0,    /* Adapt TOP 34 Gain Threshold 2dB */
+    TDA18273_TH_AGC_Adapt34_5dB         /* Adapt TOP 34 Gain Threshold 5dB */
+} TDA18273TH_AGC_Adapt34_t, *pTDA18273TH_AGC_Adapt34_t;
+
+typedef enum _TDA18273RF_Atten_3dB_t {
+    TDA18273_RF_Atten_3dB_Disabled = 0, /* RF_Atten_3dB Disabled */
+    TDA18273_RF_Atten_3dB_Enabled,      /* RF_Atten_3dB Enabled */
+    TDA18273_RF_Atten_3dB_Max
+} TDA18273RF_Atten_3dB_t, *pTDA18273RF_Atten_3dB_t;
+
+typedef enum _TDA18273IF_Output_Level_t {
+    TDA18273_IF_Output_Level_2Vpp_0_30dB = 0,           /* 2Vpp       0 - 30dB      */
+    TDA18273_IF_Output_Level_1_25Vpp_min_4_26dB,        /* 1.25Vpp   -4 - 26dB      */
+    TDA18273_IF_Output_Level_1Vpp_min_6_24dB,           /* 1Vpp      -6 - 24dB      */
+    TDA18273_IF_Output_Level_0_8Vpp_min_8_22dB,         /* 0.8Vpp    -8 - 22dB      */
+    TDA18273_IF_Output_Level_0_85Vpp_min_7_5_22_5dB,    /* 0.85Vpp   -7.5 - 22.5dB  */
+    TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,         /* 0.7Vpp    -9 - 21dB      */
+    TDA18273_IF_Output_Level_0_6Vpp_min_10_3_19_7dB,    /* 0.6Vpp    -10.3 - 19.7dB */
+    TDA18273_IF_Output_Level_0_5Vpp_min_12_18dB,        /* 0.5Vpp    -12 - 18dB     */
+    TDA18273_IF_Output_Level_Max
+} TDA18273IF_Output_Level_t, *pTDA18273IF_Output_Level_t;
+
+typedef enum _TDA18273S2D_Gain_t {
+    TDA18273_S2D_Gain_3dB = 0,  /* 3dB */
+    TDA18273_S2D_Gain_6dB,      /* 6dB */
+    TDA18273_S2D_Gain_9dB,      /* 9dB */
+    TDA18273_S2D_Gain_Max
+} TDA18273S2D_Gain_t, *pTDA18273S2D_Gain_t;
+
+typedef enum _TDA18273Negative_Modulation_t {
+    TDA18273_Negative_Modulation_Disabled = 0,
+    TDA18273_Negative_Modulation_Enabled,
+    TDA18273_Negative_Modulation_Max
+} TDA18273Negative_Modulation_t, *pTDA18273Negative_Modulation_t;
+
+typedef enum _TDA18273AGCK_Steps_t {
+    TDA18273_AGCK_Steps_0_2dB = 0,  /* 0.2dB */
+    TDA18273_AGCK_Steps_0_4dB,      /* 0.4dB */
+    TDA18273_AGCK_Steps_0_6dB,      /* 0.6dB */
+    TDA18273_AGCK_Steps_0_8dB,      /* 0.8dB */
+    TDA18273_AGCK_Steps_Max
+} TDA18273AGCK_Steps_t, *pTDA18273AGCK_Steps_t;
+
+typedef enum _TDA18273AGCK_Time_Constant_t {
+    TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE = 0,  /* 1 Step Each VSYNC Rising Edge */
+    TDA18273_AGCK_Time_Constant_0_512ms,                            /* 0.512ms                       */
+    TDA18273_AGCK_Time_Constant_8_192ms,                            /* 8.192ms                       */
+    TDA18273_AGCK_Time_Constant_32_768ms,                           /* 32.768ms                      */
+    TDA18273_AGCK_Time_Constant_Max
+} TDA18273AGCK_Time_Constant_t, *pTDA18273AGCK_Time_Constant_t;
+
+typedef enum _TDA18273AGC5_HPF_t {
+    TDA18273_AGC5_HPF_Disabled = 0, /* AGC5 HPF Disabled */
+    TDA18273_AGC5_HPF_Enabled,      /* AGC5 HPF Enabled  */
+    TDA18273_AGC5_HPF_Max
+} TDA18273AGC5_HPF_t, *pTDA18273AGC5_HPF_t;
+
+typedef enum _TDA18273Pulse_Shaper_Disable_t {
+    TDA18273_Pulse_Shaper_Disable_Disabled = 0,
+    TDA18273_Pulse_Shaper_Disable_Enabled,
+    TDA18273_Pulse_Shaper_Disable_Max
+} TDA18273Pulse_Shaper_Disable_t, *pTDA18273Pulse_Shaper_Disable_t;
+
+typedef enum _TDA18273VHF_III_Mode_t {
+    TDA18273_VHF_III_Mode_Disabled = 0, /* VHF_III_Mode Disabled */
+    TDA18273_VHF_III_Mode_Enabled,      /* VHF_III_Mode Enabled  */
+    TDA18273_VHF_III_Mode_Max
+} TDA18273VHF_III_Mode_t, *pTDA18273VHF_III_Mode_t;
+
+typedef enum _TDA18273LO_CP_Current_t {
+    TDA18273_LO_CP_Current_Disabled = 0,    /* LO CP Current Disabled */
+    TDA18273_LO_CP_Current_Enabled,         /* LO CP Current Enabled  */
+    TDA18273_LO_CP_Current_Max
+} TDA18273LO_CP_Current_t, *pTDA18273LO_CP_Current_t;
+
+typedef enum _TDA18273PD_Underload_t {
+    TDA18273_PD_Underload_Disabled = 0,    /* PD Underload Disabled */
+    TDA18273_PD_Underload_Enabled,         /* PD Underload Enabled  */
+    TDA18273_PD_Underload_Max
+} TDA18273PD_Underload_t, *pTDA18273PD_Underload_t;
+
+typedef struct _TDA18273StdCoefficients
+{
+    /****************************************************************/
+    /* IF Settings                                                  */
+    /****************************************************************/
+    UInt32                                      IF;                                 /* IF Frequency */
+    Int32                                       CF_Offset;
+
+    /****************************************************************/
+    /* IF SELECTIVITY Settings                                      */
+    /****************************************************************/
+    TDA18273LPF_t                               LPF;                                /* LPF Cut off */
+    TDA18273LPFOffset_t                         LPF_Offset;                         /* LPF offset */
+    TDA18273DC_Notch_IF_PPF_t                   DC_Notch_IF_PPF;                    /* DC notch IF PPF */
+    TDA18273IF_HPF_t                            IF_HPF;                             /* Hi Pass */
+    TDA18273IF_Notch_t                          IF_Notch;                           /* IF notch */
+    TDA18273IFnotchToRSSI_t                     IFnotchToRSSI;                      /* IFnotchToRSSI */
+
+    /****************************************************************/
+    /* AGC TOP Settings                                             */
+    /****************************************************************/
+    TDA18273AGC1_TOP_I2C_DN_UP_t                AGC1_TOP_I2C_DN_UP;                 /* AGC1 TOP I2C DN/UP */
+    TDA18273AGC1_Adapt_TOP_DN_UP_t              AGC1_Adapt_TOP_DN_UP;               /* AGC1 Adapt TOP DN/UP */
+	TDA18273AGC1_DN_Time_Constant_t             AGC1_DN_Time_Constant;              /* AGC1 DN Time Constant */
+    TDA18273AGC1_Mode_t                         AGC1_Mode;                          /* AGC1 mode */
+    TDA18273Range_LNA_Adapt_t                   Range_LNA_Adapt;                    /* Range_LNA_Adapt */
+    TDA18273LNA_Adapt_RFAGC_Gv_Threshold        LNA_Adapt_RFAGC_Gv_Threshold;       /* LNA_Adapt_RFAGC_Gv_Threshold */
+    TDA18273AGC1_Top_Adapt_RFAGC_Gv_Threshold   AGC1_Top_Adapt_RFAGC_Gv_Threshold;  /* AGC1_Top_Adapt_RFAGC_Gv_Threshold */
+    TDA18273AGC2_TOP_DN_UP_t                    AGC2_TOP_DN_UP;                     /* AGC2 TOP DN/UP */
+	TDA18273AGC2_DN_Time_Constant_t             AGC2_DN_Time_Constant;              /* AGC2 DN Time Constant */
+    TDA18273AGC3_TOP_I2C_t                      AGC3_TOP_I2C_Low_Band;              /* AGC3 TOP I2C Low Band */
+    TDA18273AGC3_TOP_I2C_t                      AGC3_TOP_I2C_High_Band;             /* AGC3 TOP I2C High Band */
+    TDA18273AGC4_TOP_DN_UP_t                    AGC4_TOP_DN_UP;                     /* AGC4 TOP DN/UP */
+    TDA18273AGC5_TOP_DN_UP_t                    AGC5_TOP_DN_UP;                     /* AGC5 TOP DN/UP */
+    TDA18273AGC3_Top_Adapt_Algorithm            AGC3_Top_Adapt_Algorithm;           /* AGC3_Top_Adapt_Algorithm */
+    TDA18273AGC3_Adapt_TOP_t                    AGC3_Adapt_TOP_Low_Band;            /* AGC3 Adapt TOP Low Band */
+    TDA18273AGC3_Adapt_TOP_t                    AGC3_Adapt_TOP_High_Band;           /* AGC3 Adapt TOP High Band */
+    TDA18273AGC_Overload_TOP_t                  AGC_Overload_TOP;                   /* AGC Overload TOP */
+    TDA18273TH_AGC_Adapt34_t                    TH_AGC_Adapt34;                     /* Adapt TOP 34 Gain Threshold */
+    TDA18273RF_Atten_3dB_t                      RF_Atten_3dB;                       /* RF atten 3dB */
+    TDA18273IF_Output_Level_t                   IF_Output_Level;                    /* IF Output Level */
+    TDA18273S2D_Gain_t                          S2D_Gain;                           /* S2D gain */
+    TDA18273Negative_Modulation_t               Negative_Modulation;                /* Negative modulation */
+
+    /****************************************************************/
+    /* GSK Settings                                                 */
+    /****************************************************************/
+    TDA18273AGCK_Steps_t                        AGCK_Steps;                         /* Step */
+    TDA18273AGCK_Time_Constant_t                AGCK_Time_Constant;                 /* AGCK Time Constant */
+    TDA18273AGC5_HPF_t                          AGC5_HPF;                           /* AGC5 HPF */
+    TDA18273Pulse_Shaper_Disable_t              Pulse_Shaper_Disable;               /* Pulse Shaper Disable */
+
+    /****************************************************************/
+    /* H3H5 Settings                                                */
+    /****************************************************************/
+    TDA18273VHF_III_Mode_t                      VHF_III_Mode;                       /* VHF_III_Mode */
+
+    /****************************************************************/
+    /* PLL Settings                                                 */
+    /****************************************************************/
+    TDA18273LO_CP_Current_t                     LO_CP_Current;                      /* LO_CP_Current */
+
+	/****************************************************************/
+    /* MISC Settings                                                */
+    /****************************************************************/
+	TDA18273PD_Underload_t                      PD_Underload;                       /* PD Underload */
+	UInt32										Freq_Start_LTE;                     /* Frequency start of high band for LTE */
+} TDA18273StdCoefficients, *pTDA18273StdCoefficients;
+
+typedef struct _TDA18273Object_t
+{
+    UInt32                          uRF;
+    UInt32                          uProgRF;
+    UInt32                          uIF;
+    TDA18273StandardMode_t          StandardMode;
+    pTDA18273StdCoefficients        pStandard;
+    TDA18273StdCoefficients         Std_Array[TDA18273_StandardMode_Max-1];
+} TDA18273Object_t, *pTDA18273Object_t, **ppTDA18273Object_t;
+
+/* Standard Preset Definitions: */
+#define TDA18273_INSTANCE_CUSTOM_STD_QAM_6MHZ \
+    {                                                               /* QAM 6MHz */ \
+	3600000,				                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_6MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_min_4pc,                                 /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_1MHz,                                       /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89wdBuV,                   /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,             /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_WIDE,                          /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,             /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                      /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_NO_TOP_ADAPT,                            /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt Low Band */ \
+	TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                     /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_QAM_8MHZ \
+    {                                                               /* QAM 8MHz */ \
+	5000000,				      				/* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_9MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_min_8pc,                                 /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_85MHz,                                    /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89wdBuV,                   /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_WIDE,                          /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_NO_TOP_ADAPT,                            /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ATSC_6MHZ \
+    {                                                               /* ATSC */ \
+	3250000,								/* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_6MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_4MHz,                                     /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d100_u94dBuV,                   /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_104dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_104dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d112_u107dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d112_u107dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_3_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_3_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_6Vpp_min_10_3_19_7dB,           /* IF Output Level */ \
+	TDA18273_S2D_Gain_3dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		662000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ISDBT_6MHZ \
+    {                                                               /* ISDBT */ \
+	3250000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_6MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_4MHz,                                     /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_6Vpp_min_10_3_19_7dB,            /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DVBT_1_7MHZ \
+    {                                                               /* DVB-T/T2 1.7MHz */ \
+	850000,                                                     /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_1_5MHz,                                        /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_4_094ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_2_047ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_94dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Enabled,                              /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DVBT_6MHZ \
+    {                                                               /* DVB-T/T2 6MHz */ \
+	3250000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_6MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_4MHz,                                     /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_4_094ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_2_047ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_94dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Enabled,                              /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DVBT_7MHZ \
+    {                                                               /* DVB-T/T2 7MHz */ \
+	3500000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_7MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_min_8pc,                                 /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_4_094ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_2_047ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_94dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Enabled,                              /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DVBT_8MHZ \
+    {                                                               /* DVB-T/T2 8MHz */ \
+	4000000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_4_094ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_2_047ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_94dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Enabled,                              /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DVBT_10MHZ \
+    {                                                               /* DVB-T/T2 10MHz */ \
+	5000000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_9MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_DMBT_8MHZ \
+    {                                                               /* DMB-T */ \
+	4000000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT,                               /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT35,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_2_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Enabled,                              /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Enabled,                              /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_FM_RADIO \
+    {                                                               /* FM */ \
+	1250000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_1_5MHz,                                        /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_85MHz,                                    /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_8Vpp_min_8_22dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_MN \
+    {                                                               /* NTSC M/N */ \
+	5400000,                                                    /* IF */ \
+	1750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_6MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Enabled,                       /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_B \
+    {                                                               /* PAL B */ \
+	6400000,                                                    /* IF */ \
+	2250000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_7MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Enabled,                       /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_GH \
+    {                                                               /* PAL G/H */ \
+	6750000,                                                    /* IF */ \
+	2750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Enabled,                       /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_I \
+    {                                                               /* PAL I */ \
+	7250000,                                                    /* IF */ \
+	2750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Enabled,                       /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_DK \
+    {                                                               /* SECAM D/K */ \
+	6850000,                                                    /* IF */ \
+	2750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Enabled,                       /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_L \
+    {                                                               /* SECAM L */ \
+	6750000,                                                    /* IF */ \
+	2750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Enabled,                                  /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Disabled,                            /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_6_min_9,              /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_LL \
+    {                                                               /* SECAM L' */ \
+	1250000,                                                    /* IF */ \
+	-2750000,                                                   /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_6_min_9,              /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_ANALOG_BLIND_SCANNING \
+    {                                                               /* Blind Scanning copy of PAL-I */ \
+	7250000,                                                    /* IF */ \
+	2750000,                                                    /* CF_Offset */ \
+	TDA18273_LPF_8MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_0pc,                                     /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Disabled,                          /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_Disabled,                                   /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89dBuV,                    /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_1_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_TOP_ADAPT,                     /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_15_25dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_96dBuV,                               /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d105_u100dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d105_u100dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_TOP_ADAPT34,                             /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_1_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_0_7Vpp_min_9_21dB,                 /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_1_STEP_EACH_VSYNC_RISING_EDGE,  /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Enabled,                                  /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+#define TDA18273_INSTANCE_CUSTOM_STD_SCANXPRESS \
+    {                                                               /* ScanXpress */ \
+	5000000,                                                    /* IF */ \
+	0,                                                          /* CF_Offset */ \
+	TDA18273_LPF_9MHz,                                          /* LPF */ \
+	TDA18273_LPFOffset_min_8pc,                                 /* LPF_Offset */ \
+	TDA18273_DC_Notch_IF_PPF_Enabled,                           /* DC notch IF PPF */ \
+	TDA18273_IF_HPF_0_85MHz,                                    /* Hi Pass */ \
+	TDA18273_IF_Notch_Disabled,                                 /* IF notch */ \
+	TDA18273_IFnotchToRSSI_Enabled,                             /* IF notch To RSSI */ \
+	TDA18273_AGC1_TOP_I2C_DN_UP_d95_u89wdBuV,                   /* AGC1 TOP I2C DN/UP */ \
+	TDA18273_AGC1_Adapt_TOP_DN_UP_0_Step,                       /* AGC1 Adapt TOP DN/UP */ \
+		TDA18273_AGC1_DN_Time_Constant_8_188ms,                     /* AGC1 DN Time Constant */ \
+	TDA18273_AGC1_Mode_LNA_ADAPT_WIDE,                          /* AGC1 mode */ \
+	TDA18273_Range_LNA_Adapt_20dB_11dB,                         /* Range LNA Adapt */ \
+	TDA18273_LNA_Adapt_RFAGC_Gv_Threshold_18_25dB,              /* LNA Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC1_Top_Adapt_RFAGC_Gv_Threshold_16_75dB,         /* AGC1 TOP Adapt RFAGC Gv Threshold */ \
+	TDA18273_AGC2_TOP_DN_UP_d90_u84dBuV,                        /* AGC2 TOP DN/UP */ \
+		TDA18273_AGC2_DN_Time_Constant_8_188ms,                     /* AGC2 DN Time Constant */ \
+	TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C Low Band */ \
+		TDA18273_AGC3_TOP_I2C_100dBuV,                              /* AGC3 TOP I2C High Band */ \
+	TDA18273_AGC4_TOP_DN_UP_d110_u105dBuV,                      /* AGC4 TOP DN/UP */ \
+	TDA18273_AGC5_TOP_DN_UP_d110_u105dBuV,                      /* AGC5 TOP DN/UP */ \
+	TDA18273_Top_Adapt_NO_TOP_ADAPT,                            /* AGC3 TOP Adapt Algorithm */ \
+	TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt Low Band */ \
+		TDA18273_AGC3_Adapt_TOP_0_Step,                             /* AGC3 Adapt High Band */ \
+	TDA18273_AGC_Overload_TOP_plus_9_plus_4_5_min_3_5,          /* AGC Overload TOP */ \
+	TDA18273_TH_AGC_Adapt34_5dB,                                /* Adapt TOP 34 Gain Threshold */ \
+	TDA18273_RF_Atten_3dB_Disabled,                             /* RF Atten 3dB */ \
+	TDA18273_IF_Output_Level_1Vpp_min_6_24dB,                   /* IF Output Level */ \
+	TDA18273_S2D_Gain_6dB,                                      /* S2D Gain */ \
+	TDA18273_Negative_Modulation_Disabled,                      /* Negative Modulation */ \
+	TDA18273_AGCK_Steps_0_2dB,                                  /* Step */ \
+	TDA18273_AGCK_Time_Constant_32_768ms,                       /* AGCK Time Constant */ \
+	TDA18273_AGC5_HPF_Disabled,                                 /* AGC5 HPF */ \
+	TDA18273_Pulse_Shaper_Disable_Enabled,                      /* Pulse Shaper Disable */ \
+	TDA18273_VHF_III_Mode_Disabled,                             /* VHF III Mode */ \
+	TDA18273_LO_CP_Current_Enabled,                             /* LO CP Current */ \
+		TDA18273_PD_Underload_Disabled,                             /* PD Underload */ \
+		754000000													/* Frequency Start LTE */ \
+    }
+
+/* Standard Presets Aggregation: */
+#define TDA18273_INSTANCE_CUSTOM_STD_DEF \
+    { \
+	TDA18273_INSTANCE_CUSTOM_STD_QAM_6MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_QAM_8MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_ATSC_6MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_ISDBT_6MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DVBT_1_7MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DVBT_6MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DVBT_7MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DVBT_8MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DVBT_10MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_DMBT_8MHZ, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_FM_RADIO, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_MN, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_B, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_GH, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_I, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_DK, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_L, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_LL, \
+	TDA18273_INSTANCE_CUSTOM_STD_ANALOG_BLIND_SCANNING, \
+	TDA18273_INSTANCE_CUSTOM_STD_SCANXPRESS \
+    }
+
+#endif	/* __TDA18273_PRIV */
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/Kconfig" "b/drivers/media/usb/dvb-usb/Kconfig"
--- "a/drivers/media/usb/dvb-usb/Kconfig"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/Kconfig"	2018-01-17 18:28:26.024098000 +0800
@@ -106,6 +106,16 @@
 	  Say Y if you own such a device and want to use it. You should build it as
 	  a module.
 
+config DVB_USB_TBS5520SE
+	tristate "Turbosight TBS5520SE DVB-T/T2/C/C2/S/S2/ISDB-T USB2.0 support"
+	depends on DVB_USB
+	select DVB_PLL if MEDIA_SUBDRV_AUTOSELECT
+	select MEDIA_TUNER_AV201X if MEDIA_SUBDRV_AUTOSELECT
+	select MEDIA_TUNER_SI2157 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_SI2183 if MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Say Y here to support the Turbosight TBS5520SE USB2 DVB-T/T2/C/C2/S/S2/ISDB-T device
+
 config DVB_USB_UMT_010
 	tristate "HanfTek UMT-010 DVB-T USB2.0 support"
 	depends on DVB_USB
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/Makefile" "b/drivers/media/usb/dvb-usb/Makefile"
--- "a/drivers/media/usb/dvb-usb/Makefile"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/Makefile"	2018-01-17 18:29:42.084978000 +0800
@@ -73,6 +73,9 @@
 dvb-usb-friio-objs := friio.o friio-fe.o
 obj-$(CONFIG_DVB_USB_FRIIO) += dvb-usb-friio.o
 
+dvb-usb-tbs5520se-objs := tbs5520se.o
+obj-$(CONFIG_DVB_USB_TBS5520SE) += dvb-usb-tbs5520se.o
+
 dvb-usb-az6027-objs := az6027.o
 obj-$(CONFIG_DVB_USB_AZ6027) += dvb-usb-az6027.o
 
--- "a/drivers/media/usb/dvb-usb/dib0700_devices.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/dib0700_devices.c"	2017-12-07 05:52:26.000000000 +0800
@@ -26,8 +26,7 @@
 
 static int force_lna_activation;
 module_param(force_lna_activation, int, 0644);
-MODULE_PARM_DESC(force_lna_activation, "force the activation of Low-Noise-Amplifyer(s) (LNA), "
-		"if applicable for the device (default: 0=automatic/off).");
+MODULE_PARM_DESC(force_lna_activation, "force the activation of Low-Noise-Amplifyer(s) (LNA), if applicable for the device (default: 0=automatic/off).");
 
 struct dib0700_adapter_state {
 	int (*set_param_save) (struct dvb_frontend *);
@@ -515,7 +514,7 @@
  */
 static int dib0700_rc_query_old_firmware(struct dvb_usb_device *d)
 {
-	enum rc_type protocol;
+	enum rc_proto protocol;
 	u32 scancode;
 	u8 toggle;
 	int i;
@@ -548,7 +547,7 @@
 	dib0700_rc_setup(d, NULL); /* reset ir sensor data to prevent false events */
 
 	switch (d->props.rc.core.protocol) {
-	case RC_BIT_NEC:
+	case RC_PROTO_BIT_NEC:
 		/* NEC protocol sends repeat code as 0 0 0 FF */
 		if ((st->buf[3 - 2] == 0x00) && (st->buf[3 - 3] == 0x00) &&
 		    (st->buf[3] == 0xff)) {
@@ -556,14 +555,14 @@
 			return 0;
 		}
 
-		protocol = RC_TYPE_NEC;
+		protocol = RC_PROTO_NEC;
 		scancode = RC_SCANCODE_NEC(st->buf[3 - 2], st->buf[3 - 3]);
 		toggle = 0;
 		break;
 
 	default:
 		/* RC-5 protocol changes toggle bit on new keypress */
-		protocol = RC_TYPE_RC5;
+		protocol = RC_PROTO_RC5;
 		scancode = RC_SCANCODE_RC5(st->buf[3 - 2], st->buf[3 - 3]);
 		toggle = st->buf[3 - 1];
 		break;
@@ -1660,6 +1659,7 @@
 	switch (band) {
 	default:
 			deb_info("Warning : Rf frequency  (%iHz) is not in the supported range, using VHF switch ", fe->dtv_property_cache.frequency);
+			/* fall through */
 	case BAND_VHF:
 			state->dib8000_ops.set_gpio(fe, 3, 0, 1);
 			break;
@@ -2415,7 +2415,7 @@
 		deb_info("%s: Upload failed. (file not found?)\n", __func__);
 		return -ENODEV;
 	} else {
-		deb_info("%s: firmware read %Zu bytes.\n", __func__, state->frontend_firmware->size);
+		deb_info("%s: firmware read %zu bytes.\n", __func__, state->frontend_firmware->size);
 	}
 	stk9090m_config.microcode_B_fe_size = state->frontend_firmware->size;
 	stk9090m_config.microcode_B_fe_buffer = state->frontend_firmware->data;
@@ -2481,7 +2481,7 @@
 		deb_info("%s: Upload failed. (file not found?)\n", __func__);
 		return -EIO;
 	} else {
-		deb_info("%s: firmware read %Zu bytes.\n", __func__, state->frontend_firmware->size);
+		deb_info("%s: firmware read %zu bytes.\n", __func__, state->frontend_firmware->size);
 	}
 	nim9090md_config[0].microcode_B_fe_size = state->frontend_firmware->size;
 	nim9090md_config[0].microcode_B_fe_buffer = state->frontend_firmware->data;
@@ -3816,6 +3816,7 @@
 	{ USB_DEVICE(USB_VID_PCTV,      USB_PID_PCTV_2002E_SE) },
 	{ USB_DEVICE(USB_VID_PCTV,      USB_PID_DIBCOM_STK8096PVR) },
 	{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_STK8096PVR) },
+	{ USB_DEVICE(USB_VID_HAMA,	USB_PID_HAMA_DVBT_HYBRID) },
 	{ 0 }		/* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, dib0700_usb_id_table);
@@ -3908,9 +3909,9 @@
 			.rc_interval      = DEFAULT_RC_INTERVAL,
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -3948,9 +3949,9 @@
 			.rc_interval      = DEFAULT_RC_INTERVAL,
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4013,9 +4014,9 @@
 			.rc_interval      = DEFAULT_RC_INTERVAL,
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4058,9 +4059,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4139,9 +4140,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4184,9 +4185,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4241,9 +4242,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4307,9 +4308,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4356,9 +4357,9 @@
 			.rc_codes         = RC_MAP_DIB0700_NEC_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4380,7 +4381,7 @@
 			},
 		},
 
-		.num_device_descs = 9,
+		.num_device_descs = 10,
 		.devices = {
 			{   "Terratec Cinergy HT USB XE",
 				{ &dib0700_usb_id_table[27], NULL },
@@ -4418,6 +4419,10 @@
 				{ &dib0700_usb_id_table[54], NULL },
 				{ NULL },
 			},
+			{   "Hama DVB=T Hybrid USB Stick",
+				{ &dib0700_usb_id_table[85], NULL },
+				{ NULL },
+			},
 		},
 
 		.rc.core = {
@@ -4425,9 +4430,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4461,9 +4466,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4537,9 +4542,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4581,9 +4586,9 @@
 			.rc_codes         = RC_MAP_DIB0700_NEC_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4630,9 +4635,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4667,9 +4672,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4704,9 +4709,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4741,9 +4746,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4778,9 +4783,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4815,9 +4820,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4866,9 +4871,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4901,9 +4906,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4938,9 +4943,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -4976,9 +4981,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name	  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-					    RC_BIT_RC6_MCE |
-					    RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+					    RC_PROTO_BIT_RC6_MCE |
+					    RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
@@ -5030,9 +5035,9 @@
 			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
 			.module_name  = "dib0700",
 			.rc_query         = dib0700_rc_query_old_firmware,
-			.allowed_protos   = RC_BIT_RC5 |
-				RC_BIT_RC6_MCE |
-				RC_BIT_NEC,
+			.allowed_protos   = RC_PROTO_BIT_RC5 |
+				RC_PROTO_BIT_RC6_MCE |
+				RC_PROTO_BIT_NEC,
 			.change_protocol  = dib0700_change_protocol,
 		},
 	},
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/dvb-usb-dvb.c" "b/drivers/media/usb/dvb-usb/dvb-usb-dvb.c"
--- "a/drivers/media/usb/dvb-usb/dvb-usb-dvb.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/dvb-usb-dvb.c"	2018-01-17 18:21:59.329683000 +0800
@@ -314,6 +314,22 @@
 				return 0;
 		}
 
+		if(adap->fe_adap[i].fe2!=NULL){
+			if (dvb_register_frontend(&adap->dvb_adap, adap->fe_adap[i].fe2)) {
+				err("Frontend %d registration failed.", i);
+				dvb_frontend_detach(adap->fe_adap[i].fe2);
+				adap->fe_adap[i].fe2 = NULL;
+				/* In error case, do not try register more FEs,
+				 * still leaving already registered FEs alive. */
+				if (i == 0)
+					return -ENODEV;
+				else
+					return 0;
+			}
+
+
+		}
+			
 		/* only attach the tuner if the demod is there */
 		if (adap->props.fe[i].tuner_attach != NULL)
 			adap->props.fe[i].tuner_attach(adap);
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/dvb-usb.h" "b/drivers/media/usb/dvb-usb/dvb-usb.h"
--- "a/drivers/media/usb/dvb-usb/dvb-usb.h"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/dvb-usb.h"	2017-12-07 05:52:26.000000000 +0800
@@ -202,11 +202,12 @@
 	u64 protocol;
 	u64 allowed_protos;
 	enum rc_driver_type driver_type;
-	int (*change_protocol)(struct rc_dev *dev, u64 *rc_type);
+	int (*change_protocol)(struct rc_dev *dev, u64 *rc_proto);
 	char *module_name;
 	int (*rc_query) (struct dvb_usb_device *d);
 	int rc_interval;
 	bool bulk_mode;				/* uses bulk mode */
+	u32 scancode_mask;
 };
 
 /**
@@ -357,7 +358,8 @@
  */
 struct dvb_usb_fe_adapter {
 	struct dvb_frontend *fe;
-
+	struct dvb_frontend *fe2;
+	struct dvb_frontend _fe2;
 	int (*fe_init)  (struct dvb_frontend *);
 	int (*fe_sleep) (struct dvb_frontend *);
 
@@ -467,8 +469,10 @@
 extern void dvb_usb_device_exit(struct usb_interface *);
 
 /* the generic read/write method for device control */
-extern int dvb_usb_generic_rw(struct dvb_usb_device *, u8 *, u16, u8 *, u16,int);
-extern int dvb_usb_generic_write(struct dvb_usb_device *, u8 *, u16);
+extern int __must_check
+dvb_usb_generic_rw(struct dvb_usb_device *, u8 *, u16, u8 *, u16, int);
+extern int __must_check
+dvb_usb_generic_write(struct dvb_usb_device *, u8 *, u16);
 
 /* commonly used remote control parsing */
 extern int dvb_usb_nec_rc_key_to_event(struct dvb_usb_device *, u8[], u32 *, int *);

--- "a/drivers/media/usb/dvb-usb/dw2102.c"	2018-01-10 16:29:55.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/dw2102.c"	2017-12-07 05:52:26.000000000 +0800
@@ -2,7 +2,7 @@
  *	DVBWorld DVB-S 2101, 2102, DVB-S2 2104, DVB-C 3101,
  *	TeVii S421, S480, S482, S600, S630, S632, S650, S660, S662,
  *	Prof 1100, 7500,
- *	Geniatech SU3000, T220,
+ *	Geniatech SU3000, T220/220A,
  *	TechnoTrend S2-4600,
  *	Terratec Cinergy S2 cards
  * Copyright (C) 2008-2012 Igor M. Liplianin (liplianin@me.by)
@@ -35,6 +35,7 @@
 #include "tda18271.h"
 #include "cxd2820r.h"
 #include "m88ds3103.h"
+#include "tda18273.h"
 
 /* Max transfer size done by I2C transfer functions */
 #define MAX_XFER_SIZE  64
@@ -87,8 +88,7 @@
 /* demod probe */
 static int demod_probe = 1;
 module_param_named(demod, demod_probe, int, 0644);
-MODULE_PARM_DESC(demod, "demod to probe (1=cx24116 2=stv0903+stv6110 "
-			"4=stv0903+stb6100(or-able)).");
+MODULE_PARM_DESC(demod, "demod to probe (1=cx24116 2=stv0903+stv6110 4=stv0903+stb6100(or-able)).");
 
 DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
@@ -971,6 +971,24 @@
 	return 0;
 }
 
+static int su3000_read_status(struct dvb_frontend *fe,
+				  enum fe_status *status)
+{
+	struct dvb_usb_adapter *d =
+		(struct dvb_usb_adapter *)(fe->dvb->priv);
+	struct dw2102_state *st = (struct dw2102_state *)d->dev->priv;
+	int ret;
+
+	ret = st->fe_read_status(fe, status);
+
+	/* resync slave fifo when signal change from unlock to lock */
+	if ((*status & FE_HAS_LOCK) && (!st->last_lock))
+		su3000_streaming_ctrl(d, 1);
+
+	st->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;
+	return ret;
+}
+
 static int dw210x_set_voltage(struct dvb_frontend *fe,
 			      enum fe_sec_voltage voltage)
 {
@@ -1028,24 +1046,6 @@
 	i2c_transfer(&udev_adap->dev->i2c_adap, &msg, 1);
 }
 
-static int tt_s2_4600_read_status(struct dvb_frontend *fe,
-				  enum fe_status *status)
-{
-	struct dvb_usb_adapter *d =
-		(struct dvb_usb_adapter *)(fe->dvb->priv);
-	struct dw2102_state *st = (struct dw2102_state *)d->dev->priv;
-	int ret;
-
-	ret = st->fe_read_status(fe, status);
-
-	/* resync slave fifo when signal change from unlock to lock */
-	if ((*status & FE_HAS_LOCK) && (!st->last_lock))
-		su3000_streaming_ctrl(d, 1);
-
-	st->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;
-	return ret;
-}
-
 static struct stv0299_config sharp_z0194a_config = {
 	.demod_address = 0x68,
 	.inittab = sharp_z0194a_inittab,
@@ -1385,12 +1385,17 @@
 {
 	struct dvb_usb_device *d = adap->dev;
 	struct dw2102_state *state = d->priv;
+	struct i2c_adapter *i2c_adapter;
+	struct i2c_client *client;
+	struct i2c_board_info board_info;
+	struct m88ds3103_platform_data m88ds3103_pdata = {};
+	struct ts2020_config ts2020_config = {};
 
 	mutex_lock(&d->data_mutex);
 
 	state->data[0] = 0xe;
 	state->data[1] = 0x80;
-	state->data[2] = 0;
+	state->data[2] = 0x0;
 
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err("command 0x0e transfer failed.");
@@ -1424,20 +1429,85 @@
 
 	mutex_unlock(&d->data_mutex);
 
+	/* First try ds300x version */
 	adap->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,
 					&d->i2c_adap);
 	if (adap->fe_adap[0].fe == NULL)
-		return -EIO;
+		goto attach2;
 
-	if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
+	if (!dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
 				&dw2104_ts2020_config,
 				&d->i2c_adap)) {
-		info("Attached DS3000/TS2020!");
-		return 0;
+		dvb_frontend_detach(adap->fe_adap[0].fe);
+		return -ENODEV;
 	}
+	goto attach3;
 
-	info("Failed to attach DS3000/TS2020!");
-	return -EIO;
+attach2:
+	/* attach demod */
+	m88ds3103_pdata.clk = 27000000;
+	m88ds3103_pdata.i2c_wr_max = 33;
+	m88ds3103_pdata.ts_mode = M88DS3103_TS_CI;
+	m88ds3103_pdata.ts_clk = 16000;
+	m88ds3103_pdata.ts_clk_pol = 0;
+	m88ds3103_pdata.spec_inv = 0;
+	m88ds3103_pdata.agc = 0x99;
+	m88ds3103_pdata.agc_inv = 0;
+	m88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;
+	m88ds3103_pdata.envelope_mode = 0;
+	m88ds3103_pdata.lnb_hv_pol = 1;
+	m88ds3103_pdata.lnb_en_pol = 0;
+	memset(&board_info, 0, sizeof(board_info));
+	strlcpy(board_info.type, "m88ds3103", I2C_NAME_SIZE);
+	board_info.addr = 0x68;
+	board_info.platform_data = &m88ds3103_pdata;
+	request_module("m88ds3103");
+	client = i2c_new_device(&d->i2c_adap, &board_info);
+	if (client == NULL || client->dev.driver == NULL)
+		return -ENODEV;
+	if (!try_module_get(client->dev.driver->owner)) {
+		i2c_unregister_device(client);
+		return -ENODEV;
+	}
+	adap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);
+	i2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);
+
+	state->i2c_client_demod = client;
+
+	/* attach tuner */
+	ts2020_config.fe = adap->fe_adap[0].fe;
+	memset(&board_info, 0, sizeof(board_info));
+	strlcpy(board_info.type, "ts2022", I2C_NAME_SIZE);
+	board_info.addr = 0x60;
+	board_info.platform_data = &ts2020_config;
+	request_module("ts2020");
+	client = i2c_new_device(i2c_adapter, &board_info);
+
+	if (client == NULL || client->dev.driver == NULL) {
+		dvb_frontend_detach(adap->fe_adap[0].fe);
+		return -ENODEV;
+	}
+
+	if (!try_module_get(client->dev.driver->owner)) {
+		i2c_unregister_device(client);
+		dvb_frontend_detach(adap->fe_adap[0].fe);
+		return -ENODEV;
+	}
+
+	/* delegate signal strength measurement to tuner */
+	adap->fe_adap[0].fe->ops.read_signal_strength =
+			adap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;
+
+	state->i2c_client_tuner = client;
+
+attach3:
+	/* hook fe: need to resync the slave fifo when signal locks */
+	state->fe_read_status = adap->fe_adap[0].fe->ops.read_status;
+	adap->fe_adap[0].fe->ops.read_status = su3000_read_status;
+
+	state->last_lock = 0;
+
+	return 0;
 }
 
 static int t220_frontend_attach(struct dvb_usb_adapter *adap)
@@ -1486,86 +1556,52 @@
 
 	adap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,
 					&d->i2c_adap, NULL);
-	if (adap->fe_adap[0].fe != NULL) {
-		if (dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,
-					&d->i2c_adap, &tda18271_config)) {
-			info("Attached TDA18271HD/CXD2820R!");
-			return 0;
-		}
-	}
-
-	info("Failed to attach TDA18271HD/CXD2820R!");
-	return -EIO;
-}
-
-static int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap)
-{
-	struct dvb_usb_device *d = adap->dev;
-	struct dw2102_state *state = d->priv;
-
-	mutex_lock(&d->data_mutex);
-
-	state->data[0] = 0x51;
-
-	if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
-		err("command 0x51 transfer failed.");
-
-	mutex_unlock(&d->data_mutex);
-
-	adap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,
-					&s421_m88rs2000_config,
-					&d->i2c_adap);
-
 	if (adap->fe_adap[0].fe == NULL)
 		return -EIO;
 
-	if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
-				&dw2104_ts2020_config,
-				&d->i2c_adap)) {
-		info("Attached RS2000/TS2020!");
-		return 0;
-	}
+	if (!dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,
+		&d->i2c_adap, &tda18271_config))
+		return -EIO;
 
-	info("Failed to attach RS2000/TS2020!");
-	return -EIO;
+	/* hook fe: need to resync the slave fifo when signal locks */
+	state->fe_read_status = adap->fe_adap[0].fe->ops.read_status;
+	adap->fe_adap[0].fe->ops.read_status = su3000_read_status;
+
+	return 0;
 }
 
-static int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)
+static int t220a_frontend_attach(struct dvb_usb_adapter *adap)
 {
 	struct dvb_usb_device *d = adap->dev;
 	struct dw2102_state *state = d->priv;
-	struct i2c_adapter *i2c_adapter;
-	struct i2c_client *client;
-	struct i2c_board_info board_info;
-	struct m88ds3103_platform_data m88ds3103_pdata = {};
-	struct ts2020_config ts2020_config = {};
 
 	mutex_lock(&d->data_mutex);
 
 	state->data[0] = 0xe;
-	state->data[1] = 0x80;
+	state->data[1] = 0x87;
 	state->data[2] = 0x0;
 
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err("command 0x0e transfer failed.");
 
 	state->data[0] = 0xe;
-	state->data[1] = 0x02;
+	state->data[1] = 0x86;
 	state->data[2] = 1;
 
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err("command 0x0e transfer failed.");
-	msleep(300);
 
 	state->data[0] = 0xe;
-	state->data[1] = 0x83;
+	state->data[1] = 0x80;
 	state->data[2] = 0;
 
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err("command 0x0e transfer failed.");
 
+	msleep(50);
+
 	state->data[0] = 0xe;
-	state->data[1] = 0x83;
+	state->data[1] = 0x80;
 	state->data[2] = 1;
 
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
@@ -1578,69 +1614,52 @@
 
 	mutex_unlock(&d->data_mutex);
 
-	/* attach demod */
-	m88ds3103_pdata.clk = 27000000;
-	m88ds3103_pdata.i2c_wr_max = 33;
-	m88ds3103_pdata.ts_mode = M88DS3103_TS_CI;
-	m88ds3103_pdata.ts_clk = 16000;
-	m88ds3103_pdata.ts_clk_pol = 0;
-	m88ds3103_pdata.spec_inv = 0;
-	m88ds3103_pdata.agc = 0x99;
-	m88ds3103_pdata.agc_inv = 0;
-	m88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;
-	m88ds3103_pdata.envelope_mode = 0;
-	m88ds3103_pdata.lnb_hv_pol = 1;
-	m88ds3103_pdata.lnb_en_pol = 0;
-	memset(&board_info, 0, sizeof(board_info));
-	strlcpy(board_info.type, "m88ds3103", I2C_NAME_SIZE);
-	board_info.addr = 0x68;
-	board_info.platform_data = &m88ds3103_pdata;
-	request_module("m88ds3103");
-	client = i2c_new_device(&d->i2c_adap, &board_info);
-	if (client == NULL || client->dev.driver == NULL)
-		return -ENODEV;
-	if (!try_module_get(client->dev.driver->owner)) {
-		i2c_unregister_device(client);
-		return -ENODEV;
-	}
-	adap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);
-	i2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);
+	adap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,
+					&d->i2c_adap, NULL);
+	if (adap->fe_adap[0].fe == NULL)
+		return -EIO;
 
-	state->i2c_client_demod = client;
+	if (!dvb_attach(tda18273_attach, adap->fe_adap[0].fe,
+				&d->i2c_adap, 0x60))
+		return -EIO;
 
-	/* attach tuner */
-	ts2020_config.fe = adap->fe_adap[0].fe;
-	memset(&board_info, 0, sizeof(board_info));
-	strlcpy(board_info.type, "ts2022", I2C_NAME_SIZE);
-	board_info.addr = 0x60;
-	board_info.platform_data = &ts2020_config;
-	request_module("ts2020");
-	client = i2c_new_device(i2c_adapter, &board_info);
+	/* hook fe: need to resync the slave fifo when signal locks */
+	state->fe_read_status = adap->fe_adap[0].fe->ops.read_status;
+	adap->fe_adap[0].fe->ops.read_status = su3000_read_status;
 
-	if (client == NULL || client->dev.driver == NULL) {
-		dvb_frontend_detach(adap->fe_adap[0].fe);
-		return -ENODEV;
-	}
+	return 0;
+}
 
-	if (!try_module_get(client->dev.driver->owner)) {
-		i2c_unregister_device(client);
-		dvb_frontend_detach(adap->fe_adap[0].fe);
-		return -ENODEV;
-	}
+static int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	struct dvb_usb_device *d = adap->dev;
+	struct dw2102_state *state = d->priv;
 
-	/* delegate signal strength measurement to tuner */
-	adap->fe_adap[0].fe->ops.read_signal_strength =
-			adap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;
+	mutex_lock(&d->data_mutex);
 
-	state->i2c_client_tuner = client;
+	state->data[0] = 0x51;
 
-	/* hook fe: need to resync the slave fifo when signal locks */
-	state->fe_read_status = adap->fe_adap[0].fe->ops.read_status;
-	adap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;
+	if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
+		err("command 0x51 transfer failed.");
 
-	state->last_lock = 0;
+	mutex_unlock(&d->data_mutex);
 
-	return 0;
+	adap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,
+					&s421_m88rs2000_config,
+					&d->i2c_adap);
+
+	if (adap->fe_adap[0].fe == NULL)
+		return -EIO;
+
+	if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
+				&dw2104_ts2020_config,
+				&d->i2c_adap)) {
+		info("Attached RS2000/TS2020!");
+		return 0;
+	}
+
+	info("Failed to attach RS2000/TS2020!");
+	return -EIO;
 }
 
 static int dw2102_tuner_attach(struct dvb_usb_adapter *adap)
@@ -1672,7 +1691,7 @@
 		if (msg.buf[0] != 0xff) {
 			deb_rc("%s: rc code: %x, %x\n",
 					__func__, key[0], key[1]);
-			rc_keydown(d->rc_dev, RC_TYPE_UNKNOWN, key[0], 0);
+			rc_keydown(d->rc_dev, RC_PROTO_UNKNOWN, key[0], 0);
 		}
 	}
 
@@ -1693,7 +1712,8 @@
 		if (msg.buf[0] != 0xff) {
 			deb_rc("%s: rc code: %x, %x\n",
 					__func__, key[0], key[1]);
-			rc_keydown(d->rc_dev, RC_TYPE_UNKNOWN, key[0]^0xff, 0);
+			rc_keydown(d->rc_dev, RC_PROTO_UNKNOWN, key[0] ^ 0xff,
+				   0);
 		}
 	}
 
@@ -1714,7 +1734,7 @@
 		if (msg.buf[0] != 0xff) {
 			deb_rc("%s: rc code: %x, %x\n",
 					__func__, key[0], key[1]);
-			rc_keydown(d->rc_dev, RC_TYPE_RC5,
+			rc_keydown(d->rc_dev, RC_PROTO_RC5,
 				   RC_SCANCODE_RC5(key[1], key[0]), 0);
 		}
 	}
@@ -1742,13 +1762,20 @@
 	TEVII_S632,
 	TERRATEC_CINERGY_S2_R2,
 	TERRATEC_CINERGY_S2_R3,
+	TERRATEC_CINERGY_S2_R4,
 	GOTVIEW_SAT_HD,
 	GENIATECH_T220,
+	GENIATECH_T220A,
 	TECHNOTREND_S2_4600,
 	TEVII_S482_1,
 	TEVII_S482_2,
-	TERRATEC_CINERGY_S2_BOX,
-	TEVII_S662
+	TERRATEC_DUAL_1,
+	TERRATEC_DUAL_2,
+	TEVII_S662,
+	GENIATECH_X9320_0,
+	GENIATECH_X9320_1,
+	GENIATECH_X9320_2,
+	GENIATECH_X9320_3,
 };
 
 static struct usb_device_id dw2102_table[] = {
@@ -1762,23 +1789,30 @@
 	[PROF_1100] = {USB_DEVICE(0x3011, USB_PID_PROF_1100)},
 	[TEVII_S660] = {USB_DEVICE(0x9022, USB_PID_TEVII_S660)},
 	[PROF_7500] = {USB_DEVICE(0x3034, 0x7500)},
-	[GENIATECH_SU3000] = {USB_DEVICE(0x1f4d, 0x3000)},
+	[GENIATECH_SU3000] = {USB_DEVICE(USB_VID_GTEK, 0x3000)},
 	[TERRATEC_CINERGY_S2] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R1)},
 	[TEVII_S480_1] = {USB_DEVICE(0x9022, USB_PID_TEVII_S480_1)},
 	[TEVII_S480_2] = {USB_DEVICE(0x9022, USB_PID_TEVII_S480_2)},
-	[X3M_SPC1400HD] = {USB_DEVICE(0x1f4d, 0x3100)},
+	[X3M_SPC1400HD] = {USB_DEVICE(USB_VID_GTEK, 0x3100)},
 	[TEVII_S421] = {USB_DEVICE(0x9022, USB_PID_TEVII_S421)},
 	[TEVII_S632] = {USB_DEVICE(0x9022, USB_PID_TEVII_S632)},
 	[TERRATEC_CINERGY_S2_R2] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R2)},
 	[TERRATEC_CINERGY_S2_R3] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R3)},
+	[TERRATEC_CINERGY_S2_R4] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R4)},
 	[GOTVIEW_SAT_HD] = {USB_DEVICE(0x1FE1, USB_PID_GOTVIEW_SAT_HD)},
-	[GENIATECH_T220] = {USB_DEVICE(0x1f4d, 0xD220)},
+	[GENIATECH_T220] = {USB_DEVICE(USB_VID_GTEK, 0xD220)},
+	[GENIATECH_T220A] = {USB_DEVICE(0x0572, 0xC686)},
 	[TECHNOTREND_S2_4600] = {USB_DEVICE(USB_VID_TECHNOTREND,
 		USB_PID_TECHNOTREND_CONNECT_S2_4600)},
 	[TEVII_S482_1] = {USB_DEVICE(0x9022, 0xd483)},
 	[TEVII_S482_2] = {USB_DEVICE(0x9022, 0xd484)},
-	[TERRATEC_CINERGY_S2_BOX] = {USB_DEVICE(USB_VID_TERRATEC, 0x0105)},
+	[TERRATEC_DUAL_1] = {USB_DEVICE(0x153B,0x1181)},
+	[TERRATEC_DUAL_2] = {USB_DEVICE(0x153B,0x1182)},
 	[TEVII_S662] = {USB_DEVICE(0x9022, USB_PID_TEVII_S662)},
+	[GENIATECH_X9320_0] = {USB_DEVICE(USB_VID_GTEK, 0x3300)},
+	[GENIATECH_X9320_1] = {USB_DEVICE(USB_VID_GTEK, 0x3301)},
+	[GENIATECH_X9320_2] = {USB_DEVICE(USB_VID_GTEK, 0x3302)},
+	[GENIATECH_X9320_3] = {USB_DEVICE(USB_VID_GTEK, 0x3303)},
 	{ }
 };
 
@@ -1839,11 +1873,12 @@
 		switch (le16_to_cpu(dev->descriptor.idProduct)) {
 		case USB_PID_TEVII_S650:
 			dw2104_properties.rc.core.rc_codes = RC_MAP_TEVII_NEC;
+			/* fall through */
 		case USB_PID_DW2104:
 			reset = 1;
 			dw210x_op_rw(dev, 0xc4, 0x0000, 0, &reset, 1,
 					DW210X_WRITE_MSG);
-			/* break omitted intentionally */
+			/* fall through */
 		case USB_PID_DW3101:
 			reset = 0;
 			dw210x_op_rw(dev, 0xbf, 0x0040, 0, &reset, 0,
@@ -1876,6 +1911,7 @@
 					break;
 				}
 			}
+			/* fall through */
 		case 0x2101:
 			dw210x_op_rw(dev, 0xbc, 0x0030, 0, &reset16[0], 2,
 					DW210X_READ_MSG);
@@ -1909,7 +1945,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_DM1105_NEC,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_NEC,
+		.allowed_protos   = RC_PROTO_BIT_NEC,
 		.rc_query = dw2102_rc_query,
 	},
 
@@ -1964,7 +2000,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_DM1105_NEC,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_NEC,
+		.allowed_protos   = RC_PROTO_BIT_NEC,
 		.rc_query = dw2102_rc_query,
 	},
 
@@ -2015,7 +2051,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_DM1105_NEC,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_NEC,
+		.allowed_protos   = RC_PROTO_BIT_NEC,
 		.rc_query = dw2102_rc_query,
 	},
 
@@ -2064,7 +2100,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_TEVII_NEC,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_NEC,
+		.allowed_protos   = RC_PROTO_BIT_NEC,
 		.rc_query = dw2102_rc_query,
 	},
 
@@ -2100,46 +2136,46 @@
 };
 
 static struct dvb_usb_device_properties *p1100;
-static struct dvb_usb_device_description d1100 = {
+static const struct dvb_usb_device_description d1100 = {
 	"Prof 1100 USB ",
 	{&dw2102_table[PROF_1100], NULL},
 	{NULL},
 };
 
 static struct dvb_usb_device_properties *s660;
-static struct dvb_usb_device_description d660 = {
+static const struct dvb_usb_device_description d660 = {
 	"TeVii S660 USB",
 	{&dw2102_table[TEVII_S660], NULL},
 	{NULL},
 };
 
-static struct dvb_usb_device_description d480_1 = {
+static const struct dvb_usb_device_description d480_1 = {
 	"TeVii S480.1 USB",
 	{&dw2102_table[TEVII_S480_1], NULL},
 	{NULL},
 };
 
-static struct dvb_usb_device_description d480_2 = {
+static const struct dvb_usb_device_description d480_2 = {
 	"TeVii S480.2 USB",
 	{&dw2102_table[TEVII_S480_2], NULL},
 	{NULL},
 };
 
 static struct dvb_usb_device_properties *p7500;
-static struct dvb_usb_device_description d7500 = {
+static const struct dvb_usb_device_description d7500 = {
 	"Prof 7500 USB DVB-S2",
 	{&dw2102_table[PROF_7500], NULL},
 	{NULL},
 };
 
 static struct dvb_usb_device_properties *s421;
-static struct dvb_usb_device_description d421 = {
+static const struct dvb_usb_device_description d421 = {
 	"TeVii S421 PCI",
 	{&dw2102_table[TEVII_S421], NULL},
 	{NULL},
 };
 
-static struct dvb_usb_device_description d632 = {
+static const struct dvb_usb_device_description d632 = {
 	"TeVii S632 USB",
 	{&dw2102_table[TEVII_S632], NULL},
 	{NULL},
@@ -2158,7 +2194,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_SU3000,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_RC5,
+		.allowed_protos   = RC_PROTO_BIT_RC5,
 		.rc_query = su3000_rc_query,
 	},
 
@@ -2185,20 +2221,24 @@
 		}},
 		}
 	},
-	.num_device_descs = 6,
+	.num_device_descs = 11,
 	.devices = {
 		{ "SU3000HD DVB-S USB2.0",
 			{ &dw2102_table[GENIATECH_SU3000], NULL },
 			{ NULL },
 		},
-		{ "Terratec Cinergy S2 USB HD",
-			{ &dw2102_table[TERRATEC_CINERGY_S2], NULL },
-			{ NULL },
-		},
 		{ "X3M TV SPC1400HD PCI",
 			{ &dw2102_table[X3M_SPC1400HD], NULL },
 			{ NULL },
 		},
+		{ "GOTVIEW Satellite HD",
+			{ &dw2102_table[GOTVIEW_SAT_HD], NULL },
+			{ NULL },
+		},
+		{ "Terratec Cinergy S2 USB HD",
+			{ &dw2102_table[TERRATEC_CINERGY_S2], NULL },
+			{ NULL },
+		},
 		{ "Terratec Cinergy S2 USB HD Rev.2",
 			{ &dw2102_table[TERRATEC_CINERGY_S2_R2], NULL },
 			{ NULL },
@@ -2207,8 +2247,24 @@
 			{ &dw2102_table[TERRATEC_CINERGY_S2_R3], NULL },
 			{ NULL },
 		},
-		{ "GOTVIEW Satellite HD",
-			{ &dw2102_table[GOTVIEW_SAT_HD], NULL },
+		{ "Terratec Cinergy S2 USB HD Rev.4",
+			{ &dw2102_table[TERRATEC_CINERGY_S2_R4], NULL },
+			{ NULL },
+		},
+		{ "Geniatech S2 X9320-0 USB2.0",
+			{ &dw2102_table[GENIATECH_X9320_0], NULL },
+			{ NULL },
+		},
+		{ "Geniatech S2 X9320-1 USB2.0",
+			{ &dw2102_table[GENIATECH_X9320_1], NULL },
+			{ NULL },
+		},
+		{ "Geniatech S2 X9320-2 USB2.0",
+			{ &dw2102_table[GENIATECH_X9320_2], NULL },
+			{ NULL },
+		},
+		{ "Geniatech S2 X9320-2 USB2.0",
+			{ &dw2102_table[GENIATECH_X9320_3], NULL },
 			{ NULL },
 		},
 	}
@@ -2227,7 +2283,7 @@
 		.rc_interval = 150,
 		.rc_codes = RC_MAP_SU3000,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_RC5,
+		.allowed_protos   = RC_PROTO_BIT_RC5,
 		.rc_query = su3000_rc_query,
 	},
 
@@ -2263,6 +2319,55 @@
 	}
 };
 
+static struct dvb_usb_device_properties t220a_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.size_of_priv = sizeof(struct dw2102_state),
+	.power_ctrl = su3000_power_ctrl,
+	.num_adapters = 1,
+	.identify_state	= su3000_identify_state,
+	.i2c_algo = &su3000_i2c_algo,
+
+	.rc.core = {
+		.rc_interval = 150,
+		.rc_codes = RC_MAP_SU3000,
+		.module_name = "dw2102",
+		.allowed_protos   = RC_PROTO_BIT_RC5,
+		.rc_query = su3000_rc_query,
+	},
+
+	.read_mac_address = su3000_read_mac_address,
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+
+	.adapter = {
+		{
+		.num_frontends = 1,
+		.fe = { {
+			.streaming_ctrl   = su3000_streaming_ctrl,
+			.frontend_attach  = t220a_frontend_attach,
+			.stream = {
+				.type = USB_BULK,
+				.count = 8,
+				.endpoint = 0x82,
+				.u = {
+					.bulk = {
+						.buffersize = 4096,
+					}
+				}
+			}
+		} },
+		}
+	},
+	.num_device_descs = 1,
+	.devices = {
+		{ "Geniatech T220A DVB-T/T2 USB2.0",
+			{ &dw2102_table[GENIATECH_T220A], NULL },
+			{ NULL },
+		},
+	}
+};
+
 static struct dvb_usb_device_properties tt_s2_4600_properties = {
 	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
 	.usb_ctrl = DEVICE_SPECIFIC,
@@ -2276,7 +2381,7 @@
 		.rc_interval = 250,
 		.rc_codes = RC_MAP_TT_1500,
 		.module_name = "dw2102",
-		.allowed_protos   = RC_BIT_RC5,
+		.allowed_protos   = RC_PROTO_BIT_RC5,
 		.rc_query = su3000_rc_query,
 	},
 
@@ -2289,7 +2394,7 @@
 		.num_frontends = 1,
 		.fe = {{
 			.streaming_ctrl   = su3000_streaming_ctrl,
-			.frontend_attach  = tt_s2_4600_frontend_attach,
+			.frontend_attach  = su3000_frontend_attach,
 			.stream = {
 				.type = USB_BULK,
 				.count = 8,
@@ -2303,12 +2408,57 @@
 		} },
 		}
 	},
-	.num_device_descs = 5,
+	.num_device_descs = 1,
 	.devices = {
 		{ "TechnoTrend TT-connect S2-4600",
 			{ &dw2102_table[TECHNOTREND_S2_4600], NULL },
 			{ NULL },
 		},
+	}
+};
+
+static struct dvb_usb_device_properties tevii_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.size_of_priv = sizeof(struct dw2102_state),
+	.power_ctrl = su3000_power_ctrl,
+	.num_adapters = 1,
+	.identify_state	= su3000_identify_state,
+	.i2c_algo = &su3000_i2c_algo,
+
+	.rc.core = {
+		.rc_interval = 250,
+		.rc_codes = RC_MAP_TEVII_NEC,
+		.module_name = "dw2102",
+		.allowed_protos   = RC_PROTO_BIT_NEC,
+		.rc_query = su3000_rc_query,
+	},
+
+	.read_mac_address = su3000_read_mac_address,
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+
+	.adapter = {
+		{
+		.num_frontends = 1,
+		.fe = {{
+			.streaming_ctrl   = su3000_streaming_ctrl,
+			.frontend_attach  = su3000_frontend_attach,
+			.stream = {
+				.type = USB_BULK,
+				.count = 8,
+				.endpoint = 0x82,
+				.u = {
+					.bulk = {
+						.buffersize = 4096,
+					}
+				}
+			}
+		} },
+		}
+	},
+	.num_device_descs = 3,
+	.devices = {
 		{ "TeVii S482 (tuner 1)",
 			{ &dw2102_table[TEVII_S482_1], NULL },
 			{ NULL },
@@ -2317,10 +2467,6 @@
 			{ &dw2102_table[TEVII_S482_2], NULL },
 			{ NULL },
 		},
-		{ "Terratec Cinergy S2 USB BOX",
-			{ &dw2102_table[TERRATEC_CINERGY_S2_BOX], NULL },
-			{ NULL },
-		},
 		{ "TeVii S662",
 			{ &dw2102_table[TEVII_S662], NULL },
 			{ NULL },
@@ -2328,13 +2474,68 @@
 	}
 };
 
+static struct dvb_usb_device_properties terratec_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.size_of_priv = sizeof(struct dw2102_state),
+	.power_ctrl = su3000_power_ctrl,
+	.num_adapters = 1,
+	.identify_state	= su3000_identify_state,
+	.i2c_algo = &su3000_i2c_algo,
+
+	.rc.core = {
+		.rc_interval = 250,
+		.rc_codes = RC_MAP_TERRATEC_CINERGY_S2_DUAL,
+		.module_name = "dw2102",
+		.allowed_protos   = RC_PROTO_BIT_NEC,
+		.rc_query = su3000_rc_query,
+	},
+
+	.read_mac_address = su3000_read_mac_address,
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+
+	.adapter = {
+		{
+		.num_frontends = 1,
+		.fe = {{
+			.streaming_ctrl   = su3000_streaming_ctrl,
+			.frontend_attach  = su3000_frontend_attach,
+			.stream = {
+				.type = USB_BULK,
+				.count = 8,
+				.endpoint = 0x82,
+				.u = {
+					.bulk = {
+						.buffersize = 4096,
+					}
+				}
+			}
+		} },
+		}
+	},
+	.num_device_descs = 2,
+	.devices = {
+		{ "Terratec Cinergy S2 Dual (tuner 1)",
+			{ &dw2102_table[TERRATEC_DUAL_1], NULL },
+			{ NULL },
+		},
+		{ "Terratec Cinergy S2 Dual (tuner 2)",
+			{ &dw2102_table[TERRATEC_DUAL_2], NULL },
+			{ NULL },
+		},
+	}
+};
+
 static int dw2102_probe(struct usb_interface *intf,
 		const struct usb_device_id *id)
 {
+	int retval = -ENOMEM;
 	p1100 = kmemdup(&s6x0_properties,
 			sizeof(struct dvb_usb_device_properties), GFP_KERNEL);
 	if (!p1100)
-		return -ENOMEM;
+		goto err0;
+
 	/* copy default structure */
 	/* fill only different fields */
 	p1100->firmware = P1100_FIRMWARE;
@@ -2345,10 +2546,9 @@
 
 	s660 = kmemdup(&s6x0_properties,
 		       sizeof(struct dvb_usb_device_properties), GFP_KERNEL);
-	if (!s660) {
-		kfree(p1100);
-		return -ENOMEM;
-	}
+	if (!s660)
+		goto err1;
+
 	s660->firmware = S660_FIRMWARE;
 	s660->num_device_descs = 3;
 	s660->devices[0] = d660;
@@ -2358,11 +2558,9 @@
 
 	p7500 = kmemdup(&s6x0_properties,
 			sizeof(struct dvb_usb_device_properties), GFP_KERNEL);
-	if (!p7500) {
-		kfree(p1100);
-		kfree(s660);
-		return -ENOMEM;
-	}
+	if (!p7500)
+		goto err2;
+
 	p7500->firmware = P7500_FIRMWARE;
 	p7500->devices[0] = d7500;
 	p7500->rc.core.rc_query = prof_rc_query;
@@ -2372,12 +2570,9 @@
 
 	s421 = kmemdup(&su3000_properties,
 		       sizeof(struct dvb_usb_device_properties), GFP_KERNEL);
-	if (!s421) {
-		kfree(p1100);
-		kfree(s660);
-		kfree(p7500);
-		return -ENOMEM;
-	}
+	if (!s421)
+		goto err3;
+
 	s421->num_device_descs = 2;
 	s421->devices[0] = d421;
 	s421->devices[1] = d632;
@@ -2403,11 +2598,26 @@
 			 THIS_MODULE, NULL, adapter_nr) ||
 	    0 == dvb_usb_device_init(intf, &t220_properties,
 			 THIS_MODULE, NULL, adapter_nr) ||
+	    0 == dvb_usb_device_init(intf, &t220a_properties,
+			 THIS_MODULE, NULL, adapter_nr) ||
 	    0 == dvb_usb_device_init(intf, &tt_s2_4600_properties,
+			 THIS_MODULE, NULL, adapter_nr) ||
+	    0 == dvb_usb_device_init(intf, &tevii_properties,
+			 THIS_MODULE, NULL, adapter_nr) ||
+	    0 == dvb_usb_device_init(intf, &terratec_properties,
 			 THIS_MODULE, NULL, adapter_nr))
 		return 0;
 
-	return -ENODEV;
+	retval = -ENODEV;
+	kfree(s421);
+err3:
+	kfree(p7500);
+err2:
+	kfree(s660);
+err1:
+	kfree(p1100);
+err0:
+	return retval;
 }
 
 static void dw2102_disconnect(struct usb_interface *intf)
@@ -2443,12 +2653,7 @@
 module_usb_driver(dw2102_driver);
 
 MODULE_AUTHOR("Igor M. Liplianin (c) liplianin@me.by");
-MODULE_DESCRIPTION("Driver for DVBWorld DVB-S 2101, 2102, DVB-S2 2104,"
-			" DVB-C 3101 USB2.0,"
-			" TeVii S421, S480, S482, S600, S630, S632, S650,"
-			" TeVii S660, S662, Prof 1100, 7500 USB2.0,"
-			" Geniatech SU3000, T220,"
-			" TechnoTrend S2-4600, Terratec Cinergy S2 devices");
+MODULE_DESCRIPTION("Driver for DVBWorld DVB-S 2101, 2102, DVB-S2 2104, DVB-C 3101 USB2.0, TeVii S421, S480, S482, S600, S630, S632, S650, TeVii S660, S662, Prof 1100, 7500 USB2.0, Geniatech SU3000, T220, TechnoTrend S2-4600, Terratec Cinergy S2 devices");
 MODULE_VERSION("0.1");
 MODULE_LICENSE("GPL");
 MODULE_FIRMWARE(DW2101_FIRMWARE);
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/tbs5520se.c" "b/drivers/media/usb/dvb-usb/tbs5520se.c"
--- "a/drivers/media/usb/dvb-usb/tbs5520se.c"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/tbs5520se.c"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,501 @@
+/*
+ * TurboSight TBS 5520se  driver
+ *
+ * Copyright (c) 2017 Davin <smailedavin@hotmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, version 2.
+ *
+ */
+
+#include <linux/version.h>
+#include "tbs5520se.h"
+#include "si2183.h"
+#include "si2157.h"
+#include "av201x.h"
+
+#define TBS5520se_READ_MSG 0
+#define TBS5520se_WRITE_MSG 1
+
+#define TBS5520se_RC_QUERY (0x1a00)
+#define TBS5520se_VOLTAGE_CTRL (0x1800)
+
+struct tbs5520se_state {
+	struct i2c_client *i2c_client_demod;
+	struct i2c_client *i2c_client_tuner; 
+	u32 last_key_pressed;
+};
+
+static struct av201x_config tbs5520se_av201x_cfg = {
+	.i2c_address = 0x62,
+	.id          = ID_AV2018,
+	.xtal_freq   = 27000,
+};
+
+/* debug */
+static int dvb_usb_tbs5520se_debug;
+module_param_named(debug, dvb_usb_tbs5520se_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level (1=info 2=xfer (or-able))." 
+							DVB_USB_DEBUG_STATUS);
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static int tbs5520se_op_rw(struct usb_device *dev, u8 request, u16 value,
+				u16 index, u8 * data, u16 len, int flags)
+{
+	int ret;
+	void *u8buf;
+
+	unsigned int pipe = (flags == TBS5520se_READ_MSG) ?
+			usb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);
+	u8 request_type = (flags == TBS5520se_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;
+	u8buf = kmalloc(len, GFP_KERNEL);
+	if (!u8buf)
+		return -ENOMEM;
+
+	if (flags == TBS5520se_WRITE_MSG)
+		memcpy(u8buf, data, len);
+	ret = usb_control_msg(dev, pipe, request, request_type | USB_TYPE_VENDOR,
+				value, index , u8buf, len, 2000);
+
+	if (flags == TBS5520se_READ_MSG)
+		memcpy(data, u8buf, len);
+	kfree(u8buf);
+	return ret;
+}
+
+/* I2C */
+static int tbs5520se_i2c_transfer(struct i2c_adapter *adap, 
+					struct i2c_msg msg[], int num)
+{
+	struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	int i = 0;
+	u8 buf6[20];
+	u8 inbuf[20];
+
+	if (!d)
+		return -ENODEV;
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	switch (num) {
+	case 2:
+		buf6[0]=msg[1].len;//lenth
+		buf6[1]=msg[0].addr<<1;//demod addr
+		//register
+		buf6[2] = msg[0].buf[0];
+
+		tbs5520se_op_rw(d->udev, 0x90, 0, 0,
+					buf6, 3, TBS5520se_WRITE_MSG);
+		//msleep(5);
+		tbs5520se_op_rw(d->udev, 0x91, 0, 0,
+					inbuf, buf6[0], TBS5520se_READ_MSG);
+		memcpy(msg[1].buf, inbuf, msg[1].len);
+
+		break;
+	case 1:
+		switch (msg[0].addr) {
+		case 0x67:
+		case 0x62:
+		case 0x61:
+			if (msg[0].flags == 0) {
+				buf6[0] = msg[0].len+1;//lenth
+				buf6[1] = msg[0].addr<<1;//addr
+				for(i=0;i<msg[0].len;i++) {
+					buf6[2+i] = msg[0].buf[i];//register
+				}
+				tbs5520se_op_rw(d->udev, 0x80, 0, 0,
+					buf6, msg[0].len+2, TBS5520se_WRITE_MSG);
+			} else {
+				buf6[0] = msg[0].len;//length
+				buf6[1] = (msg[0].addr<<1) | 0x01;//addr
+				tbs5520se_op_rw(d->udev, 0x93, 0, 0,
+						buf6, 2, TBS5520se_WRITE_MSG);
+				//msleep(5);
+				tbs5520se_op_rw(d->udev, 0x91, 0, 0,
+					inbuf, buf6[0], TBS5520se_READ_MSG);
+				memcpy(msg[0].buf, inbuf, msg[0].len);
+			}
+			//msleep(3);
+		break;
+		case (TBS5520se_VOLTAGE_CTRL):
+			buf6[0] = 3;
+			buf6[1] = msg[0].buf[0];
+			tbs5520se_op_rw(d->udev, 0x8a, 0, 0,
+					buf6, 2, TBS5520se_WRITE_MSG);
+			break;
+		case (TBS5520se_RC_QUERY):
+			tbs5520se_op_rw(d->udev, 0xb8, 0, 0,
+					buf6, 4, TBS5520se_READ_MSG);
+			msg[0].buf[0] = buf6[2];
+			msg[0].buf[1] = buf6[3];
+			//msleep(3);
+			//info("TBS5520se_RC_QUERY %x %x %x %x\n",
+			//		buf6[0],buf6[1],buf6[2],buf6[3]);
+			break;
+		}
+
+		break;
+	}
+
+	mutex_unlock(&d->i2c_mutex);
+	return num;
+}
+
+static u32 tbs5520se_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm tbs5520se_i2c_algo = {
+	.master_xfer = tbs5520se_i2c_transfer,
+	.functionality = tbs5520se_i2c_func,
+};
+
+static int tbs5520se_set_voltage(struct dvb_frontend *fe, 
+						enum fe_sec_voltage voltage)
+{
+	static u8 command_13v[1] = {0x00};
+	static u8 command_18v[1] = {0x01};
+	struct i2c_msg msg[] = {
+		{.addr = TBS5520se_VOLTAGE_CTRL, .flags = 0,
+			.buf = command_13v, .len = 1},
+	};
+	
+	struct dvb_usb_adapter *udev_adap =
+		(struct dvb_usb_adapter *)(fe->dvb->priv);
+	if (voltage == SEC_VOLTAGE_18)
+		msg[0].buf = command_18v;
+
+	//info("tbs5520se_set_voltage %d",voltage);
+	i2c_transfer(&udev_adap->dev->i2c_adap, msg, 1);
+	
+	return 0;
+}
+
+static int tbs5520se_read_mac_address(struct dvb_usb_device *d, u8 mac[6])
+{
+	int i,ret;
+	u8 ibuf[3] = {0, 0,0};
+	u8 eeprom[256], eepromline[16];
+
+	for (i = 0; i < 256; i++) {
+		ibuf[0]=1;//lenth
+		ibuf[1]=0xa0;//eeprom addr
+		ibuf[2]=i;//register
+		ret = tbs5520se_op_rw(d->udev, 0x90, 0, 0,
+					ibuf, 3, TBS5520se_WRITE_MSG);
+		ret = tbs5520se_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBS5520se_READ_MSG);
+			if (ret < 0) {
+				err("read eeprom failed.");
+				return -1;
+			} else {
+				eepromline[i%16] = ibuf[0];
+				eeprom[i] = ibuf[0];
+			}
+			
+			if ((i % 16) == 15) {
+				deb_xfer("%02x: ", i - 15);
+				debug_dump(eepromline, 16, deb_xfer);
+			}
+	}
+	memcpy(mac, eeprom + 16, 6);
+	return 0;
+};
+
+static struct dvb_usb_device_properties tbs5520se_properties;
+
+static int tbs5520se_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	struct dvb_usb_device *d = adap->dev;
+	struct tbs5520se_state *st = d->priv;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client_demod;
+	struct i2c_client *client_tuner;
+	struct i2c_board_info info;
+	struct si2183_config si2183_config;
+	struct si2157_config si2157_config;
+	u8 buf[20];
+
+	/* attach frontend */
+	memset(&si2183_config,0,sizeof(si2183_config));
+	si2183_config.i2c_adapter = &adapter;
+	si2183_config.fe = &adap->fe_adap[0].fe;	
+	si2183_config.ts_mode = SI2183_TS_PARALLEL;
+	si2183_config.ts_clock_gapped = true;
+	si2183_config.rf_in = 0;
+	si2183_config.RF_switch = NULL;
+	si2183_config.fef_pin = SI2183_MP_B;
+	si2183_config.fef_inv = 0;
+	si2183_config.agc_pin = SI2183_MP_D;
+	si2183_config.ter_agc_inv = 0;
+	si2183_config.sat_agc_inv = 1;
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	strlcpy(info.type, "si2183", I2C_NAME_SIZE);
+	info.addr = 0x67;
+	info.platform_data = &si2183_config;
+	request_module(info.type);
+	client_demod = i2c_new_device(&d->i2c_adap, &info);
+	if (client_demod == NULL || client_demod->dev.driver == NULL)
+		return -ENODEV;
+
+	if (!try_module_get(client_demod->dev.driver->owner)) {
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+
+	st->i2c_client_demod = client_demod;
+
+	/* dvb core doesn't support 2 tuners for 1 demod so
+	   we split the adapter in 2 frontends */
+
+	adap->fe_adap[0].fe2 = &adap->fe_adap[0]._fe2;
+	memcpy(adap->fe_adap[0].fe2, adap->fe_adap[0].fe, sizeof(struct dvb_frontend));
+
+	/* terrestrial tuner */
+	memset(adap->fe_adap[0].fe->ops.delsys, 0, MAX_DELSYS);
+	adap->fe_adap[0].fe->ops.delsys[0] = SYS_DVBT;
+	adap->fe_adap[0].fe->ops.delsys[1] = SYS_DVBT2;
+	adap->fe_adap[0].fe->ops.delsys[2] = SYS_DVBC_ANNEX_A;
+	adap->fe_adap[0].fe->ops.delsys[3] = SYS_ISDBT;
+	adap->fe_adap[0].fe->ops.delsys[4] = SYS_DVBC_ANNEX_B;
+
+	/* attach ter tuner */
+	memset(&si2157_config, 0, sizeof(si2157_config));
+	si2157_config.fe = adap->fe_adap[0].fe;
+	si2157_config.if_port = 1;
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	strlcpy(info.type, "si2157", I2C_NAME_SIZE);
+	info.addr = 0x61;
+	info.platform_data = &si2157_config;
+	request_module(info.type);
+	client_tuner = i2c_new_device(adapter, &info);
+	if (client_tuner == NULL || client_tuner->dev.driver == NULL) {
+		module_put(client_demod->dev.driver->owner);
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+	if (!try_module_get(client_tuner->dev.driver->owner)) {
+		i2c_unregister_device(client_tuner);
+		module_put(client_demod->dev.driver->owner);
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+
+	st->i2c_client_tuner = client_tuner;
+
+	memset(adap->fe_adap[0].fe2->ops.delsys, 0, MAX_DELSYS);
+	adap->fe_adap[0].fe2->ops.delsys[0] = SYS_DVBS;
+	adap->fe_adap[0].fe2->ops.delsys[1] = SYS_DVBS2;
+	adap->fe_adap[0].fe2->ops.delsys[2] = SYS_DSS;
+	adap->fe_adap[0].fe2->id = 1;
+
+	if (!dvb_attach(av201x_attach, adap->fe_adap[0].fe2, &tbs5520se_av201x_cfg,
+			adapter))
+			return -ENODEV;
+	buf[0] = 1;
+	buf[1] = 0;
+	tbs5520se_op_rw(d->udev, 0x8a, 0, 0,
+			buf, 2, TBS5520se_WRITE_MSG);
+	adap->fe_adap[0].fe2->ops.set_voltage = tbs5520se_set_voltage;
+
+	buf[0] = 0;
+	buf[1] = 0;
+	tbs5520se_op_rw(d->udev, 0xb7, 0, 0,
+			buf, 2, TBS5520se_WRITE_MSG);
+	buf[0] = 8;
+	buf[1] = 1;
+	tbs5520se_op_rw(d->udev, 0x8a, 0, 0,
+			buf, 2, TBS5520se_WRITE_MSG);
+
+	return 0;
+}
+
+static struct usb_device_id tbs5520se_table[] = {
+	{USB_DEVICE(0x734c, 0x5521)},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(usb, tbs5520se_table);
+
+static int tbs5520se_load_firmware(struct usb_device *dev,
+			const struct firmware *frmwr)
+{
+	u8 *b, *p;
+	int ret = 0, i;
+	u8 reset;
+	const struct firmware *fw;
+	switch (dev->descriptor.idProduct) {
+	case 0x5521:
+		ret = request_firmware(&fw, tbs5520se_properties.firmware, &dev->dev);
+		if (ret != 0) {
+			err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details "
+			"on firmware-problems.", tbs5520se_properties.firmware);
+			return ret;
+		}
+		break;
+	default:
+		fw = frmwr;
+		break;
+	}
+	info("start downloading TBS5520se firmware");
+	p = kmalloc(fw->size, GFP_KERNEL);
+	reset = 1;
+	/*stop the CPU*/
+	tbs5520se_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, TBS5520se_WRITE_MSG);
+	tbs5520se_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, TBS5520se_WRITE_MSG);
+
+	if (p != NULL) {
+		memcpy(p, fw->data, fw->size);
+		for (i = 0; i < fw->size; i += 0x40) {
+			b = (u8 *) p + i;
+			if (tbs5520se_op_rw(dev, 0xa0, i, 0, b , 0x40,
+					TBS5520se_WRITE_MSG) != 0x40) {
+				err("error while transferring firmware");
+				ret = -EINVAL;
+				break;
+			}
+		}
+		/* restart the CPU */
+		reset = 0;
+		if (ret || tbs5520se_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,
+					TBS5520se_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+		if (ret || tbs5520se_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,
+					TBS5520se_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+
+		msleep(100);
+		kfree(p);
+	}
+	return ret;
+}
+
+static struct dvb_usb_device_properties tbs5520se_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.firmware = "dvb-usb-tbsqbox-id5521.fw",
+	.size_of_priv = sizeof(struct tbs5520se_state),
+	.no_reconnect = 1,
+
+	.i2c_algo = &tbs5520se_i2c_algo,
+
+	.generic_bulk_ctrl_endpoint = 0x81,
+	/* parameter for the MPEG2-data transfer */
+	.num_adapters = 1,
+	.download_firmware = tbs5520se_load_firmware,
+	.read_mac_address = tbs5520se_read_mac_address,
+	.adapter = {{
+		.num_frontends = 1,
+		.fe = {{
+			.frontend_attach = tbs5520se_frontend_attach,
+			.streaming_ctrl = NULL,
+			.tuner_attach = NULL,
+			.stream = {
+				.type = USB_BULK,
+				.count = 8,
+				.endpoint = 0x82,
+				.u = {
+					.bulk = {
+						.buffersize = 4096,
+					}
+				}
+			},
+		},
+/*			{
+				.frontend_attach = tbs5520se_satfrontend_attach,
+				.streaming_ctrl = NULL,
+				.tuner_attach = NULL,
+				.stream = {
+					.type = USB_BULK,
+					.count = 8,
+					.endpoint = 0x82,
+					.u = {
+						.bulk = {
+							.buffersize = 4096,
+						}
+					}
+				},
+			},*/
+
+		},
+		
+	}},
+
+	.num_device_descs = 1,
+	.devices = {
+		{"TBS 5520se USB2.0",
+			{&tbs5520se_table[0], NULL},
+			{NULL},
+		}
+	}
+};
+
+static int tbs5520se_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	if (0 == dvb_usb_device_init(intf, &tbs5520se_properties,
+			THIS_MODULE, NULL, adapter_nr)) {
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static void tbs5520se_disconnect(struct usb_interface *intf)
+{
+	struct dvb_usb_device *d = usb_get_intfdata(intf);
+	struct tbs5520se_state *st = d->priv;
+	struct i2c_client *client;
+
+	/* remove I2C client for tuner */
+	client = st->i2c_client_tuner;
+	if (client) {
+		module_put(client->dev.driver->owner);
+		i2c_unregister_device(client);
+	}
+
+	/* remove I2C client for demodulator */
+	client = st->i2c_client_demod;
+	if (client) {
+		module_put(client->dev.driver->owner);
+		i2c_unregister_device(client);
+	}
+
+	dvb_usb_device_exit(intf);
+}
+
+static struct usb_driver tbs5520se_driver = {
+	.name = "tbs5520se",
+	.probe = tbs5520se_probe,
+	.disconnect = tbs5520se_disconnect,
+	.id_table = tbs5520se_table,
+};
+
+static int __init tbs5520se_module_init(void)
+{
+	int ret =  usb_register(&tbs5520se_driver);
+	if (ret)
+		err("usb_register failed. Error number %d", ret);
+
+	return ret;
+}
+
+static void __exit tbs5520se_module_exit(void)
+{
+	usb_deregister(&tbs5520se_driver);
+}
+
+module_init(tbs5520se_module_init);
+module_exit(tbs5520se_module_exit);
+
+MODULE_AUTHOR("Davin <smiledavin@hotmail.com>");
+MODULE_DESCRIPTION("TurboSight TBS 5520se driver");
+MODULE_VERSION("1.0");
+MODULE_LICENSE("GPL");
diff -U 3 -H -d -r -N -- "a/drivers/media/usb/dvb-usb/tbs5520se.h" "b/drivers/media/usb/dvb-usb/tbs5520se.h"
--- "a/drivers/media/usb/dvb-usb/tbs5520se.h"	1970-01-01 08:00:00.000000000 +0800
+++ "b/drivers/media/usb/dvb-usb/tbs5520se.h"	2017-12-07 05:52:26.000000000 +0800
@@ -0,0 +1,8 @@
+#ifndef _TBS5520SE_H_
+#define _TBS5520SE_H_
+
+#define DVB_USB_LOG_PREFIX "tbs5520se"
+#include "dvb-usb.h"
+
+#define deb_xfer(args...) dprintk(dvb_usb_tbs5520se_debug, 0x02, args)
+#endif
diff --git a/drivers/media/usb/dvb-usb/cxusb.c b/drivers/media/usb/dvb-usb/cxusb.c
index 3b3661b30b2b..12fb3b727bb2 100644
--- a/drivers/media/usb/dvb-usb/cxusb.c
+++ b/drivers/media/usb/dvb-usb/cxusb.c
@@ -1485,6 +1485,7 @@ enum cxusb_table_index {
 	MYGICA_D689,
 	MYGICA_T230,
 	MYGICA_T230C,
+	MYGICA_T230C2,
 	NR__cxusb_table_index
 };
 
@@ -1555,6 +1556,9 @@ static struct usb_device_id cxusb_table[NR__cxusb_table_index + 1] = {
 	[MYGICA_T230C] = {
 		USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230+1)
 	},
+	[MYGICA_T230C2] = {
+		USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230+2)
+	},
 	{}		/* Terminating entry */
 };
 MODULE_DEVICE_TABLE (usb, cxusb_table);
@@ -2309,12 +2313,19 @@ static struct dvb_usb_device_properties cxusb_mygica_t230c_properties = {
 		.allowed_protos = RC_BIT_UNKNOWN,
 	},
 
-	.num_device_descs = 1,
+	.num_device_descs = 2,
 	.devices = {
 		{
 			"Mygica T230C DVB-T/T2/C",
 			{ NULL },
 			{ &cxusb_table[MYGICA_T230C], NULL },
+		  
+		},
+		{
+			"Mygica T230C2 DVB-T/T2/C",
+			{ NULL },
+			{ &cxusb_table[MYGICA_T230C2], NULL },
+		  
 		},
 	}
 };
